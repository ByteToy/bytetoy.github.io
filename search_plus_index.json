{"./":{"url":"./","title":"简介","keywords":"","body":"Welcome to Bytetoy.cn Day day up,good good study! 欢迎臭味相投的朋友交流，QQ：12620716 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-09-30 11:43:56 "},"python/":{"url":"python/","title":"Python","keywords":"","body":"人生苦短，我用Python \"Life is short. You need Python\" --Bruce Eckel 高中《信息技术》课程Python教学，边学边教^_^ 参考资料 递归&回溯算法 队列&栈&链表 Hello算法 Colab 线性回归分析 代码仓库 Github 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-13 23:10:30 "},"python/python_queue.html":{"url":"python/python_queue.html","title":"Python队列","keywords":"","body":"Python队列 FIFO 一、单向队列 使用list实现队列基本的方式: 队首head:list最后一个list[-1]元素，出队(pop)的位置，使用list.pop实现 队尾tail：list第一个list[0]元素，入队(push)的位置，使用list.insert实现 入列(push) 使用list.insert()方法，在list第一个元素[0]位置插入数据项 出列(pop) 使用list.pop()方法，将list最后一个元素[-1]位置弹出数据项 class Queue: def __init__(self): self.items=[] def push(self,item): self.items.insert(0,item) def pop(self): return self.items.pop() def is_empty(self): return self.items==[] def size(self): return len(self.items) if __name__==\"__main__\": queue=Queue() queue.push('first') queue.push('second') queue.push('third') queue.push('forth') print(queue.size()) print(queue.items) print(queue.pop()) print(queue.items) print(queue.pop()) print(queue.items) print(queue.size()) 二、双向队列 双向队列，队首、队尾均可入队、出队 使用list实现队列基本的方式: 队首head:list的最后一个list[-1]元素 队尾tail：list的第一个list[0]元素 队首操作 push_head:使用list.append()方法实现，在list的最后一个位置[-1]添加元素 pop_head:使用list.pop()方法实现，将list最后一个位置[-1]元素弹出 队尾操作 push_tail:使用list.insert(0)方法实现，在list[0]位置插入一个元素 pop_tail:使用list.pop(0)，将list[0]元素弹出 class DoubleQueue: def __init__(self): self.items=[] def push_tail(self, item): self.items.insert(0,item) def pop_tail(self): return self.items.pop(0) def push_head(self,item): self.items.append(item) def pop_head(self): return self.items.pop() def is_empty(self): return self.items==[] def size(self): return len(self.items) if __name__==\"__main__\": queue=DoubleQueue() queue.push_tail('first') queue.push_tail('second') queue.push_tail('third') queue.push_tail('forth') print(queue.size()) print(queue.items) print(queue.pop_head()) print(queue.items) queue.push_tail(\"five\") print(queue.items) print(queue.pop_tail()) print(queue.items) queue.push_head(\"zero\") print(queue.items) print(queue.size()) print(queue.is_empty()) 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-01-02 13:08:25 "},"python/python_stack.html":{"url":"python/python_stack.html","title":"Python栈","keywords":"","body":"Python栈 FILO 使用list简单实现栈 表示方式 栈顶：list的最后一个元素[-1] 栈底：list的第一个元素[0] 出入栈 入栈：使用list.append()向列表最后一个位置添加一个元素 出栈：使用list.pop()弹出list的最后一个元素 class Stack: def __init__(self): self.items=[] def push(self,item): self.items.append(item) def pop(self): return self.items.pop() def size(self): return len(self.items) def is_empty(self): return self.items==[] if __name__==\"__main__\": stack=Stack() stack.push(\"one\") stack.push(\"two\") print(stack.size()) print(stack.items) stack.push(\"three\") stack.push(\"four\") print(stack.size()) print(stack.items) print(stack.pop()) print(stack.size()) print(stack.items) 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-01-02 13:18:35 "},"python/recursion.html":{"url":"python/recursion.html","title":"Python递归算法及其简单应用","keywords":"","body":"Python递归算法及其简单应用 一、递归算法 递归算法是一个相对较抽象的问题，有点像套娃，一开始不怎么好理解。 一旦抓住了核心思路，理解起来就相对容易了。 递归问题要点： 边界条件（终止条件）：否则将无限循环 子问题必须与原问题结构一致，但是输入规模小于原问题的规模（即要求问题分解和循环计算） 递归解题思路： 假设问题有解，且函数为Fun(p)，p为函数的输入； 可将原问题分解为为n个子问题，即P1，P2，P3，....Pn 由于原问题的函数为Fun，因此求解各子问题的函数依然为Fun() 子问题对应输入元素个数（规模）要小于原问题的输入元素 建立子问题的解与原问题的关系： Fun(p)=Fun(P1)+Fun(P2)+Fun(P3)......+Fun(Pn) 根据以上关系得到递归结构 子问题最简形式存在解（边界或终止条件） 二、斐波那契函数 题目简单明了，函数和终止条件已经说明 题目： f(n)=f(n-1)+f(n-2) f(0)=0 #终止条件1 f(1)=1 #终止条件2 def fib_recursion(n): if n 三、回文判断 题目： 正向与反向读都是相同字符串 如：noon，上海自来水来自海上，黄山落叶松叶落山黄 解题思路： 先假设输入的字符串是回文 定义回文函数：is_pal_recursion(input_str) 分析终止条件： 如果最后只有一个字符，是回文，返回True 如果最后只有零个字符，是回文，返回True len(input_str) 分解子问题： input_str[0]==input_str[-1] and is_pal_recursion(input_str[1:-1]) def is_pal_recursion(input_str): print(input_str) if len(input_str) 四、全排列 题目： 输入字符串为N个不相同字符，输出N个字符的全排列 解题思路 假设题目存在解，定义函数为：per(s) 终止条件：s的长度为1，len(s) 分解子问题： s[i]+per(s-s[i]) #s-s[i]为s[i]以外的字符串，字符串长度为n-1 对字符串s先提取一个，然后对剩余字符串重复调用自身 每一次重复调用自身时，需要将提取的一个字符加上剩余的字符，然后加入到list中 def per(s): lens=len(s) if lens 五、汉诺塔 题目： 小盘必须在大盘上面 每次只能移动一个盘子 解题思路： 假设问题有解，定义函数：hanoi(n,src,des,tmp) 边界条件：柱子上只有一个盘子，此时仅需移动一个盘子即可 第一步：启动hanoi函数 第二步：将n-1个盘子移动到临时柱子（tmp）上； 第三步：将底部盘子（第n个盘子）移动到目标柱子上； 第四步：重复调用递归函数，将n-1个盘子移动到目标柱子上。 step = 1 def hanoi(num, src, des, tmp): if num 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-01-03 16:56:29 "},"python/sudoku.html":{"url":"python/sudoku.html","title":"Python回溯算法解数独","keywords":"","body":"Python回溯算法解数独 Python解数独题目，基本的方式就是通过回溯和递归，网上的案例很多，这里我是一步一步分析，然后解决这个问题，顺便讲解递归算法的应用。 题目：download-csv 完整代码：download-sudoku.py 一、题目说明 题目如下，其中空白格用0代替 表格第一行是列标题，不是题目内容。大概数一下，空格有50多个。 1 2 3 4 5 6 7 8 9 1 2 9 0 0 6 0 3 0 0 0 0 0 0 0 0 6 0 0 0 6 0 8 0 1 0 0 0 7 0 0 2 9 0 0 0 0 0 1 0 7 0 9 0 0 0 0 0 5 1 0 0 2 0 0 0 4 0 9 0 8 0 0 0 8 0 0 0 0 0 0 0 0 3 0 1 0 0 2 5 9 二、解题思路 1. 读取&加载题目 数独原始文件放在一个csv文件中，通过pandas读取，然后经过处理： 对空白格处填充0，dataframe.fillna(0, inplace=True) pandas读取的数据，默认是float类型，需要将数据类型转化为int，dataframe[i] = dataframe[i].astype(int) 将pandas读取的数据为dataframe，需要进一步转化为list，方便使用下标进行操作，self.data = dataframe.values def __init__(self, file_path): self.data = None self.blank = None self.file_path = file_path def load(self): dataframe = pd.read_csv(self.file_path, sep=',', header=None) dataframe.fillna(0, inplace=True) for i in range(9): dataframe[i] = dataframe[i].astype(int) self.data = dataframe.values 2. 读取空白格 空白格（填充0）就是需要填入数字的内容，先读取list，判断有多少个空格。 将需要填充的空格放入list，后续通过回溯和递归算法，处理空格内容。 def search_blank(self): blank_list = [] for r in range(9): for c in range(9): if self.data[r][c] == 0: blank_list.append([r, c]) self.blank = blank_list return blank_list 3. 判断空白格数字有效性 根据数独的规则，行、列以及小九宫格内数字是唯一的，需要验证填入的数字是否有效。 这里三个规则的判断是分别分开验证，方便理解和学习。 小九宫格判断 根据空白格的位置（pos），对九宫格（3×3）遍历，填入数字（num）是否符合规则 # pos是一个list，定义了表格的row和col # 验证一个数num在对应的区块中是否符合规则 def block_valid(self, num, pos): row_start = (pos[0] // 3) * 3 col_start = (pos[1] // 3) * 3 row_end = row_start + 2 col_end = col_start + 2 for r in range(row_start, row_end + 1): for c in range(col_start, col_end + 1): # print(r, c, self.data[r][c]) if num == self.data[r][c]: return False return True 行内数据判断 对行内9个数进行遍历，填入数据（num）是否符合规则。 def row_valid(self, num, pos): for c in range(9): # print(pos[0], c, self.data[pos[0]][c]) if num == self.data[pos[0]][c]: return False return True 列内数据判断 对列内9个数进行遍历，填入数据（num）是否符合规则。 def col_valid(self, num, pos): for r in range(9): # print(r, pos[1], self.data[r][pos[1]]) if num == self.data[r][pos[1]]: return False return True 4. 回溯算法处理 通过回溯和递归处理全部空白格，是解数独的核心。 经过前面的处理（读取数据、查找空白格、对行、列、九宫格判断），下一步就是使用回溯和递归逐个处理空白格 处理空白格的逻辑很简单，从1-9验证每个空格填入数字是否可行： 递归的终止条件：空白格list全部处理完为空，即list 长度为0:if len(self.blank) == 0:return True 尝试从1-9逐个取出数据（for循环），然后从空白格list中弹出(pop)一个空白格填入，验证行、列、九宫格是否符合数独规则 如果符合规则，使用递归再次调用此函数； 如何不符合规则，将此空白格再次压入(append)空白格list中，同时此空白格填充0，回溯至上一步 直到全部处理完毕，或者没有正确的解，返回False def backtrace(self): if len(self.blank) == 0: self.show_table() return True else: for num in range(1, 10, 1): pos = self.blank[-1] if self.block_valid(num, pos) and self.row_valid(num, pos) and self.col_valid(num, pos): self.data[pos[0]][pos[1]] = num # self.show_table() self.blank.pop() if self.backtrace(): return True self.data[pos[0]][pos[1]] = 0 self.blank.append(pos) return False 题目答案为： 将表格打印的注释取消，可以观察到，解数独的过程是从表格的最后一个数字开始演算，这就符合题目的思路，空白格list是从最后一个元素先处理，这个元素就是整个数独表的最后一个空白格。 其次就是，解数独用到列回溯，list中空白格的弹出和压入，就是一个回溯的过程； 同时，解数独用到了递归，在前一个空白格填入的数字符合行、列以及九宫格要求后，再次调用函数自身，进行下一个空白格的处理，直到全部空白格处理完毕（空白格list为0，递归终止条件），表明数据全部解题完毕 1 2 3 4 5 6 7 8 9 1 2 9 4 5 6 7 3 8 7 4 8 9 3 1 5 6 2 3 5 6 2 8 7 1 9 4 4 7 5 6 2 9 3 8 1 2 6 1 8 7 3 9 4 5 8 9 3 5 1 4 6 2 7 5 1 4 3 9 2 8 7 6 9 8 2 7 6 5 4 1 3 6 3 7 1 4 8 2 5 9 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-01-04 16:03:06 "},"python/colab_setting.html":{"url":"python/colab_setting.html","title":"Colab开发环境配置","keywords":"","body":"配置Colab开发环境 一、环境配置 这里使用Google家的colab，免费又好用。 登录Gooelg drive 创建colab环境 新建-->更多-->关联更多应用:然后应用市场搜索搜索colab 如果之前已经使用过colab,则更多中会出现google colaboratory 链接 进入环境后,点击右上角connect,链接资源环境,开始启用colab 开通GPU Edit-->notebook settins-->Hardware accelerator:选择T4 GPU,输入!nvidia-smi然后运行,会显示以下GPU信息 Wed Jan 10 08:31:14 2024 +---------------------------------------------------------------------------------------+ | NVIDIA-SMI 535.104.05 Driver Version: 535.104.05 CUDA Version: 12.2 | |-----------------------------------------+----------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |=========================================+======================+======================| | 0 Tesla T4 Off | 00000000:00:04.0 Off | 0 | | N/A 51C P8 9W / 70W | 0MiB / 15360MiB | 0% Default | | | | N/A | +-----------------------------------------+----------------------+----------------------+ +---------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=======================================================================================| | No running processes found | +---------------------------------------------------------------------------------------+ 二、使用Drive资源 挂载drive 运行下列代码时,会提示要求授权 from google.colab import drive drive.mount('/content/drive') 挂载成功后会返回Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True). 挂载后drive的根路径为:/content/drive/My Drive,我的文件是在drive的子目录下,所以完整路径为:/content/drive/My Drive/01/Salary_Data.csv 使用drive资源 import pandas as pd url='/content/drive/My Drive/01/Salary_Data.csv' print(pd.read_csv(url)) 使用pandas读取csv表格后会返回表格内容 YearsExperience Salary 0 0.3 36.2 1 0.6 36.6 2 0.8 42.8 3 1.1 39.3 4 1.3 46.2 5 1.5 37.7 6 2.0 43.5 7 2.2 39.8 8 2.9 56.6 9 3.0 60.1 10 3.2 54.4 11 3.2 64.4 12 3.7 57.1 13 3.9 63.2 14 4.0 55.7 15 4.0 56.9 16 4.1 57.0 17 4.5 61.1 18 4.9 67.9 19 5.1 66.0 20 5.3 83.0 21 5.9 81.3 22 6.0 93.9 23 6.8 91.7 24 7.1 98.2 25 7.9 101.3 26 8.2 113.8 27 8.7 109.4 28 9.0 105.5 29 9.5 116.9 30 9.6 112.6 31 10.3 122.3 32 10.5 121.8 三、安装中文字体 默认情况下，colab无法显示中文，需要自行安装字体 如果没有中文字体,在matplotlib中使用汉字,会报错. /usr/local/lib/python3.10/dist-packages/IPython/core/pylabtools.py:151: UserWarning: Glyph 24180 (\\N{CJK UNIFIED IDEOGRAPH-5E74}) missing from current font. fig.canvas.print_figure(bytes_io, **kw) /usr/local/lib/python3.10/dist-packages/IPython/core/pylabtools.py:151: UserWarning: Glyph 36164 (\\N{CJK UNIFIED IDEOGRAPH-8D44}) missing from current font. fig.canvas.print_figure(bytes_io, **kw) /usr/local/lib/python3.10/dist-packages/IPython/core/pylabtools.py:151: UserWarning: Glyph 25955 (\\N{CJK UNIFIED IDEOGRAPH-6563}) missing from current font. fig.canvas.print_figure(bytes_io, **kw) /usr/local/lib/python3.10/dist-packages/IPython/core/pylabtools.py:151: UserWarning: Glyph 28857 (\\N{CJK UNIFIED IDEOGRAPH-70B9}) missing from current font. fig.canvas.print_figure(bytes_io, **kw) /usr/local/lib/python3.10/dist-packages/IPython/core/pylabtools.py:151: UserWarning: Glyph 22270 (\\N{CJK UNIFIED IDEOGRAPH-56FE}) missing from current font. fig.canvas.print_figure(bytes_io, **kw) 安装字体 安装字体前需要安装wget,使用wget下载字体 这里下载的字体是ChineseFont.ttf !pip install wget import wget wget.download(\"https://drive.usercontent.google.com/download?id=10SXzZFfsoMTC9b7UZLnfse7tIprMI8Bh&export=download&authuser=0&confirm=t&uuid=ccf99670-d41f-4cb9-aaa6-1516a85097ea&at=APZUnTU8zDUUTF7m46xF5zVcYb04:1704939398929\") 字体安装成功后,会有一个输出提示 Requirement already satisfied: wget in /usr/local/lib/python3.10/dist-packages (3.2) ChineseFont.ttf 使用字体 import matplotlib.pyplot as plt import pandas as pd import matplotlib as mlp from matplotlib.font_manager import fontManager fontManager.addfont(\"ChineseFont.ttf\") mlp.rc(\"font\",family=\"ChineseFont\") url='/content/drive/My Drive/01/Salary_Data.csv' dataframe=pd.read_csv(url) x=dataframe['YearsExperience'] y=dataframe['Salary'] plt.title(\"工龄薪水图\") plt.xlabel(\"工龄\") plt.ylabel(\"薪资\") plt.scatter(x,y,marker=\"*\",color=\"red\",label=\"真实数据\") plt.show() 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-01-11 10:42:26 "},"python/linklist.html":{"url":"python/linklist.html","title":"Python单向链表","keywords":"","body":"Python单向链表 单向链表增、删、查、改操作 单向链表的使用，主要注意插入和删除这两项。 一、节点及链表定义 使用和操作链表，需要先定义节点。 节点至少包含两个变量: item:节点包含的数据内容 next:节点指针指向 节点定义 class LinkNode: def __init__(self, val): self.item = val self.next = None 链表定义 定义一个__head变量，指向链表的头部，初始化时，无元素，赋值None class LinkList: def __init__(self): self.__head: LinkNode = None 二、链表遍历 遍历即为访问链表的全部元素： 定一个cur变量为游标,从头部开始循环依次向后移动 直到节点为None时,说明尾部再无其他节点,到达链表尾部,循环终止 def travel(self): cur = self.__head while cur is not None: print(cur.item, end='\\t') cur = cur.next print() 三、链表查找 链表查找与遍历类似: 循环遍历整个链表,找到指定元素,返回True, 全部遍历完毕,未找到指定元素,返回False def search(self, val): cur = self.__head while cur is not None: if cur.item == val: # print(cur.item,id(cur)) return True cur = cur.next print(\"Not found {}\".format(val)) return False 四、链表插入节点 链表插入分为3种情况,头部,尾部以及中间插入 头部插入节点 新建一个节点; 新节点的指针指向链表的头部__head 将__head指向新节点 def addHead(self, val): node = LinkNode(val) node.next = self.__head self.__head = node 尾部插入节点 首先判断链表是否为None,如为None即为空链表,则直接让__head指向新节点即可 游标cur遍历至最后一个节点;最后一个节点就是指针指向为None的节点 新建一个节点 将尾部节点指向新节点,即游标cur指向新节点 注意:这里的遍历方式(while循环)与遍历中的终止调节条件略有不同,因为需要用到游标cur,让游标指向新节点 def addtail(self, val): node = LinkNode(val) if self.__head is None: self.__head = node else: cur: LinkNode = self.__head while cur.next is not None: cur = cur.next cur.next = node 中间插入节点 先判断插入位置pos与链表的长度,判断是在头部插入,还是在尾部插入; 根据指定位置插入新节点,同list操作,位置从0开始计算 首先需要将游标cur移动到指定位置pos的前一个元素,即pos-1处,这里使用count计数,需要小于pos-1 将新节点指向游标cur的下一个节点,即cur的next; 将游标cur指向新节点 中间插入注意2点: 游标cur需要指向位置pos的前一个节点; 注意插入节点指针链接的顺序,先将新节点指向下一个节点,然后将游标指向新节点 def insert(self, pos, val): if pos = self.length(): self.addtail(val) else: cur = self.__head count = 0 # 注意计数方式，count从0开始，即要即算到pos-1位置 while count 五、链表删除节点 链表操作中,删除元素相对较复杂 定义两个游标变量:cur指向遍历的当前节点,pre指向上一个节点 遍历链表整个链表,游标cur和pre逐次向后移动,直到cur内容为删除的内容,或者cur遍历至最后一个节点 遍历过程: 如果找到指定元素,即游标cur指向的节点内容与删除内容相等 如果删除内容是链表的头节点__head是要删除的元素,则直接将__head指向下一个元素即可,self.__head = cur.next 如果要删除的内容不是头结点__head,此时,游标cur指向的是找到的节点,pre为前一个节点,则此时只需要将pre指向cur的下一个节点,pre.next = cur.next 如果遍历游标cur不是指定的内容,则将cur和pre继续向后移动,直到找到,或者链表全部遍历,pre = cur cur = cur.next def remove(self, val): cur = self.__head pre = None while cur is not None: if cur.item == val: # 判断删除的元素是否为第一个元素（head） if cur == self.__head: print(\"find:{}\".format(val)) self.__head = cur.next else: # 如果不是第一个元素，则将上一个元素指向下下个元素 pre.next = cur.next return True # 一个迭代，将pre指向当前元素，cur进入下一个元素 else: pre = cur cur = cur.next return False 六、其他功能函数 判断链表为空 如果链表为空,则头部指针__head为None def is_empty(self): return self.__head is None 计算链表长度 同遍历功能,从头部开始计数 def length(self): count = 0 cur = self.__head while cur is not None: cur = cur.next count += 1 return count 七、完成代码 class LinkNode: def __init__(self, val): self.item = val self.next = None class LinkList: def __init__(self): self.__head: LinkNode = None def addHead(self, val): node = LinkNode(val) node.next = self.__head self.__head = node # 注意，这里的while中与traval函数不同。next为None，表明无后续节点，已经遍历到最后一个节点 # travel函数则是判断node为None，表明本节点无数据，退出循环 # ==比较的是值，is not None比较的是地址 def addtail(self, val): node = LinkNode(val) if self.__head is None: self.__head = node else: cur: LinkNode = self.__head while cur.next is not None: cur = cur.next cur.next = node def search(self, val): cur = self.__head while cur is not None: if cur.item == val: # print(cur.item,id(cur)) return True cur = cur.next print(\"Not found {}\".format(val)) return False def find(self, pos): cur = self.__head count = 0 if pos >= 0 and pos = self.length(): self.addtail(val) else: cur = self.__head count = 0 # 注意计数方式，count从0开始，即要即算到pos-1位置 while count 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-01-29 22:07:04 "},"python/cyclelink.html":{"url":"python/cyclelink.html","title":"Python单向循环链表","keywords":"","body":"Python单向循环链表 单向循环链表与单向链表类似,在操作上,最主要的区别在于判断链表结束的方式. 单链表结束,游标cur或next的值为None 循环链表结束,游标cur或next值为__head,即指向头部指针 这就导致遍历、插入、删除判断条件不同 学习本节请先阅读上一节：Python单向链表 一、节点及链表定义 循环链表的与单向链表相同 节点定义class LinkNode: def __init__(self, val): self.item = val self.next = None 链表定义class CycleLinkList: def __init__(self): self.__head: LinkNode = None 二、链表遍历 注意这里while循环结束方式,是与单链表最大的区别之一. while cur.next != self.__head:,此时游标cur指向最后一个节点,但尚未输出,因此循环结束后,需要输出最后一个元素,即print(cur.item) def travel(self): if self.is_empty(): print(\"linklist id empty\") return cur = self.__head while cur.next != self.__head: print(cur.item, end=\" \") cur = cur.next # 此时cur位于最后一个节点，他的next指向__head，但是在while循环中并未打印 print(cur.item) 三、链表查找 这里与循环链表的遍历travel类似,while循环结束后,最后一个节点在while中未进行比较,需要在循环外进行比较操作if cur.item==val: def search(self,val): if self.is_empty(): return False cur=self.__head while cur.next!=self.__head: if cur.item==val: return True cur=cur.next if cur.item==val: return True return False 四、链表插入节点 循环链表的插入与单链表类似,同样需要考虑三种情况:头部插入,尾部插入,中间插入 循环链表首尾相连,头部插入和尾部插入,貌似都是在最后面插入一个节点,但是头部插入需要移动head指针,而尾部插入无须移动head指针 中间插入与单链表相同 头部插入 先将游标cur移动至尾部; 将新节点指向头部 将游标cur指向新节点 移动head指针指向新节点 def addHead(self, val): node = LinkNode(val) # 链表为空，head指向node，同时node指向自己 if self.is_empty(): self.__head = node node.next = node cur = self.__head while cur.next != self.__head: cur = cur.next node.next = self.__head # 下面两个顺序没有先后 cur.next = node self.__head = node 尾部插入 尾部插入节点与单链表基本相同: 将游标cur移动到链表尾部 将尾部指向新节点:cur的next指向node 将新节点指向链表头部 def addTail(self,val): node=LinkNode(val) if self.is_empty(): self.__head=node node.next=node cur=self.__head while cur.next!=self.__head: cur=cur.next # node节点链接首尾，head位置不变，这里与在头部插入不同 cur.next=node node.next=self.__head 中间插入 中间插入与单链表基本相同 def insert(self,pos,val): if pos=self.length(): self.addTail(val) else: node = LinkNode(val) cur=self.__head count=0 while count 五、链表删除节点 循环链表的删除应该是操作最复杂的功能,需要对三种情况进行逐一理解: 头部删除:如果删除元素在链表头部,需要另定义一个游标rear循环至链表尾部,然后将头部head向后移,将rear指向head 中间删除:中间删除与单链表类似,不做介绍,同单链表的处理,设置2个游标:pre和cur 尾部删除:循环链表的while循环结束后,游标cur在尾部,但没有在while循环中进行处理,因此当查找元素在尾部时,跳出循环后需要单独处理.同时要考虑当链表只有一个节点时,while循环时没有执行的,因此也需要在这里处理. def remove(self,val): cur=self.__head pre=None if self.is_empty(): return False while cur.next!=self.__head: if cur.item==val: # 如果需要删除的元素是在头部，则需要再定义一个游标变量rear，循环至尾部，然后让head指向下一个元素，让 if cur==self.__head: rear=self.__head while rear.next!=self.__head: rear=rear.next # 由于头部节点已经删除，需要将head向后移动一位，并将尾部（rear）指向新的头部 self.__head=cur.next rear.next=self.__head else: pre.next=cur.next return True else: pre=cur cur=cur.next # 跳出循环后，cur位于链表尾部，开始比较尾部是否为要删除数据 if cur.item==val: # 判断链表是否只有一个元素，即cur==__head if cur==self.__head: self.__head=None else: pre.next=cur.next return True # 没有找到元素，返回False return False 六、其他功能函数 判断链表为空 此处同单链表操作,判断头部指针即可 def is_empty(self): return self.__head is None 计算链表长度 这里需要注意的是,count从1开始计数,由于前面已经判断链表是否为空None 且while循环判断条件与单链表不同,当只有一个节点时,while循环未启动;当游标cur到最后一个节点时,count在while循环也为+1,所以count计数从1开始. def length(self): if self.is_empty(): return 0 cur = self.__head # 这里count的从1开始，注意while循环的终止条件，此时cur到最后一个元素即跳出循环，而count没有即会+1 count = 1 # 游标又回到头部节点，即链表遍历完毕，返回链表长度 while cur.next != self.__head: count += 1 cur = cur.next return count 七、完整代码 class LinkNode: def __init__(self, val): self.item = val self.next = None class CycleLinkList: def __init__(self): self.__head: LinkNode = None def is_empty(self): return self.__head is None def length(self): if self.is_empty(): return 0 cur = self.__head # 这里count的从1开始，注意while循环的终止条件，此时cur到最后一个元素即跳出循环，而count没有即会+1 count = 1 # 游标又回到头部节点，即链表遍历完毕，返回链表长度 while cur.next != self.__head: count += 1 cur = cur.next return count def travel(self): if self.is_empty(): print(\"linklist id empty\") return cur = self.__head while cur.next != self.__head: print(cur.item, end=\" \") cur = cur.next # 此时cur位于最后一个节点，他的next指向__head，但是在while循环中并未打印 print(cur.item) def search(self,val): if self.is_empty(): return False cur=self.__head while cur.next!=self.__head: if cur.item==val: return True cur=cur.next if cur.item==val: return True return False def addHead(self, val): node = LinkNode(val) # 链表为空，head指向node，同时node指向自己 if self.is_empty(): self.__head = node node.next = node cur = self.__head while cur.next != self.__head: cur = cur.next node.next = self.__head # 下面两个顺序没有先后 cur.next = node self.__head = node def addTail(self,val): node=LinkNode(val) if self.is_empty(): self.__head=node node.next=node cur=self.__head while cur.next!=self.__head: cur=cur.next # node节点链接首尾，head位置不变，这里与在头部插入不同 cur.next=node node.next=self.__head def insert(self,pos,val): if pos=self.length(): self.addTail(val) else: node = LinkNode(val) cur=self.__head count=0 while count 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-01-30 12:19:49 "},"python/pycharm_github_token.html":{"url":"python/pycharm_github_token.html","title":"Github配置token提交代码","keywords":"","body":"Github配置token提交代码 使用Pycharm提交代码，用token比使用密码更方便，也没有使用SSH KEY麻烦。 Github生成token Settings-->Developer Settings-->Personal access tokens-->Tokens(classic) Note 就是这个token的名字，或者用途，随便取一个即可 Expiration token的过期时间，根据自己的情况设置 Select scopes token的全校配置，在pycharm中使用token登录，必须设置以下几项： 其他项目可选可不选。 [x] repo [x] workflow [ ] admin:org [x] read:org [x] gist [ ] user [x] read:user [x] user:email Pycharm添加token File-->Settings-->Version Control-->Github-->Log in with token 然后填入github的网址和token 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-08 21:05:17 "},"python/binary_tree_travel.html":{"url":"python/binary_tree_travel.html","title":"Python二叉树遍历","keywords":"","body":"Python二叉树的遍历 一、二叉树几个概念 注意区分几个概念： 二叉树的高度与层； 二叉树的高度是从最底部起算，而深度是从根节点起算； 基本术语 节点所在的层 level：从顶至底递增，根节点所在层为 1 节点的度 degree：节点的子节点的数量。在二叉树中，度的取值范围是[ 0、1、2] 。即节点所拥有叶子节点的数量 二叉树的高度 height：从根节点到最远叶节点所经过的边的数量。 节点的深度 depth：从根节点到该节点所经过的边的数量。 节点的高度 height：从距离该节点最远的叶节点到该节点所经过的边的数量。 树的类型 完美二叉树：所有层的节点都被完全填满，满二叉树，叶节点的度为0，其余所有节点的度都为2；若树的高度为h，则节点总数为2^(h+1)-1，如一个高度h=3的满二叉树，即有根节点到底节点共有4层，一共有15个节点（第一层1个，第二层2个，第三层4个，第四层8个） 完全二叉树：只有最底层的节点未被填满，且最底层节点尽量靠左填充。 完满二叉树：除了叶节点之外，其余所有节点都有两个子节点，即节点的度，要么为0，要么为2 平衡二叉树：任意节点的左子树和右子树的高度之差的绝对值不超过 1 二、列表转换为二叉树 将列表元素按照层顺序，逐层填满二叉树，即转换之后的二叉树是一个完全二叉树 计算公式： 当前元素的下标为i，如：第0个元素； 其左节点的下标为i×2+1，如：第0个元素的，左节点下标为1； 其右节点的效标为i×2+2，如：第0个元素，右节点的下标为2； 整体上通过递归方式实现，边界（返回）条件为列表下标越界，或者元素为None； 由于要获取元素的左、右两个子节点，因此递归中需要两次调用函数本身，获取左右子节点 # 使用递归方式，将list转换为二叉树，按层的顺序实现转换 # 先判断arr的下标start是否越界，然后再新建节点 def create_btree(arr, start): if start = len(arr) or arr[start] is None: return None root = TreeNode(arr[start]) root.left = create_btree(arr, start * 2 + 1) root.right = create_btree(arr, start * 2 + 2) return root 三、广度优先遍历 广度优先（breadth-first traversal），即按层遍历二叉树的所有节点，逐层访问全部节点的方式 实现方式：（队列） 使用标准库（collections)中的deque双向链表类作为列表 使用while循环，当队列为None是终止循环 读取根节点，同时获取左右子节点，按照顺序将左右节点加入(append)队列；append 弹出（popleft)队列中节点，同时获取其左右自节点，按照顺序将左右节点加入队列; 弹出队列的节点时，将节点元素内容存入列表。 # 广度优先（breadth-first traversal）方式遍历二叉树 # 以队列方式实现，按层进行遍历 def bfs_travel(root): res = [] queue = deque() queue.append(root) while queue: node: TreeNode = queue.popleft() res.append(node.val) if node.left is not None: queue.append(node.left) if node.right is not None: queue.append(node.right) return res 四、深度优先遍历 深度优先分为前序、中序以及后序方式，区分的依据为访问根节点的顺序，前序即为先访问根节点，然后依次访问左右节点；中序为先访问左节点，然后依次访问根、右节点；后序为依次访问左节点、右节点、根节点。 二叉树搜索即为中序方式，左节点递归 边界（返回）条件：节点为None 然后依次调用函数本身，访问左、右节点，根据前序、中序、后序需要，访问根节点元素 前序遍历 res_pre=[] # 深度优先就是使用递归方式 # 深度优先（depth-first search）：前序遍历 # 前序遍历：根节点-左子树-右子树 # 中序遍历：左子树-根节点-右子树 # 后续遍历：左子树-右子树-根节点 def dfs_pre(root:TreeNode): # 递归边界（返回条件）：节点为None if root is None: return # 访问根节点 res_pre.append(root.val) # 递归处理左子树 dfs_pre(root=root.left) # 递归处理右子树 dfs_pre(root=root.right) 中序遍历 res_mid=[] # 深度优先遍历：中序方式，左子树-根节点-右子树 # 如果是一个有序的二叉树，中序遍历出来的元素就是一个有序的列表，左节点 五、完整代码 from typing import Optional # deque是collections中的双向链表实现 from collections import deque class TreeNode: def __init__(self, val: int): self.val: int = val self.left: Optional[TreeNode] = None self.right: Optional[TreeNode] = None # 使用递归方式，将list转换为二叉树，按层的顺序实现转换 # 先判断arr的下标start是否越界，然后再新建节点 def create_btree(arr, start): if start = len(arr) or arr[start] is None: return None root = TreeNode(arr[start]) root.left = create_btree(arr, start * 2 + 1) root.right = create_btree(arr, start * 2 + 2) return root # 广度优先（breadth-first traversal）方式遍历二叉树 # 以队列方式实现，按层进行遍历 def bfs_travel(root): res = [] queue = deque() queue.append(root) while queue: node: TreeNode = queue.popleft() res.append(node.val) if node.left is not None: queue.append(node.left) if node.right is not None: queue.append(node.right) return res res_pre=[] # 深度优先就是使用递归方式 # 深度优先（depth-first search）：前序遍历 # 前序遍历：根节点-左子树-右子树 # 中序遍历：左子树-根节点-右子树 # 后续遍历：左子树-右子树-根节点 def dfs_pre(root:TreeNode): # 递归边界（返回条件）：节点为None if root is None: return # 访问根节点 res_pre.append(root.val) # 递归处理左子树 dfs_pre(root=root.left) # 递归处理右子树 dfs_pre(root=root.right) res_mid=[] # 深度优先遍历：中序方式，左子树-根节点-右子树 # 如果是一个有序的二叉树，中序遍历出来的元素就是一个有序的列表，左节点鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-12 23:49:37 "},"python/binary_tree_array.html":{"url":"python/binary_tree_array.html","title":"Python二叉树列表表示","keywords":"","body":"Python二叉树列表表示 在前一节：Python二叉树遍历，介绍二叉树的遍历操作是以链表方式进行的，本次介绍以列表下操作，在以列表表示二叉树时，就是上一节中“列表转换为二叉树”的思路。 在二叉树的遍历中，介绍了将列表转换为二叉树（链表形式），其中介绍了左右子节点的计算公式： 左节点下标：i×2+1 右节点下标：i×2+2 本介绍主要依据以上两个公式展开，同时介绍由子节点计算负节点。 需要注意的是，二叉树多数情况下不是完美二叉树或者完全二叉树，节点可能会只有一个子节点，那么另一个子节点需要用None存储在列表中。 一、基本方法 获取根节点左节点下标 def getLeft(self, i): return i * 2 + 1 获取节点父节点下标# 注意计算公式 def getPar(self, i): return (i - 1) // 2 获取节点值# 注：是>= def getVar(self, i): if i = self.size(): return None return self.__tree[i] 获取左节点值 def getLeftVar(self, i): return self.getVar(self.getLeft(i)) 二、广度优先遍历 用列表表示二叉树，本身就是将列表按层来存储和表示列表，因此，直接返回列表的值即可。 但是使用过程中，需要注意二叉树中的只有一个子节点的情况，此时需要过滤掉值为None的节点。 # 广度优先遍历，即返回数组即可 def bfs_travel(self): for i in range(self.size()): if self.__tree[i] is not None: self.__res.append(self.getVar(i)) 三、深度优先遍历 深度优先遍历，同上一节链表的使用方式相同，通过递归的方式来实现 边界（终止）条件：子节点的元素为None 然后根据前序、中序、后序要求，访问根节点、左节点、右节点 这里访问左右子节点的方式不同，不再通过链表指针实现，二是通过计算左右子节点在列表的下标实现。 前序遍历 # 深度优先遍历-前序方式 # 当元素为None，表明无子节点，回溯返回。这里无须再次判断是否数组越界，因元素为None，就是无子树了，不进行下一步，回溯即可。 def dfs_pre(self, i): if self.getVar(i) is None: return self.__res.append(self.getVar(i)) self.dfs_pre(self.getLeft(i)) self.dfs_pre(self.getRight(i)) 中序遍历 def dfs_mid(self, i): if self.getVar(i) is None: return self.dfs_mid(self.getLeft(i)) self.__res.append(self.getVar(i)) self.dfs_mid(self.getRight(i)) 四、完整代码 class BinaryTreeList: def __init__(self, arr): self.__tree = list(arr) self.__res = [] def size(self): return len(self.__tree) # 注：是>= def getVar(self, i): if i = self.size(): return None return self.__tree[i] def getLeft(self, i): return i * 2 + 1 def getRight(self, i): return i * 2 + 2 # 注意计算公式 def getPar(self, i): return (i - 1) // 2 def getLeftVar(self, i): return self.getVar(self.getLeft(i)) def getRightVar(self, i): return self.getVar(self.getRight(i)) def getParVar(self, i): return self.getVar(self.getPar(i)) # 广度优先遍历，即返回数组即可 def bfs_travel(self): for i in range(self.size()): if self.__tree[i] is not None: self.__res.append(self.getVar(i)) # 深度优先遍历-前序方式 # 当元素为None，表明无子节点，回溯返回。这里无须再次判断是否数组越界，因元素为None，就是无子树了，不进行下一步，回溯即可。 def dfs_pre(self, i): if self.getVar(i) is None: return self.__res.append(self.getVar(i)) self.dfs_pre(self.getLeft(i)) self.dfs_pre(self.getRight(i)) def dfs_mid(self, i): if self.getVar(i) is None: return self.dfs_mid(self.getLeft(i)) self.__res.append(self.getVar(i)) self.dfs_mid(self.getRight(i)) # res定义在构造函数中，如果不清空，多种方法append后，列表内部元素会不断增加 def clear(self): self.__res = [] def getRes(self): return self.__res 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-13 23:12:56 "},"python/binary_tree_search.html":{"url":"python/binary_tree_search.html","title":"Python二叉搜索树操作","keywords":"","body":"Python二叉搜索树操作 二叉搜索树，可以理解为一个有序二叉树，其要求为：左子树节点的值，即按照深度优先中序遍历方式出来的列表，是一个有序列表。 一、遍历二叉树 二叉搜索树的遍历同二叉树相同，可以广度优先，也可以深度优先。 这里重新实现了两种遍历方式，目的是在测试的时候，可以输出二叉树的内容。 广度优先遍历 使用队列实现 # 广度优先遍历 def bfs(self): self.__res=[] queue = deque() queue.append(self.__root) while queue: node: TreeNode = queue.popleft() self.__res.append(node.val) if node.left is not None: queue.append(node.left) if node.right is not None: queue.append(node.right) return self.__res 深度优先遍历 使用递归实现 注意，这里借用别人写的一种方式，注意区分dfs函数中if的写法 # 深度优先搜索 # 这一段是看了别人的写法，很有意思 # 注意if判断的位置和含义 def dfs(self,node,order): cur = node if node is None: return if order=='pre': self.__res.append(cur.val) self.dfs(cur.left,order) if order=='mid': self.__res.append(cur.val) self.dfs(cur.right,order) if order=='post': self.__res.append(cur.val) # 深度优先遍历-中序 # 中序遍历，应该返回一个有序的列表 def dfs_mid(self): cur=self.__root self.__res=[] self.dfs(cur,'mid') return self.__res def dfs_pre(self): cur=self.__root self.__res=[] self.dfs(cur,'pre') return self.__res 二、搜索节点 二叉搜索树本身就是一个有序的树，当查找内容小于根节点时，进入左子树；当查找内容大于根节时，进入右子树。 value>cur.val，进入右子树继续搜索，cur=cur.right value，进入左子树继续搜索，cur=cur.left 在遍历整个树的过程中，类似一种深度优先的方式向下前进。 注意这里while循环，如果在循环中找到内容，即返回True；如果在循环中未找到内容，则循环结束后返回False，即未找到内容。 # 当value> 当前节点，跳至当前节点的右子节点 # 当valuebool: cur = self.__root while cur is not None: if cur.val value: cur = cur.left else: return True return False 三、插入节点 为了保证左子树 成立，插入的新节点始终为叶子节点，即在二叉树的底部，有了这个思路，插入就容易理解了。 实现方式： while循环中，按照深度优先的方式进行搜索，直到cur==None（空节点说明找到父节点的位置了），表明到达最底部，跳出循环； 判断插入元素与父节点的大小，选择插入方向 注意点： 需要定义两个指针变量：pre（记录父节点）和cur（记录当前节点） 当cur为None时，说明已经到二叉树的底部，此时pre指向的是父节点的位置，新节点挂在下面 需要判断插入的节点是否已经在二叉树中存在，如果已经存在，则无须其他操作，退出函数即可return 需要判断树是否为空None，如果是空树，直接将内容填入根即可self.__root=TreeNode(value) # 考虑两种情况，数为空None和非空，为空则建立一个新节点，然后root指向即可 # 树非空时，则根据搜索的原理，沿着路径向下走，直到空节点（cur），此时pre为父节点 # 判断value与pre节点的大小，然后在左右插入节点。 def insert(self, value): if self.__root is None: self.__root=TreeNode(value) return cur=self.__root pre=None while cur is not None: if cur.val==value: return pre=cur if cur.val四、删除节点 相对来讲，删除节点比较复杂，考虑的情况较多。 判断删除元素的类型：无叶子节点，只有一个叶子节点的节点，有两个节点的节点。即考虑节点的度degree 需要判断树是否为空self.__root is None 需要判断删除的元素，在二叉树中是否存在，如不存在即返回False 删除节点为无叶子节点（节点的度为0） 无叶子节点时，此种情况最容易，将此节点的父节点left或right指向None 删除节点有一个叶子节点（节点的度为1） 只有一个叶子节点时，用叶子节点代替本节点的位置 删除节点有两个叶子节点（节点的度为2） 有两个叶子节点时，删除当前节点后，还需要找到替代当前节点的元素。根据搜索二叉树的特点，有两种替代方式：右子树的最小节点或左子树的最大节点 右子树最小节点：右子树沿着最左边一路向下最底部节点 左子树最大几点：左子树沿着最右边一路向下最底部节点 代码实现流程 判断二叉树是否为空None，如果为空，返回False，肯定是无法删除元素； 深度优先方式遍历二叉树，找到待删除的元素，中断while循环；如果未找到待删除的元素，此时cur=None 当未找到待删除元素时，返回False，也是无法删除元素的； 处理只有0、或者一个子树情况： 先获取子节点（可能为None或者是一个节点），然后进行两层判断，先判断待删除元素是否为根节点，然后判断子节点是左、右节点， 替换相应的节点 处理有2个子树情况： 找到右子树的最小节点，通过while循环走到右子树的最左边底部，获取此节点； 删除此节点（将父节点的这个指针指向None，已经最底部了，值可能为None） 替换节点内容：cur.val=tmp.val 此时，全部流程处理完毕，该返回False的两种情况已经处理，且节点已经删除或者替换，返回True。 # 删除元素，删除成功返回True，失败返回False def remove(self,value)->bool: # 首先判断树是否为空 if self.__root is None: return False cur=self.__root pre=None # 遍历二叉树，查找待删除的元素 # 找到元素跳出循环，否则继续循环，直到二叉树遍历结束 # 注：如果未找到元素，此时cur=None，找到元素时，cur=该元素，而pre则为父节点 while cur is not None: if cur.val==value: break pre=cur if cur.val五、全部代码 from collections import deque from typing import Optional class TreeNode: def __init__(self, val: int): self.val: int = val self.left: Optional[TreeNode] = None self.right: Optional[TreeNode] = None class BinaryTreeSearch: def __init__(self): self.__root: TreeNode = None self.__res=[] # 广度优先遍历 def bfs(self): self.__res=[] queue = deque() queue.append(self.__root) while queue: node: TreeNode = queue.popleft() self.__res.append(node.val) if node.left is not None: queue.append(node.left) if node.right is not None: queue.append(node.right) return self.__res # 深度优先搜索 # 这一段是看了别人的写法，很有意思 # 注意if判断的位置和含义 def dfs(self,node,order): cur = node if node is None: return if order=='pre': self.__res.append(cur.val) self.dfs(cur.left,order) if order=='mid': self.__res.append(cur.val) self.dfs(cur.right,order) if order=='post': self.__res.append(cur.val) # 深度优先遍历-中序 # 中序遍历，应该返回一个有序的列表 def dfs_mid(self): cur=self.__root self.__res=[] self.dfs(cur,'mid') return self.__res def dfs_pre(self): cur=self.__root self.__res=[] self.dfs(cur,'pre') return self.__res # 当value> 当前节点，跳至当前节点的右子节点 # 当valuebool: cur = self.__root while cur is not None: if cur.val value: cur = cur.left else: return True return False # 考虑两种情况，数为空None和非空，为空则建立一个新节点，然后root指向即可 # 树非空时，则根据搜索的原理，沿着路径向下走，直到空节点（cur），此时pre为父节点 # 判断value与pre节点的大小，然后在左右插入节点。 def insert(self, value): if self.__root is None: self.__root=TreeNode(value) return cur=self.__root pre=None while cur is not None: if cur.val==value: return pre=cur if cur.valbool: # 首先判断树是否为空 if self.__root is None: return False cur=self.__root pre=None # 遍历二叉树，查找待删除的元素 # 找到元素跳出循环，否则继续循环，直到二叉树遍历结束 # 注：如果未找到元素，此时cur=None，找到元素时，cur=该元素，而pre则为父节点 while cur is not None: if cur.val==value: break pre=cur if cur.val鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-13 23:06:45 "},"python/python_heap.html":{"url":"python/python_heap.html","title":"Python堆操作","keywords":"","body":"Python堆操作 大顶堆的实现与操作 一、概念 堆heap：用于表示优先队列 是一个完全二叉树，最底层节点靠左填充，其他层的节点都被填满； 小顶堆：任意节点的值 大顶堆：任意节点的值> 左右子节点 堆通常用于实现优先队列，大顶堆相当于元素按从大到小的顺序出队的优先队列。 堆的表示：完全二叉树，用列表表示，通过映射公式计算父节点、左右子节点的列表下标： 左子节点的索引为：i×2+1 右子节点的索引为：i×2+2 父节点的索引为：(i-1)//2 二、入堆(push) 在堆中新添加一个元素，使用列表的append方法添加至列表的尾部，然后通过向上移动此元素，通过比较大小，使其符合大顶堆的定义。 向上移动实现: while循环从新节点开始向上遍历，比较当前节点与父节点的大小 如果当前节点大于父节点，则两个节点互相交换 然后继续循环向上比较两个节点 while循环终止条件：如果当前节点小于父节点，则终止（隐含条件：原列表已经符合堆的规则，父节点大于左右子节点） # 新元素入堆 def push(self, value): # 将新元素添加至尾部 self.max_heap.append(value) # 向上移动末尾节点 self.shift_up(self.size() - 1) # 新元素入堆后，需要向上移动至合适位置 def shift_up(self, i): while True: # 获取父节点 p = self.getPar(i) # 终止循环条件：达到根节点或者子节点小于根节点 if p 三、堆顶出堆(pop) 将堆顶节点（列表第0个元素）与堆最后一个节点（列表最后1个元素）互换，然后列表弹出最后一个元素（pop），即堆顶元素。同时对新的堆，从堆顶进行向下移动，以其符合堆的规则。 向下移动实现 从堆顶循环遍历整个堆，将新的堆顶元素与左右子节点比较； 如果堆顶节点小于左右子节点，则与左右节点中最大的节点互换； 进入互换元素的子节点，循环执行上述步骤； while循环终止条件：数组遍历结束（达到数组最大长度位置）或者父节点大于左右子节点（符合堆的定义），注意这个步骤：if mx == i: # 堆顶元素出堆 def pop(self): if self.isEmpty(): raise IndexError(\"空堆\") # 堆顶元素与尾部元素互换 self.swap(0, self.size() - 1) # 弹出堆顶元素，此时堆顶元素在最尾部，pop即可 value = self.max_heap.pop() # 堆顶新元素向下移动 self.shift_down(0) return value # 堆顶元素向下移动 def shift_down(self, i): while True: # 定义三个变量，当前元素、左节点、右节点的数组下标，默认最大值的下标为当前元素 l, r, mx = self.getLeft(i), self.getRight(i), i # 找到三个变量中最大的元素 # 如果左节点大于最大元素，将mx为左节点 if l 四、其他功能函数 初始化建堆 新建一个空堆，然后将列表元素逐个入堆（push），这相当于在堆列表尾部依次添加元素，然后将最末尾元素逐渐线上移动的过程。 def __init__(self, nums): self.max_heap = [] #自顶向下建堆，逐个元素压入堆 for i in nums: self.push(i) 五、全部代码 # 自定义堆的实现，大顶堆 class MaxHeap: def __init__(self, nums): self.max_heap = [] #自顶向下建堆，逐个元素压入堆 for i in nums: self.push(i) def getVal(self, i): # 这里需要判断是否越界，否则深度优先遍历会报错 if i = self.size(): return None return self.max_heap[i] def getLeft(self, i): return i * 2 + 1 def getRight(self, i): return i * 2 + 2 def getPar(self, i): return (i - 1) // 2 def size(self): return len(self.max_heap) def isEmpty(self): return self.size() == 0 def dfs_mid(self): self.__res=[] self.dfs(0,'mid') return self.__res # 深度优先遍历 def dfs(self,i,order): if self.getVal(i) is None: return if order=='pre': self.__res.append(self.getVal(i)) self.dfs(self.getLeft(i),order) if order=='mid': self.__res.append(self.getVal(i)) self.dfs(self.getRight(i),order) if order=='post': self.__res.append(self.getVal(i)) # 交换堆内的两个节点内容 # python独特的变量互换写法 def swap(self, i, j): self.max_heap[i], self.max_heap[j] = self.max_heap[j], self.max_heap[i] def peek(self): return self.max_heap[0] # 新元素入堆 def push(self, value): # 将新元素添加至尾部 self.max_heap.append(value) # 向上移动末尾节点 self.shift_up(self.size() - 1) # 新元素入堆后，需要向上移动至合适位置 def shift_up(self, i): while True: # 获取父节点 p = self.getPar(i) # 终止循环条件：达到根节点或者子节点小于根节点 if p 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-15 00:22:56 "},"python/python_graph_matrix.html":{"url":"python/python_graph_matrix.html","title":"Python无向图邻接矩阵实现","keywords":"","body":"Python无向图邻接矩阵实现 一、无向图邻接矩阵表示 Python使用邻接矩阵实现无向图，通过两个列表存储数据：一个列表存储顶点，一个二维列表存储边。 构造函数 邻接矩阵构造函数内含两个成员变量： 顶点:一维列表存储顶点，self.verts = [] 边:二维列表构成一个N*N矩阵（N为顶点个数），相连的两个顶点在对应的行和列位置填充1，未相连填充0，self.mats = [] def __init__(self, verts, edges): # 顶点是一个列表 self.verts = [] # 边是一个二维列表，是根据顶点N×N的二维列表（数组） self.mats = [] for v in verts: self.add_vert(v) for e in edges: self.add_edge(e[0], e[1]) 二、无向图增加顶点 增加顶点有三个操作步骤： 在顶点列表中新增一个元素：self.verts.append(val) 在边列表中新增一行：self.mats.append(row) 在边列表中新增一列，即为每一行新增一个元素，通过while循环遍历列表中的每一行，然后在行中增加一列（包含上一步中新增的一行）：``` for row in self.mats: row.append(0) # 添加顶点 def add_vert(self, val): # n = self.size() # 顶点列表添加新元素 self.verts.append(val) row = [0] * n # 边列表添加一行 self.mats.append(row) # 边列表添加一列（每一行增加一个元素） for row in self.mats: row.append(0) 三、无向图删除顶点 删除顶点与增加顶点步骤相同，唯一不同点是增加顶点是在顶点列表的尾部添加（append），而删除顶点则是可能删除任意顶点，因此pop需要指定下标，同样三个步骤： 顶点列表中删除（pop）一个顶点元素：self.verts.pop(i) 边列表中删除指定顶点所在的行：self.mats.pop(i) 边列表中删除一列，即为每一行删除一个元素，通过while循环遍历边列表的每一行，然后在行中删除指定的下标元素：``` for row in self.mats: row.pop(i) # 删除顶点,根据顶点的索引删除 def remove_vert(self, i): if self.size() == 0: raise IndexError(\"矩阵为空\") # 顶点列表移除指定索引顶点 self.verts.pop(i) # 边列表移除指定索引顶点行 self.mats.pop(i) # 按行遍历边列表，逐行删除指定索引所在的列 for row in self.mats: row.pop(i) 四、无向图边操作 无向图中的边操作：新增和删除相对比较简单。唯一需要注意的是，边连接的是两个顶点，而邻接矩阵是对角线对称的，因此需要操作两次，即对顶点的行和列均需要进行操作。 注意：增加、删除边时，不能为同一个顶点增加边if r = self.size() or c >= self.size() or r == c: # c:行索引，r：列索引 def add_edge(self, r, c): if r = self.size() or c >= self.size() or r == c: raise IndexError('越界') self.mats[r][c] = 1 self.mats[c][r] = 1 def remove_edge(self, r, c): if r = self.size() or c >= self.size() or r == c: raise IndexError('越界') self.mats[r][c] = 0 self.mats[c][r] = 0 五、全部代码 from prettytable import PrettyTable class GraphMatrix: def __init__(self, verts, edges): # 顶点是一个列表 self.verts = [] # 边是一个二维列表，是根据顶点N×N的二维列表（数组） self.mats = [] for v in verts: self.add_vert(v) for e in edges: self.add_edge(e[0], e[1]) def size(self): return len(self.verts) # 添加顶点 def add_vert(self, val): # n = self.size() # 顶点列表添加新元素 self.verts.append(val) row = [0] * n # 边列表添加一行 self.mats.append(row) # 边列表添加一列（每一行增加一个元素） for row in self.mats: row.append(0) # 删除顶点,根据顶点的索引删除 def remove_vert(self, i): if self.size() == 0: raise IndexError(\"矩阵为空\") # 顶点列表移除指定索引顶点 self.verts.pop(i) # 边列表移除指定索引顶点行 self.mats.pop(i) # 按行遍历边列表，逐行删除指定索引所在的列 for row in self.mats: row.pop(i) # c:行索引，r：列索引 def add_edge(self, r, c): if r = self.size() or c >= self.size() or r == c: raise IndexError('越界') self.mats[r][c] = 1 self.mats[c][r] = 1 def remove_edge(self, r, c): if r = self.size() or c >= self.size() or r == c: raise IndexError('越界') self.mats[r][c] = 0 self.mats[c][r] = 0 def show(self): tb = PrettyTable(self.verts) for c in self.mats: tb.add_row(c) print(tb) if __name__ == \"__main__\": verts = ['a', 'b', 'c', 'd', 'e'] edges = [[0, 1], [0, 3], [1, 2], [2, 3], [2, 4], [3, 4]] matrix = GraphMatrix(verts, edges) matrix.show() matrix.add_vert('f') matrix.add_edge(1, 5) matrix.show() matrix.remove_vert(4) matrix.show() matrix.remove_edge(0, 3) matrix.show() 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-16 23:40:28 "},"python/python_graph_list.html":{"url":"python/python_graph_list.html","title":"Python无向图邻接表实现","keywords":"","body":"Python无向图邻接表实现 一、无向图邻接表表示 Python使用邻接表实现无向图，使用Python的字典dict来实现，字典的健存储顶点，字典的值存储图的边。 使用字典的过程中，需要注意字典的几个基本操作，如：字典长度，添加健以及值。 构造函数 基于Python的字典实现无向图，仅需一个成员变量：self.graph_list = dict[str, list[str]]() 字典的健key:顶点(str类型) 字典的值value:是一个列表，存储顶点所链接的边（list[str]类型） 为列便于理解，建议为变量添加注解，如：dict[str, list[str]]() def __init__(self, verts: str, edges: list[list[str]]): # 初始化一个字典，健为顶点，值为边（list） self.graph_list = dict[str, list[str]]() # 添加顶点，向字典中添加健 for v in verts: self.add_vert(v) # 添加边，向字典中添加健的值 for e in edges: self.add_edge(e[0], e[1]) 二、无向图增加顶点 为无向图增加一个顶点，即在字典中新增一个键值对，由于只增加列顶点，因此健的值为空[] 注意字典的操作方法：self.graph_list[v] = []，在字典新增一个健为v，但是值为[] # 添加顶点：向字典添加健 def add_vert(self, v): if v in self.graph_list: return # 仅添加顶点的健，暂无键值 self.graph_list[v] = [] 三、无向图删除顶点 无向图删除一个顶点，需要进行两步操作方可完成： 在字典中删除顶点对应的键值对； 处理其他顶点有链接的边，因此需要对其他顶点进行遍历，通过while循环获取每一个顶点的键值，然后在键值中删除对应的顶点。 # 删除顶点，删除顶点的键值对，同时删除其他顶点内包含该顶点值中包含的顶点 def remove_vert(self, v): if v not in self.graph_list: raise ValueError(\"查无此顶点\") # 首先删除字典中v健的键值对 self.graph_list.pop(v) # 遍历顶点和链表字典，逐个从字典中顶点对应的键值中，删除v顶点的边 for vert in self.graph_list: if v in vert: self.graph_list[vert].remove(v) 四、无向图边操作 无向图邻接表的边操作，与邻接矩阵类似，也是需要进行两次操作。对边的两个顶点都进行操作。 同样也要注意，不可为同一个顶点增加边，需要做一个前置的if判断。 # 增加边：同时修改两个顶点对应的键值 def add_edge(self, vert1, vert2): if vert1 not in self.graph_list or vert2 not in self.graph_list or vert1 == vert2: raise ValueError('顶点不存在') self.graph_list[vert1].append(vert2) # 对键值做个排序，看起来舒服些 self.graph_list[vert1].sort() self.graph_list[vert2].append(vert1) self.graph_list[vert2].sort() # 删除边：同时删除两个顶点对应的键值 def remove_edge(self, vert1, vert2): if vert1 not in self.graph_list or vert2 not in self.graph_list or vert1 == vert2: raise ValueError('顶点不存在') self.graph_list[vert1].remove(vert2) self.graph_list[vert2].remove(vert1) 五、全部代码 class GraphList: # 基于字典实现无向图的邻接链表 # 字典的健：顶点(str类型) # 字典的值：是一个列表，存储顶点所链接的边list[str]类型 # edges: list[list[str]]：edges是一个列表，包含多条边，每条边list[str]也是一个列表，包含两个顶点 def __init__(self, verts: str, edges: list[list[str]]): # 初始化一个字典，健为顶点，值为边（list） self.graph_list = dict[str, list[str]]() # 添加顶点，向字典中添加健 for v in verts: self.add_vert(v) # 添加边，向字典中添加健的值 for e in edges: self.add_edge(e[0], e[1]) # 图的大小，就是顶点个数，即字典的长度 def size(self): return len(self.graph_list) # 添加顶点：向字典添加健 def add_vert(self, v): if v in self.graph_list: return # 仅添加顶点的健，暂无键值 self.graph_list[v] = [] # 删除顶点，删除顶点的键值对，同时删除其他顶点内包含该顶点值中包含的顶点 def remove_vert(self, v): if v not in self.graph_list: raise ValueError(\"查无此顶点\") # 首先删除字典中v健的键值对 self.graph_list.pop(v) # 遍历顶点和链表字典，逐个从字典中顶点对应的键值中，删除v顶点的边 for vert in self.graph_list: if v in vert: self.graph_list[vert].remove(v) # 增加边：同时修改两个顶点对应的键值 def add_edge(self, vert1, vert2): if vert1 not in self.graph_list or vert2 not in self.graph_list or vert1 == vert2: raise ValueError('顶点不存在') self.graph_list[vert1].append(vert2) # 对键值做个排序，看起来舒服些 self.graph_list[vert1].sort() self.graph_list[vert2].append(vert1) self.graph_list[vert2].sort() # 删除边：同时删除两个顶点对应的键值 def remove_edge(self, vert1, vert2): if vert1 not in self.graph_list or vert2 not in self.graph_list or vert1 == vert2: raise ValueError('顶点不存在') self.graph_list[vert1].remove(vert2) self.graph_list[vert2].remove(vert1) if __name__ == \"__main__\": verts = ['a', 'b', 'c', 'd', 'e'] # edges = [ # [verts[0], verts[1]], # [verts[0], verts[3]], # [verts[1], verts[2]], # [verts[2], verts[3]], # [verts[2], verts[4]], # [verts[3], verts[4]], # ] edges = [['a', 'b'], ['a', 'd'], ['b', 'c'], ['c', 'd'], ['c', 'e'], ['d', 'e'], ] grap_list = GraphList(verts, edges) print(\"大小：\",grap_list.size()) print(grap_list.graph_list) grap_list.add_vert('f') grap_list.add_edge('b','f') print(\"大小：\", grap_list.size()) print(grap_list.graph_list) grap_list.remove_edge('d','e') print(\"大小：\", grap_list.size()) print(grap_list.graph_list) grap_list.remove_vert('c') print(\"大小：\", grap_list.size()) print(grap_list.graph_list) 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-16 23:42:59 "},"python/python_graph_travel.html":{"url":"python/python_graph_travel.html","title":"Python无向图遍历","keywords":"","body":"Python无向图遍历 无向图的遍历同二叉树类似，也分为广度优先和深度优先两种方式，其逻辑和原理也是一样的。 本次以无向图邻接表为基础，实现无向图的两种遍历方式。 关于无向图的邻接表实现，请看上一节：Python无向图邻接表实现 一、广度优先遍历 广度优先遍历以队列为基础进行实现，在实现的过程中，同二叉树类似，按层进行遍历。 实现步骤为： 从输入的顶点（起始顶点）开始，从根据顶点的健获取键值，即获取顶点的邻接的全部顶点（按层访问），然后加入队列（append），同时记录已经放问过visited 从队列中弹出一个顶点，重复以上步骤，将邻接的顶点加入队列。注意，这里就需要加入队列前进行一个判断，此顶点是否已经访问过，已经访问的顶点不再加入队列： if sub_vert in visited: continue 直到字典的全部顶点已经访问，即队列长度为0:while len(que) > 0: 广度优先遍历的核心：一是用队列来按层添加后续访问的顶点；二是要记录已经访问的顶点，不再加入队列。 同时要理解set的特性以及用法 # 广度优先遍历，通过队列方式实现 def bfs(graph: GraphList, start_vert: str): res = [] # 集合和队列存储顶点，均为str类型，做个注解 visited = set[str]([start_vert]) que = deque[str]([start_vert]) # 获取顶点的邻接顶点，如果没有被访问，就添加至队列中，直到队列元素全部被访问完毕 # 前提条件是所有节点之间有相连的边，如果有未连接的节点，则无法遍历。 while len(que) > 0: vert = que.popleft() res.append(vert) # graph_list就是存储图的字典，根据健获取键值，键值是一个列表 for sub_vert in graph.graph_list[vert]: # 如果该顶点已经放问过，则继续循环不甜加至队列 if sub_vert in visited: continue que.append(sub_vert) visited.add(sub_vert) return res 二、深度优先遍历 深度优先队列在前面二叉树中已经做个简单介绍：Python二叉树的遍历，同样使用递归的方式实现。 递归的使用，也在前面小节：Python递归算法及其简单应用，其应用的核心是要找到边界条件（终止条件），在无向图的森度优先遍历中，字典的键值链表循环遍历结束，即表示达到来终止条件 实现步骤为： 从输入顶点获取邻接第一个顶点（根据字典的键值，获取列表的第一个）； 判断邻接的顶点是否已经访问visited，如果未访问，则重复以上步骤，即使用递归，此时逻辑是一样的，只是输入的顶点变成来另一个（邻接的顶点） 当遍历至最后一个无邻接顶点时，则返回（归)，返回上一步，或者继续向上返回。 这里需要注意的是，递归的终止条件是隐性的，for循环执行完毕，即返回。 # 深度优先遍历，使用递归方式实现 # 为列便于理解，为变量加上注解 # graph：邻接表实现的无向图 # visited：访问过顶点的集合 # res：访问的节点，这里要与visited区分，他们顺序不同的。这里注意set的属性，有兴趣可以观察set的内容和顺序 def dfs(graph: GraphList, visited: set[str], res: list[str], start_v): visited.add(start_v) # 经过节点即记录，前序方式 res.append(start_v) # 递归边界条件（终止条件），这里是一种隐性的写法，for循环终止列，即退回到上一步 for v in graph.graph_list[start_v]: if v in visited: continue # 对连接的新顶点继续遍历 dfs(graph, visited, res, v) 三、全部代码 # 无向图遍历 from collections import deque from graph_list import GraphList # 广度优先遍历，通过队列方式实现 def bfs(graph: GraphList, start_vert: str): res = [] # 集合和队列存储顶点，均为str类型，做个注解 visited = set[str]([start_vert]) que = deque[str]([start_vert]) # 获取顶点的邻接顶点，如果没有被访问，就添加至队列中，直到队列元素全部被访问完毕 # 前提条件是所有节点之间有相连的边，如果有未连接的节点，则无法遍历。 while len(que) > 0: vert = que.popleft() res.append(vert) # graph_list就是存储图的字典，根据健获取键值，键值是一个列表 for sub_vert in graph.graph_list[vert]: # 如果该顶点已经放问过，则继续循环不甜加至队列 if sub_vert in visited: continue que.append(sub_vert) visited.add(sub_vert) return res # 深度优先遍历，使用递归方式实现 # 为列便于理解，为变量加上注解 # graph：邻接表实现的无向图 # visited：访问过顶点的集合 # res：访问的节点，这里要与visited区分，他们顺序不同的。这里注意set的属性，有兴趣可以观察set的内容和顺序 def dfs(graph: GraphList, visited: set[str], res: list[str], start_v): visited.add(start_v) # 经过节点即记录，前序方式 res.append(start_v) # 递归边界条件（终止条件），这里是一种隐性的写法，for循环终止列，即退回到上一步 for v in graph.graph_list[start_v]: if v in visited: continue # 对连接的新顶点继续遍历 dfs(graph, visited, res, v) if __name__ == \"__main__\": verts = ['a', 'b', 'c', 'd', 'e'] edges = [['a', 'b'], ['a', 'd'], ['b', 'c'], ['c', 'd'], ['c', 'e'], ['d', 'e'], ] graph = GraphList(verts, edges) print(graph.graph_list) print(bfs(graph, 'a')) dfs_res = [] visited = set[str]() dfs(graph, visited, dfs_res, 'a') print(dfs_res,visited) 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-17 21:12:52 "},"python/python_binary_search_close.html":{"url":"python/python_binary_search_close.html","title":"Python二分查找算法","keywords":"","body":"Python二分查找算法 二分查找算法的前提条件是列表是有序的。 本次实现以双闭区间表示的方式，这种方式更容易理解，而且在写代码时，不容易因为下标计算转换以及while循环跳出时出错。 双闭区间表示方法： 最左侧下标为：left_index，起始从0开始 最右侧下标为：right_index，起始从len(list)-1，即要包含最右侧的元素 中值下标为：m=(left_index+right_index)//2，向下取整 实现方式 通过在循环中不断移动左右侧下标的值，缩小查找的范围，直到右侧下标小于左侧下标，终止循环，退出查找，或者找到对应的元素，退出查找。 如果目标值小于中间值：nums[m] > num，调整最右侧的下标为：right_index = m - 1，进入列表左侧继续查找，此时区间为[left_index,m-1] 如果目标值大于中间值：nums[m] ，调整最左侧下标为：left_index = m + 1，进入列表右侧继续查找，此时区间为[m+1,right_index] 如果目标值等于中间值，则返回列表的下标 如果继续循环遍历，列表中没有找到对应的目标值，最左右侧的效标通过不断的变化，先会出现left_index=right_index，然后下一次循环就会left_index > right_index，最后跳出while循环。 这里需要注意几点： 每次进入循环后，是已经调整左右侧下标值，然后计算中间下标； 调整左或右侧下标时，是不包含原中间侧下标的值，因此是m+1，或者m-1 while循环经过不断调整左右侧下标，没有找到元素时，右侧下标会小于左侧下标 重点注意：while循环比较的是while left_index ，这里用的是，因为未找到元素时，会出现left_index ，如果用符号，则无法比较到最右侧下标的值。这就是双闭区间与左闭右开方式的区别。 # 二分查找，左右双闭方式 def binary_search(nums: list[int], num: int): left_index, right_index = 0, len(nums) - 1 # 必须是 num: right_index = m - 1 else: return m return -1 左闭右开区间表示法 通常左右均为闭区间，较为方便，但是左闭右开也是一种表示方式。由于右侧是开区间（即不包含最右侧下标的这个元素），因此最右侧下标的移动方式略有不同。 左右侧的起始为：left_index,right_index=0,len(list)，即比较的时候，不能包含最右侧的下标元素（越界） 如果目标值小于中间值：nums[m] > num，调整最右侧的下标为：right_index = m，进入列表左侧继续查找，此时区间为[left_index,m) 如果目标值大于中间值：nums[m] ，调整最左侧下标为：left_index = m + 1，进入列表右侧继续查找，此时区间为[m+1,right_index) while循环中，由于不包含最右侧下标的元素，因此应该为：left_index。 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-18 12:18:51 "},"python/python_selection_sort.html":{"url":"python/python_selection_sort.html","title":"Python排序算法-选择排序","keywords":"","body":"Python排序算法-选择排序 选择排序，顾名思义，就是选出一个元素，通过与剩余元素进行比较，找出最大（最小）的元素，然后进行互相交换。 算法实现 通过两层循环遍历实现： 列表的长度为n，即列表所有元素的表示范围为：[0,n-1] 外层循环i从0开始，到列表倒数第二个，即[0,n-1-1]，因为是从这里取出一个元素，与后面的元素相比较（即无须取最后一个元素，最后一个元素与谁比呢^_^），且前面的元素都排序了，最后一个必然是最大或最小的元素；所以for循环的表示方法为range(n-1) 内层循环j从i+1开始，到列表最后一个元素，即[i+1,n-1]，即i与i+1相比，直到最后一个元素[n-1]。所以for循环的表示方法为range(i + 1, n) # 选择排序算法 # 重点是注意列表下标的取值范围，两轮循环的取值最末端是不同的。 def selection_sort(nums: list[int]): n = len(nums) # n-1实际取值是n-2位置 for i in range(n - 1): # k记录列表i+1至n-1之间最小数的效标 k = i for j in range(i + 1, n): # 在i+1至n-1中发现比num[i]小的数，k记录此下标 if nums[j] 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-19 23:13:50 "},"python/python_bubble_sort.html":{"url":"python/python_bubble_sort.html","title":"Python排序算法-冒泡排序","keywords":"","body":"Python排序算法-冒泡排序 上一节：选择排序，是选出一个元素与后面的全部元素逐个比较，选出一个最大或最小的元素。 而冒泡排序，则略有不同，他是将相邻的两个元素两两相互比较，其中较大（较小）的元素以互换的形式向后移动。 实现方式 两两相互比较，即将j与j+1相互比较，也是通过两层循环遍历的方式实现： 列表的长度为n，即列表所有元素的表示范围为：[0,n-1] 外层循环从列表尾部[n-1]先开始，最大的元素位置在最后一个；到第2个结束，即列表的表示范围[n-1,1]，这是因为前面元素全部比较完毕，最后一个元素[0]自然是最小的，无须再比较。因此循环的写法为：for i in range(n-1,0,-1) 内层循环从0开始，到倒数第2个结束，即内层循环的表示范围[0,n-1-1]，因为后面比较的方式是nums[j+1]，这样就可以比较到最后一个元素。因此循环的写法为for j in range(i) 同时，可以在外层循环内部定义一个标志变量flag，如果列表是有序的，即在内层循环遍历是没有出现两两互换，说明已经是有序列表，可以跳出循环，终止排序。 # 冒泡排序 # def bubble_sort(nums:list[int]): n=len(nums) # 外层循环从列表尾部先开始，目的：为内层循环设置最大的范围； # 注意外层循环范围为：[n-1,1]，前面元素全部比较完毕，最后一个元素[0]自然是最小的，无须再比较 for i in range(n-1,0,-1): # 定义一个标志变量，如果后面元素是有序的（没有元素交换操作），无须排序，直接终止 flag = True # 内层循环范围：[0,n-1-1]，因为后面比较的方式是nums[j+1]，这样就可以比较到最后一个元素 for j in range(i): if nums[j]>nums[j+1]: nums[j],nums[j+1]=nums[j+1],nums[j] flag=False if flag: break if __name__==\"__main__\": nums = [62, 65, 51, 15, 30, 63, 37, 8, 55, 70, 13, 84, 46, 44, 86, 11, 91, 10, 47, 3, 96, 9, 36, 54, 24, 55, 72, 29, 45] bubble_sort(nums) print(nums) 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-19 23:15:05 "},"python/python_insertion_sort.html":{"url":"python/python_insertion_sort.html","title":"Python排序算法-插入排序","keywords":"","body":"Python排序算法-插入排序 插入排序算，和选择排序算法类似，也是选取一个元素，向前插入到合适的位置，前面的元素逐个向后移动。 实现方式 通过两层循环的方式，遍历整个列表： 列表的长度为n，即列表所有元素的表示范围为：[0,n-1] 外层循环：i从1开始至尾部[n-1]结束，从 1开始（即nums[1]）取出元素base，作为与前面进行比较的基数，与前面已排序列表元素进行比较。因此外层列表的范围为nums[1,n-1]，循环for的写法为：for i in range(n) 内层循环：j从[i-1]开始至0结束，倒序方式先从[i-1]位置取出元素与base(nums[i])比较，如果nums[j]>base，将nums[j]向后移动一位，直到找到base大于nums[j]的位置，或者已经到列表最左侧（即0位置），循环结束。 需要注意的一点是，在while循环结束后，此时j已经到了合适位置的前一个位置，因此插入base时，j的下标需要j+1才能插入到正确位置。 # 插入排序 # 取出排序后的一个元素，与前面元素相比，插入对应的位置。 def insertion_sort(nums:list[int]): n=len(nums) for i in range(n): # 取出排序后的第一个元素base base=nums[i] j=i-1 # 将比自己大的元素向后移动 while j>=0 and nums[j]>base: nums[j+1]=nums[j] j-=1 # 注意下标j+1的含义，在while循环中j已经跑到前一个位置了，因此需要j+1 nums[j+1]=base if __name__==\"__main__\": nums = [62, 65, 51, 15, 30, 63, 37, 8, 55, 70, 13, 84, 46, 44, 86, 11, 91, 10, 47, 3, 96, 9, 36, 54, 24, 55, 72, 29, 45] insertion_sort(nums) print(nums) 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-20 10:29:28 "},"python/python_quick_sort.html":{"url":"python/python_quick_sort.html","title":"Python排序算法-快速排序","keywords":"","body":"Python排序算法-快速排序 快排是一种不断划分左右子列表，通过递归方式实现的排序算法。 实现方式 划分左右子列表，可以理解为学生排队，在队伍中选择一个标杆（基数)，比基数的站到左边，比基数高的站到右边，然后通过向下递归的方式，对左、右子列表重复上述步骤，直到列表（队伍）中只有一个人时，列表向上返回，整个队伍全部排序完毕。 列表的长度为n，即列表所有元素的表示范围为：[0,n-1] 选取最左侧（nums[left]）的元素作为基数（标杆），先从最右侧j查找比基数小的元素，再从左侧i起查找比基数大的元素，然后交换这两个元素 重复以上步骤，直到i==j，此时两边均查找完毕，然后将基数（nums[left]）与i所处（nums[i]）互换，即实现了：左子列表 然后使用递归的方式处理左右子列表，当子列表中只有一个元素是返回，即if left >= right: 需要注意的两点 选择最左侧元素为列表的基数时，必须先从右侧查找比基数小的元素，不能先从左侧查找比基数大的元素。如： [0, 0, 0, 0, 1] ，如果先“从左向右查找”，标杆划分后数组为 [1, 0, 0, 0, 0] ，这个结果是不正确的。 因为从左侧先查找时，最终i == j==4是，会出现nums[j] == nums[i] > nums[left]，而在while结束后，需要条换nums[left]与nums[i]，此时将列表中的1调换至最左侧。 在排序算法quick_sort中，递归处理左右子列表，输入的参数，不包含i位置，因此左子列表的最右侧下标为base_index - 1，右子列表的最左侧下标为base_index + 1 # 快速排序算法 # partition将列表划分为两个部分：左子列表 int: i, j = left, right # 选定最列表最左侧元素为基数 base = nums[left] while i = base: j -= 1 while i = right: return base_index = partition(nums, left, right) quick_sort(nums, left, base_index - 1) quick_sort(nums, base_index + 1, right) if __name__ == \"__main__\": nums = [62, 65, 51, 15, 30, 63, 37, 8, 55, 70, 13, 84, 46, 44, 86, 11, 91, 10, 47, 3, 96, 9, 36, 54, 24, 55, 72, 29, 45] # nums=[2, 4, 1, 0, 3, 5] quick_sort(nums, 0, len(nums) - 1) print(nums) 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-20 16:34:37 "},"python/python_merge_sort.html":{"url":"python/python_merge_sort.html","title":"Python排序算法-归并排序","keywords":"","body":"Python排序算法-归并排序 归并排序，类似于快排，也是通过递归实现的一种排序算法。 实现思路： 归并排序算法思路上分为两个步骤：划分列表和排序合并列表。 划分列表：通过递归的方式，将列表从中间位置，划分为左、右子列表，直到子列表的长度为1，然后向上返回。 排序合并列表：在左、右子列表划分长度为1时，在向上递归返回时，对左右子列表进行合并排序，并填入原列表中。 实现步骤： 列表的长度为n，即列表所有元素的表示范围为：[0,n-1],对最左、右侧元素下标分别命名为left,right 划分阶段，通过左右下标，计算列表中间位置，下标命名为mid，即此时有列表的3个下标lefe,mid,right，分别代表列表的左，中间，右元素的下标，通过不断递归调用自身，直到列表的长度为1，达到递归函数的边界（终止）条件返回。 排序合并阶段：对左右子列表进行排序，先定义一个临时列表tmp，比较左右子列表，从小到大填入tmp列表: while i 如果左右子列表有部分元素较大，然后通过while循环，将子列表元素全部填入tmp临时列表: while i 将临时列表tmp元素填入原列表nums 注意要点 划分左右子列表是，注意左列表最右侧元素（mid）和右子列表最左侧元素（mid+1）的下标。必须要包含mid元素。 划分左右子列表的递归边界条件是子列表长度为1，即无法划分系列表。 if left >= right: return 合并排序列表时，临时列表tmp填入原列表nums，注意起始下标从left开始，子列表长度从小到大，从从左子列表起点left开始，保证左右子列表均能填入nums 代码： # 归并排序 # 合并函数，对分解的列表，合并排序存储在tmp列表中，然后将列表中元素复制到nums中 def merge(nums: list[int], left, mid, right): tmp = [0] * (right - left + 1) i, j, k = left, mid + 1, 0 # 合并左右子列表，从左端逐个比较左右列表，然后按序存入tmp列表 while i = right: return mid = (left + right) // 2 # 分别处理左右子列表 merge_sort(nums, left, mid) merge_sort(nums, mid + 1, right) # 子列表排序合并 merge(nums, left, mid, right) if __name__ == \"__main__\": nums = [62, 65, 51, 15, 30, 63, 37, 8, 55, 70, 13, 84, 46, 44, 86, 11, 91, 10, 47, 3, 96, 9, 36, 54, 24, 72, 29, 45] merge_sort(nums, 0, len(nums) - 1) print(nums) ` 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-22 22:30:55 "},"python/python_heap_sort.html":{"url":"python/python_heap_sort.html","title":"Python排序算法-堆排序","keywords":"","body":"Python排序算法-堆排序 堆排序就是一个不断弹出堆顶元素（堆中的最大值），堆同时在缩小，然后不断堆化和弹出堆顶元素进行排序。 堆化的理解，请看前面小节：Python堆操作 一、实现思路 首先对列表元素进行建堆，此时堆顶元素就是列表最大的元素； 弹出堆顶元素（堆中最大值）：弹出堆顶元素时，是将堆顶元素（nums[0]）与列表最后的元素互换（nums[len-1]）。nums[i], nums[0] = nums[0], nums[i] 然后循环执行以上两个步骤，堆缩小的堆不断弹出堆顶元素。 二、注意要点 注意堆化（shift_down）过程中while循环的终止条件：互换后堆顶仍为最大值或者i无左右子顶点； 注意列表长度的变化，在堆排序函数中，列表长度在缩小，取得堆顶元素后，列表下标i变为缩小后堆的长度。 for i in range(len(nums) - 1, 0, -1): nums[i], nums[0] = nums[0], nums[i] shift_down(nums, i, 0) 注意for i in range(len(nums) - 1, 0, -1)堆缩小后，列表下标的最小值为1，这是因为n-1个元素排序完毕后，堆中的最后一个元素必然是最小的。 注意建堆的过程，此处建堆与之前的从上到下的建堆略有不同，此处为从下到上的建堆。 # 建堆操作 for i in range(len(nums) // 2 - 1, -1, -1): shift_down(nums, len(nums), i) # 堆排序 # l:堆的长度（列表长度） # i：堆的顶点（也可以是左右子堆的顶点，随着向下移动，顶点在向下移动） def shift_down(nums: list[int], l: int, i: int): while True: left = i * 2 + 1 right = i * 2 + 2 # 最大值先指向堆顶，然后与左右子堆比较，进行堆化 mx = i if left 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-23 10:23:30 "},"python/python_build_tree.html":{"url":"python/python_build_tree.html","title":"Python分治算法应用-构建二叉树","keywords":"","body":"Python分治算法应用-构建二叉树 问题 根据二叉树的深度遍历前序列表(pre_list)和中序列表(mid_list)，构建对应的二叉树。如： 前序列表：pre_list = [5, 9, 15, 2, 55, 18, 11, 90, 243] 中序列表：mid_list = [2, 15, 55, 9, 18, 5, 90, 11, 243] 生成二叉树的广度优先遍历结果应为：bfs_list = [5, 9, 11, 15, 18, 90, 243, 2, 55]，可以作为验证。 一、分治算法基本思路 在学习二叉树的深度遍历以及归并排序、快速排序等小节时，使用的就是分而治之的思路。通常分治法通过递归实现，整体上包含两个部分：划分问题和合并问题 划分问题：将题目问题划分为规模较小的问题；按照递归的基本原理，小问题与原问题结构是一致的；直到小的问题无法再划分（达到边界条件）时，停止划分 合并问题：当达到边界条件时，从下到上返回，开始合并小问题。 一个问题是否适合使用分治解决，通常可以参考以下几个判断依据。 问题可以分解：原问题可以分解成规模更小、类似的子问题，以及能够以相同方式递归地进行划分。 子问题是独立的：子问题之间没有重叠，互不依赖，可以独立解决。 子问题的解可以合并：原问题的解通过合并子问题的解得来。 二、解题步骤 根据分治算法的基本思路，下面解决构建二叉树： 在前序列表中，我们知道根节点在列表的最左侧，可以用下标i表示； 同理，在前序列表中，左子树的根节点紧跟着根节点，可以用下标i+1表示； 下面就要推算右子树的根节点，这里要稍微复杂，直接给出结果，如下表 树 根节点索引pre_list 子树的列表区间mid_list 当前树 i [left,right] 左子树 i+1 [left,m-1] 右子树 i+1+(t-left) [t+1,right] t为当前树根节点在中序列表mid_list的索引（下标） t-left即为左子树元素的节点的个数。因为m在中序列表mid_list中的的位置，代表中t左侧全部为左子树节点，t的右侧全部为右子树的节点，因此t-left表示左子树节点的数量。 实现步骤 先通过i在前序列表pre_list，初始化根节点root； 通过i+1在前序列表pre_list，可以构建左子树根节点，然后连接在根节点的left指针上； 通过根节点元素值，获取在中序列表mid_list的索引t， 通过i+1+(t-left)在前序列表pre_list，可以构建右子树根节点，然后连接在根节点的right指针上； 让后通过递归的方式，继续探索左右子树，不断的向下构建子树和节点。 递归的边界条件：节点为叶子节点，无左右子树，即此时子树的列表区间中，left和right指向同一个节点（叶子节点），right-left==0 # 使用递归的分治策略，根据前序列表和中序字典，逐层向下递归，向上返回的方式构建二叉树，可以通过return上部的print查看构建过程 # 参数说明： # pre_list:深度优先前序遍历列表 # mid_dict:深度优先中序遍历列表生成的列表 # root_index:前序列表中根节点下标 # left:中序列表左侧元素下标 # right:中序列表右侧元素下标 def dfs(pre_list:list[int],mid_dict:dict[int,int],root_index,left,right): # 当前节点为叶子节点，right和left指向同一个节点 if right-left三、注意要点 要理解t-left的含义； 递归的边界条件是当前节点为叶子节点，此时无法构建左右次数，因此if right-left 在中序列表中获取根节点的索引，先将中序列表转换为字典dict，将元素值作为健，元素的索引作为值，这样可以通过元素值获取到中学列表的索引t，t=mid_dict[pre_list[root_index]] 列表转换为字典的用法如下：mid_dict = {val: index for index, val in enumerate(mid_list)} 四、全部代码 from collections import deque # 分治算法应用： # 构建二叉树 # 根据深度优先前序遍历列表和中序遍历列表，还原二叉树 # 树节点类 class TreeNode: def __init__(self, val: int): self.val = val self.left: TreeNode = None self.right: TreeNode = None # 以深度优先的方式构建二叉树 # 使用递归的分治策略，根据前序列表和中序字典，逐层向下递归，向上返回的方式构建二叉树，可以通过return上部的print查看构建过程 # 参数说明： # pre_list:深度优先前序遍历列表 # mid_dict:深度优先中序遍历列表生成的列表 # root_index:前序列表中根节点下标 # left:中序列表左侧元素下标 # right:中序列表右侧元素下标 def dfs(pre_list:list[int],mid_dict:dict[int,int],root_index,left,right): # 当前节点为叶子节点，right和left指向同一个节点 if right-left鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-25 15:56:36 "},"python/numpy_basic.html":{"url":"python/numpy_basic.html","title":"Numpy基础用法","keywords":"","body":"Numpy基础用法 一、创建数组 1. 从列表创建数组 创建一维数组 输入一个一维列表即可 arr_list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] x1 = np.array(arr_list1) 创建二维数组 输入一个二维列表 注意二维列表的输入方式，使用[arr_list1, arr_list2]，参数为一个二维列表，不是2个参数 dtype：指定元素数据类型 arr_list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] arr_list2 = [21, 22, 23, 24, 25, 26, 27, 28, 29, 30] x1 = np.array([arr_list1, arr_list2], dtype=int) 2. 从头创建数组 np.zeros：生成一个填充0的数组，生成一个3×4，填充0的二维数组 np.ones:生成一个填充1的数组，生成一个2×4，填充1的二维数组 np.full:生成一个指定内容的数组，生成一个3×5，填充9.9的二维数组 x2 = np.zeros((3, 4), dtype=float) x2 = np.ones((2, 4), dtype=int) x2 = np.full((3, 5), 9.9, dtype=float) 3. 创建序列数组 np.arange:简单序列数组,默认的step为1,从1开始,小于10(不包含10),步长为2 np.linspace:等差数组, np.logspace:等比数组 np.random.randint:随机数组，在1-10之间随机生成一个3×4的数组 x3 = np.arange(1, 10, 2, dtype=int) # 等差数列 x3 = np.linspace(1, 100, 100, dtype=int) # 等比数列 x3 = np.logspace(1, 100, 50) # 随机 x3 = np.random.random((3, 3)) x3 = np.random.randint(1, 10, (3, 4)) 二、数组的性质 shape:数组的形状，即含有几行×几列 ndim:数组的维度，如：二维，一维 dtype:数组的元素数据类型 x4 = np.random.randint(1, 50, (5, 8)) print('x4数组的形状', x4.shape) print('x4数组的维度', x4.ndim) print('x4数组的类型', x4.dtype) 三、数组的索引 x5[1]:获取一行 x5[:, 1]:获取一列 x5[1][2]:获取第1行第2列元素 x5[1, 2]:同上，两种写法都可以 x5 = np.random.randint(1, 40, (6, 7)) print('x5二维数组获取一行', x5[1]) print('x5二维数组获取一列', x5[:, 1]) print('x5指定位置：', x5[1][2]) print('x5指定位置：', x5[1, 2]) 四、数组的切片 1. 一维数组切片 x6[5:12]:选取5~11元素，不包含尾部（12），同列表的使用相同； x6[::-1]:反向输出（逆序输出），同列表使用相同； x6[:-2]:输出0至第三个元素 x6 = np.random.randint(1, 30, 15) # 包含起点，不包含终点 print('截取一段', x6[5:12]) print('截取至倒数第三个元素', x6[:-2]) # 注意是2个: print('反向输出', x6[::-1]) 2. 二维数组切片 x6[:2, :3]:0-1行×0-2列 x6[::-1,::-1]:反向输出（先按行反向，然后再按列反向），与矩阵的转置不同 x6[:1,0:5:3]:第一个参数是行，第二个参数是列（3表示步长）。即第 x6[1,:]:获取第一行，与x6[1]相同 x6[:,2]:获取第二列，注意观察与获取行的区别。 print('截取一段', x6[:2, :3]) # 可以理解为先按行反向，然后再按列反向（与转置是不同的) print('反向输出',x6[::-1,::-1]) # 3为步长 print(x6[:1,0:5:3]) # 也可以写为：x6[1] print(\"获取一行：\",x6[1,:]) print('获取一列：',x6[:,2]) 3. 视图与拷贝区别 视图获取的仍然是原数组的内容，修改的仍然是原数组 拷贝则另外生成一个新的数组，与原数组不同 x7[0,0]=35:修改原数组，属于视图模式 x7=x6[:2,:3].copy():生成一个新的数组，对元素的改变不影响原数组 x7=x6[:2,:2] x7[0,0]=35 # 使用copy方法，返回副本，不影响原数组 x7=x6[:2,:3].copy() x7[0,0]=38 五、数组的变形 1. 一维数组变二维数组 reshape:将一维数组重构为二维数组：x8=x7.reshape(3,4)，np.random.randint(1,20,(12,))，生成一维数组 x8[1,1]=100*:修改数组内容，reshape，获得的是视图，不是副本，因此修改的是原数组。 # 注意写法：(12,)表明是一个一维数组；(12,1)是一个2维数组，12×1 x7=np.random.randint(1,20,(12,)) print(x7.shape) # 维度转换，必须元素的长度是一致的。1×23=3×4 x8=x7.reshape(3,4) # reshap生成的是视图，修改数组内容，影响原数组 x8[1,1]=100 2. 二维数组变一维数组 flatten():二维数组变一维数组，返回的是拷贝（副本）； ravel():二维数组变一维数组，返回的是视图； reshape(-1):二维数组变一维数组，返回的是视图； x7=np.random.randint(1,30,(3,4)) # flatten：返回副本 x8=x7.flatten() # ravel：返回视图 x9=x7.ravel() # reshape：返回视图 x10=x7.reshape(-1) 六、数组拼接 hstack和vstack两种拼接方法，均返回的是副本，即生成一个新的数组。 1. 水平拼接 注意参数的写法，传入的是一个数组（包含2个数组），且两种写法功能相同 np.hstack([x8,x9]): np.c_[x8,x9]: x8=np.random.randint(1,20,(2,3)) x9=np.random.randint(30,50,(2,3)) # 水平拼接，np.hstack # 注意参数写法[arr1,arr2] x10=np.hstack([x8,x9]) print(x10) # 水平拼接,np.c_ # 注意参数写法 x11=np.c_[x8,x9] print(x11) 2. 垂直拼接 使用方式与水平拼接相同 np.vstack([x8,x9]): np.r_[x8,x9]: x8=np.random.randint(1,20,(2,3)) x9=np.random.randint(30,50,(2,3)) x12=np.vstack([x8,x9]) print(x12) x13=np.r_[x8,x9] print(x13) 七、数组分裂 1. 一维数组分裂 np.split(x9,[5,12]): 第一个参数：被分裂的数组； 第二个参数：分裂的位置（传入的是一个数组），出入数组参数为下一个数组的起点； [5,12]:分裂为3个数组，0～4，5～11，12～19 x9=np.random.randint(1,30,20) # 不包含终点，即可以理解为下一个的起点 # 注意索引参数的用法[] x10,x11,x12=np.split(x9,[5,12]) print(x10,x11,x12) 2. 二维数组分裂 按行分裂np.vsplit(x10,[2,3]):垂直（纵向）方向分裂，[2,3]表示：按第0～1行，第2行，第3行共三个数组 按列分裂np.hsplit(x10,[2,3]):水平（横向）方向分裂，[2,3]表示，按第0～1行，第2行，第3～4行共三个数组 x10=x9.reshape(4,5) # 按行分裂 # 注split和vsplit相同 x11,x12,x13=np.vsplit(x10,[2,3]) print(x11,'\\n',x12,'\\n',x13) # 按列分裂 x11,x12,x13=np.hsplit(x10,[2,3]) print(x11, '\\n', x12, '\\n', x13) 八、数组运算 1. 向量化运算 数组内部元素逐个参与运算，如+，-，×，/，以及各类内部函数的计算，返回仍然是一个大小（shape）相同的数组 x10=np.arange(1,10) x11=np.arange(11,20) # 内部元素对应位置的+，-，×，/ print(x10+5) print(x10+x11) print(x10*x11) # numpy内部函数：sin,cos,tan,log,log2,log10等，返回一个数组。 print(np.sin(x10)) print(np.log(x11)) 2. 矩阵运算 主要包含两种运算： 转置:根据对角线互相交换位置，如索引[0,1]换到[1,0]，这里与二维数组的行和列均反向输出是不同的。 乘法:矩阵的乘法，注意区分向量的乘法，且x10.dot(x11)和np.dot(x10,x11)功能相同 x10=np.arange(1,10).reshape(3,3) x11=np.arange(11,20).reshape(3,3) # 矩阵转置 print(x10.T) # 矩阵乘法 print(x10.dot(x11)) print(np.dot(x10,x11)) 3. 比较运算 x10>50:判断数组大于50的元素，大于50返回True，否则返回False，返回的是一个大小（shape）相同的数组，内部根据元素填充True和False np.sum(x10>50):统计大于50元素的个数 np.sum((x10 > 50) & (x10 ：多个条件统计，统计大于50，且小于80元素的个数 np.all(x10>0)：判断数组元素是否均大于0 np.all(x10>50,axis=1):按行判断元素是否大于50，根据行数返回一个填充True和False的数组。axis=1轴向，1表示按行，0表示按列 x10=np.random.randint(1,100,(10,10)) # 返回一个10×10数组，填充false、ture，大于50为true，其他填充为false print(x10>50) # 统计大于50的个数 print(np.sum(x10>50)) # 多条件判断50 50) & (x10 0)) # 判断按行是否全部大于50；axis为轴，1行，0列 print(np.all(x10>50,axis=1)) 4. 掩码运算 结合比较运算，根据比较运算生成的True和False数组，获取原数组为True的元素。 x10=np.random.randint(1,100,(10,10)) # 掩码运算：获取大于50的元素 # x10>50返回false，true数组 # x10[]从数组中获取为True的元素 print(x10[x10>50]) 九、加强版索引 通过数组形式的索引，获取原数组的元素 1. 一维数组 索引是一个数组，如：ind=[1,5,9]，然后通过索引数组获取原数组的元素，x11[ind] 同样可以构建一个二维索引数组，如：ind=[[2,4],[3,1]]，然后通过索引数组获取数组的元素构建一个二维数组，x11[ind] x11=np.random.randint(1,100,10) # 定义一个索引数组 ind=[1,5,9] # 根据索引数组，返回数组内容 print(x11[ind]) # 根据索引，生成二维数组 ind=[[2,4],[3,1]] print(x11[ind]) 2. 二维数组 构建2个数组索引，分别对应行和列； 然后通过数组索引获取原二维数组的元素 x11 = np.random.randint(1, 100, (5, 5)) print(x11) # 定义行、列索引 row=np.array([0,2,4]) col=np.array([1,3,0]) x12=x11[row,col] 十、其他函数 Numpy的功能更加强大，已经内置很多函数，如极值、求和、求积、均值等。 1. 一维数组 np.sort:数组排序，原数组不变，生成一个新数组； x12.sort():数组排序，对原数组进行操作 np.max：求数组最大值 np.min：求数组最小值 np.argmax：获取数组最大值的索引 np.argmin：获取数组最小值的索引 np.sum：数组求和 x12.sum：数组求和，功能同上 np.prod：数组求积 x12.prod：数组求积 x12=np.random.randint(1,100,15) # np.sort排序，原数组不变，生成一个新数组 print(np.sort(x12)) print(x12) # 替换原数组，为生成排序变化后的数组 x12.sort() print(x12) # 最大、小值元素 print(np.max(x12),np.min(x12)) # 最大、小值元素的索引 print(np.argmax(x12),np.argmin(x12)) print(np.sum(x12)) 2. 二维数组 np.sum(x12,axis=1)：axis按行或列求和 x12=np.random.randint(1,100,(4,4)) print(x12) print(np.sum(x12)) # 按行求和，轴=1 print(np.sum(x12,axis=1)) ~ 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-03-10 14:59:05 "},"tips/tips.html":{"url":"tips/tips.html","title":"Tips","keywords":"","body":"记录工具使用中的小技巧 点滴积累 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-10-15 09:14:14 "},"tips/kms_act.html":{"url":"tips/kms_act.html","title":"KMS激活服务器vlmcsd搭建","keywords":"","body":"KMS激活服务器vlmcsd搭建 [TOC] KMS 方式激活，有效期是 180 天，到期之后系统会自动再次激活 一、服务器安装 1、服务器安装 根据服务器CPU不同型号，选择进入不同的目录。 普通Linux服务器，进入Linux/intel/stati目录，执行vlmcsd-x64-musl-static N1盒子是arm芯片，进入Linux/arm/little-endian/static目录，执行vlmcsd-armv4el-musl-static wget https://github.com/Wind4/vlmcsd/releases/download/svn1111/binaries.tar.gz #进入路径 cd binaries/Linux/intel/static #创建KMS服务-64位Linux服务器 ./vlmcsd-x64-musl-static #创建KMS服务-N1盒子，armbian系统 #cd binaries/Linux/arm/little-endian/static #./vlmcsd-armv4el-musl-static 2、测试服务器是否成功启动 查看服务端口即可，mlvcsd监听端口为1688 $netstat -ant Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:445 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:139 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:6800 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:1688 0.0.0.0:* LISTEN tcp 0 0 10.201.0.24:6800 10.201.8.89:64962 ESTABLISHED tcp 0 0 10.201.0.24:6800 10.201.8.89:64963 ESTABLISHED tcp 0 216 10.201.0.24:22 10.201.8.89:64819 ESTABLISHED tcp6 0 0 :::445 :::* LISTEN tcp6 0 0 :::1024 :::* LISTEN tcp6 0 0 :::139 :::* LISTEN tcp6 0 0 :::80 :::* LISTEN tcp6 0 0 :::53 :::* LISTEN tcp6 0 0 :::22 :::* LISTEN tcp6 0 0 :::1688 :::* LISTEN tcp6 0 0 :::3000 :::* LISTEN tcp6 0 0 10.201.0.24:1024 10.201.8.89:64976 ESTABLISHED tcp6 0 0 10.201.0.24:80 10.201.8.89:64958 SYN_RECV tcp6 0 0 10.201.0.24:1024 10.201.8.89:64975 ESTABLISHED tcp6 0 0 10.201.0.24:1024 10.201.8.89:64974 ESTABLISHED tcp6 0 0 10.201.0.24:80 10.201.8.89:64959 SYN_RECV tcp6 0 0 10.201.0.24:1024 10.201.8.89:64964 ESTABLISHED tcp6 0 0 10.201.0.24:1024 10.201.8.89:64970 ESTABLISHED tcp6 0 0 10.201.0.24:80 10.201.8.89:64960 SYN_RECV tcp6 0 0 10.201.0.24:1024 10.201.8.89:64973 ESTABLISHED 3、测试客户端是否连接成功 Windows也下载vlcmsc压缩包，解压后进入binaries\\Windows\\intel目录,在Powershell中运行vlmcs-Windows-x64.exe，连接N1盒子IP地址。 这里注意一点vlmcs是客户端，vlmcsd是服务端 mlvcsd> .\\vlmcs-Windows-x64.exe -v -l 3 10.201.0.24 Request Parameters ================== Protocol version : 6.0 Client is a virtual machine : No Licensing status : 2 (OOB grace) Remaining time (0 = forever) : 43200 minutes Application ID : 55c92734-d682-4d71-983e-d6ec3f16059f (Windows) SKU ID (aka Activation ID) : 34e1ae55-27f8-4950-8877-7a03be5fb181 (Windows Server 2019 Datacenter) KMS ID (aka KMS counted ID) : 8449b1fb-f0ea-497a-99ab-66ca96e9a0f5 (Windows Server 2019) Client machine ID : 3bd63bfb-a462-43c5-9fde-0de5ff022424 Previous client machine ID : 00000000-0000-0000-0000-000000000000 Client request timestamp (UTC) : 2023-10-09 00:35:26 Workstation name : hack-me.adobe.ua N count policy (minimum clients): 5 Connecting to 10.201.0.24:1688 ... successful Performing RPC bind ... ... NDR64 ... BTFN ... NDR32 ... successful Sending activation request (KMS V6) 1 of 1 Response from KMS server ======================== Size of KMS Response : 260 (0x104) Protocol version : 6.0 KMS host extended PID : 06401-00206-558-827852-03-8201-9600.0000-1612023 KMS host Hardware ID : 3A1C049600B60076 Client machine ID : 3bd63bfb-a462-43c5-9fde-0de5ff022424 Client request timestamp (UTC) : 2023-10-09 00:35:26 KMS host current active clients : 10 Renewal interval policy : 10080 Activation interval policy : 120 二、激活系统 1、Windows激活 Windows 必须是 VL 版本才可以使用 kms 激活，如果不是 VL 版本，则需要更换密钥 查看系统版本号 wmic os get caption Caption Microsoft Windows 11 Home China 在终端或者Powershell中运行以下命令进行激活 slmgr /upk 卸载WINDOWS自带密钥 slmgr.vbs /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX #10.201.0.24 为N1盒子IP地址。 slmgr.vbs /skms 10.201.0.24 slmgr.vbs /ato 查看到期时间 Windows 就激活完毕了，期限是180天，到期后自动续订，不需要人工干预。 在终端执行以下命令，会弹出对话框显示到期时间 slmgr.vbs /xpr 2、Office激活 查看版本号 Windows的激活一样，要求安装的 Office 为批量版本 在Office的产品信息页面 (就是显示是否激活的页面)，查看是否有 更改产品密钥 选项，有则为批量，没有则为零售 文件-->更多-->账户 打开后在产品信息下可以看到切换许可证 激活 进入Office目录，注意区分64位和32位版本 Office2016是office16目录，Office2013是office15目录，Office2010是office14目录。 #进入office 安装目录 #cd C:\\Program Files (x86)\\Microsoft Office\\Office16 cd C:\\Program Files\\Microsoft Office\\Office16 cscript ospp.vbs /inpkey:XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99 cscript ospp.vbs /sethst:10.201.0.24 cscript ospp.vbs /act 查看激活 cscript ospp.vbs /dstatus 三、密钥 1、Windows 10密钥 Operating system edition KMS Client Setup Key Windows 10 Professional W269N-WFGWX-YVC9B-4J6C9-T83GX Windows 10 Professional N MH37W-N47XK-V7XM9-C7227-GCQG9 Windows 10 Enterprise NPPR9-FWDCX-D2C8J-H872K-2YT43 Windows 10 Enterprise N DPH2V-TTNVB-4X9Q3-TJR4H-KHJW4 Windows 10 Education NW6C2-QMPVW-D7KKK-3GKT6-VCFB2 Windows 10 Education N 2WH4N-8QGBV-H22JP-CT43Q-MDWWJ Windows 10 Enterprise 2015 LTSB WNMTR-4C88C-JK8YV-HQ7T2-76DF9 Windows 10 Enterprise 2015 LTSB N 2F77B-TNFGY-69QQF-B8YKP-D69TJ Windows 10 Enterprise 2016 LTSB DCPHK-NFMTC-H88MJ-PFHPY-QJ4BJ Windows 10 Enterprise 2016 LTSB N QFFDN-GRT3P-VKWWX-X7T3R-8B639 Windows Server Datacenter 6NMRW-2C8FM-D24W7-TQWMY-CWH2D Windows Server Standard N2KJX-J94YW-TQVFB-DG9YT-724CC 2、Office 2016密钥 Product GVLK Office Professional Plus 2016 XQNVK-8JYDB-WJ9W3-YJ8YR-WFG99 Office Standard 2016 JNRGM-WHDWX-FJJG3-K47QV-DRTFM Project Professional 2016 YG9NW-3K39V-2T3HJ-93F3Q-G83KT Project Standard 2016 GNFHQ-F6YQM-KQDGJ-327XX-KQBVC Visio Professional 2016 PD3PC-RHNGV-FXJ29-8JK7D-RJRJK Visio Standard 2016 7WHWN-4T7MP-G96JF-G33KR-W8GF4 Access 2016 GNH9Y-D2J4T-FJHGG-QRVH7-QPFDW Excel 2016 9C2PK-NWTVB-JMPW8-BFT28-7FTBF OneNote 2016 DR92N-9HTF2-97XKM-XW2WJ-XW3J6 Outlook 2016 R69KK-NTPKF-7M3Q4-QYBHW-6MT9B PowerPoint 2016 J7MQP-HNJ4Y-WJ7YM-PFYGF-BY6C6 Publisher 2016 F47MM-N3XJP-TQXJ9-BP99D-8K837 Skype for Business 2016 869NQ-FJ69K-466HW-QYCP2-DDBV6 Word 2016 WXY84-JN2Q9-RBCCQ-3Q3J3-3PFJ6 3、Office 2013密钥 Product GVLK Office 2013 Professional Plus YC7DK-G2NP3-2QQC3-J6H88-GVGXT Office 2013 Standard KBKQT-2NMXY-JJWGP-M62JB-92CD4 Project 2013 Professional FN8TT-7WMH6-2D4X9-M337T-2342K Project 2013 Standard 6NTH3-CW976-3G3Y2-JK3TX-8QHTT Visio 2013 Professional C2FG9-N6J68-H8BTJ-BW3QX-RM3B3 Visio 2013 Standard J484Y-4NKBF-W2HMG-DBMJC-PGWR7 Access 2013 NG2JY-H4JBT-HQXYP-78QH9-4JM2D Excel 2013 VGPNG-Y7HQW-9RHP7-TKPV3-BG7GB InfoPath 2013 DKT8B-N7VXH-D963P-Q4PHY-F8894 Lync 2013 2MG3G-3BNTT-3MFW9-KDQW3-TCK7R OneNote 2013 TGN6P-8MMBC-37P2F-XHXXK-P34VW Outlook 2013 QPN8Q-BJBTJ-334K3-93TGY-2PMBT PowerPoint 2013 4NT99-8RJFH-Q2VDH-KYG2C-4RD4F Publisher 2013 PN2WF-29XG2-T9HJ7-JQPJR-FCXK4 Word 2013 6Q7VD-NX8JD-WJ2VH-88V73-4GBJ7 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-10-15 09:19:49 "},"tips/rime.html":{"url":"tips/rime.html","title":"rime输入法安装配置","keywords":"","body":"rime輸入法安裝&配置 一、安裝 下载小狼毫后，直接默认安装即可 安装完毕后，启动的配置中，选择中文简体，然后在输入法中，选择明月拼音，初步安装完毕。 二、配置 1. windows语言配置 点击工具栏小狼毫图标（黑色）-->语言首选项-->中文简体-->选项-->添加键盘，将小狼毫添加进来 在键盘中删除windows自带的bing输入法 建议安装一个英文输入法，同时将英文输入法调到中文输入法前面 以后按win+空格，切换中英文输入法 2. 安装其他拼音方案 默认情况下推荐使用明月拼音（简体），但是这里推荐另一个方案：clover四叶草拼音 下载clover- schema压缩包 将压缩包解压至小狼毫用户文件夹C:\\Users\\bytetoy\\AppData\\Roaming\\Rime 3. 项目微调 打开小狼毫程序文件夹C:\\Program Files (x86)\\Rime\\weasel-0.15.0 进入data文件夹，按照以下步骤进行调整，然后重新部署即可 weasel.yaml:是常规设置，主要控制托盘图标、候选词横竖排列、界面配色等等功能。那么，我们需要定制界面配色，只需在weasel.custom.yaml中修改，重新部署后就可实现。 default.yaml是默认设置，主要控制快捷键、按键上屏等等。同样，作修改就编辑default.custom.yaml文件即可。 1) 修改候选词数量 打开default.yaml，找到page_size，将默认的5改为8 2) 候选词横屏显示 打开weasel.yaml，找到horizontal，将false改为true 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-10-27 09:17:44 "},"tips/apt_fail.html":{"url":"tips/apt_fail.html","title":"Armbian apt update失败处理方法","keywords":"","body":"Armbian apt update失败处理方法 N1盒子上装的Armbian，之前一直用的好好的，这段时间无法apt安装软件了，update也是一直失败，一直在报错。 尝试更换不同的源，什么清华、阿里云等都试了个边，包括修改armbian.list都没有用。 原来是安装的debian的版本是9，23年4月已经停止维护了，需要更换专用的源。 一、Armbian版本 bytetoy@aml:/etc/apt$ lsb_release -a No LSB modules are available. Distributor ID: Debian Description: Debian GNU/Linux 9.13 (stretch) Release: 9.13 Codename: stretch 二、报错类型 bytetoy@aml:~$ sudo aptitude update Ign http://mirrors.aliyun.com/debian stretch InRelease Ign http://mirrors.aliyun.com/debian-security stretch/updates InRelease Ign http://mirrors.aliyun.com/debian stretch-updates InRelease Ign http://mirrors.aliyun.com/debian stretch-backports InRelease Err http://mirrors.aliyun.com/debian stretch Release 404 Not Found [IP: 111.32.209.191 80] Err http://mirrors.aliyun.com/debian-security stretch/updates Release 404 Not Found [IP: 111.32.209.191 80] Err http://mirrors.aliyun.com/debian stretch-updates Release 404 Not Found [IP: 111.32.209.191 80] Err http://mirrors.aliyun.com/debian stretch-backports Release 404 Not Found [IP: 111.32.209.191 80] Err http://mirrors.nju.edu.cn/armbian stretch InRelease Cannot initiate the connection to mirrors.nju.edu.cn:80 (2001:da8:1007:4011::3). - connect (101: Network is unreachable) [IP: 2001:da8:1007:4011::3 80] E: The repository 'http://mirrors.aliyun.com/debian stretch Release' does not have a Release file. E: The repository 'http://mirrors.aliyun.com/debian-security stretch/updates Release' does not have a Release file. E: The repository 'http://mirrors.aliyun.com/debian stretch-updates Release' does not have a Release file. E: The repository 'http://mirrors.aliyun.com/debian stretch-backports Release' does not have a Release file. E: Failed to download some files W: Failed to fetch http://apt.armbian.com/dists/stretch/InRelease: Cannot initiate the connection to mirrors.nju.edu.cn:80 (2001:da8:1007:4011::3). - connect (101: Network is unreachable) [IP: 2001:da8:1007:4011::3 80] W: Failed to fetch http://mirrors.aliyun.com/debian/dists/stretch/Release: 404 Not Found [IP: 111.32.209.191 80] W: Failed to fetch http://mirrors.aliyun.com/debian-security/dists/stretch/updates/Release: 404 Not Found [IP: 111.32.209.191 80] W: Failed to fetch http://mirrors.aliyun.com/debian/dists/stretch-updates/Release: 404 Not Found [IP: 111.32.209.191 80] W: Failed to fetch http://mirrors.aliyun.com/debian/dists/stretch-backports/Release: 404 Not Found [IP: 111.32.209.191 80] W: Some index files failed to download. They have been ignored, or old ones used instead. 三、更换新的官方地址源 debian9停止维护，需要更换新的软件源地址 同时armbian.list保持原官方配置 deb http://apt.armbian.com stretch main stretch-utils stretch-desktop deb http://archive.debian.org/debian/ stretch main contrib non-free #deb-src http://archive.debian.org/debian/ stretch main contrib non-free deb http://archive.debian.org/debian-security/ stretch/updates main contrib non-free #deb-src http://archive.debian.org/debian-security/ stretch/updates main contrib non-free deb http://archive.debian.org/debian/ stretch-backports main contrib non-free 四、更新 更换新的软件源后，可以愉快的系统更新和安装工具了 bytetoy@aml:~$ sudo aptitude update Ign http://archive.debian.org/debian stretch InRelease Get: 1 http://archive.debian.org/debian-security stretch/updates InRelease [59.1 kB] Get: 2 http://archive.debian.org/debian stretch-backports InRelease [78.5 kB] Hit http://mirrors.ustc.edu.cn/armbian stretch InRelease Get: 3 http://archive.debian.org/debian stretch Release [118 kB] Get: 4 http://archive.debian.org/debian-security stretch/updates/main arm64 Packages [762 kB] Get: 5 http://archive.debian.org/debian-security stretch/updates/main armhf Packages [758 kB] Get: 6 http://archive.debian.org/debian-security stretch/updates/main Translation-en [368 kB] Get: 7 http://archive.debian.org/debian-security stretch/updates/contrib armhf Packages [1,764 B] Get: 8 http://archive.debian.org/debian-security stretch/updates/contrib arm64 Packages [1,760 B] Get: 9 http://archive.debian.org/debian-security stretch/updates/contrib Translation-en [1,759 B] Get: 10 http://archive.debian.org/debian-security stretch/updates/non-free armhf Packages [5,320 B] Get: 11 http://archive.debian.org/debian-security stretch/updates/non-free arm64 Packages [5,320 B] Get: 12 http://archive.debian.org/debian-security stretch/updates/non-free Translation-en [21.3 kB] Get: 13 http://archive.debian.org/debian stretch Release.gpg [3,177 B] Get: 14 http://archive.debian.org/debian stretch-backports/main armhf Packages [600 kB] Get: 15 http://archive.debian.org/debian stretch-backports/main arm64 Packages [598 kB] Get: 16 http://archive.debian.org/debian stretch-backports/main Translation-en [467 kB] Get: 17 http://archive.debian.org/debian stretch-backports/main arm64 Contents (deb) [5,354 kB] Get: 18 http://archive.debian.org/debian stretch-backports/main armhf Contents (deb) [5,434 kB] Get: 19 http://archive.debian.org/debian stretch-backports/contrib armhf Packages [8,964 B] Get: 20 http://archive.debian.org/debian stretch-backports/contrib arm64 Packages [7,828 B] Get: 21 http://archive.debian.org/debian stretch-backports/contrib Translation-en [7,237 B] Get: 22 http://archive.debian.org/debian stretch-backports/contrib arm64 Contents (deb) [142 kB] Get: 23 http://archive.debian.org/debian stretch-backports/contrib armhf Contents (deb) [143 kB] Get: 24 http://archive.debian.org/debian stretch-backports/non-free arm64 Packages [6,588 B] Get: 25 http://archive.debian.org/debian stretch-backports/non-free armhf Packages [14.2 kB] Get: 26 http://archive.debian.org/debian stretch-backports/non-free Translation-en [38.5 kB] Get: 27 http://archive.debian.org/debian stretch-backports/non-free armhf Contents (deb) [62.5 kB] Get: 28 http://archive.debian.org/debian stretch-backports/non-free arm64 Contents (deb) [56.7 kB] Get: 29 http://archive.debian.org/debian stretch/main arm64 Packages [6,921 kB] Get: 30 http://archive.debian.org/debian stretch/main armhf Packages [6,908 kB] Get: 31 http://archive.debian.org/debian stretch/main Translation-en [5,377 kB] Get: 32 http://archive.debian.org/debian stretch/main arm64 Contents (deb) [31.4 MB] Get: 33 http://archive.debian.org/debian stretch/main armhf Contents (deb) [31.4 MB] Get: 34 http://archive.debian.org/debian stretch/contrib armhf Packages [41.8 kB] Get: 35 http://archive.debian.org/debian stretch/contrib arm64 Packages [39.6 kB] Get: 36 http://archive.debian.org/debian stretch/contrib Translation-en [45.8 kB] Get: 37 http://archive.debian.org/debian stretch/contrib armhf Contents (deb) [80.3 kB] Get: 38 http://archive.debian.org/debian stretch/contrib arm64 Contents (deb) [79.6 kB] Get: 39 http://archive.debian.org/debian stretch/non-free armhf Packages [59.8 kB] Get: 40 http://archive.debian.org/debian stretch/non-free arm64 Packages [50.9 kB] Get: 41 http://archive.debian.org/debian stretch/non-free Translation-en [80.2 kB] Get: 42 http://archive.debian.org/debian stretch/non-free armhf Contents (deb) [757 kB] Get: 43 http://archive.debian.org/debian stretch/non-free arm64 Contents (deb) [754 kB] Fetched 99.1 MB in 55s (1,774 kB/s) Current status: 78194 (+77134) new. 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-11-19 22:01:57 "},"tips/mariadb_conf.html":{"url":"tips/mariadb_conf.html","title":"Armbian安装Mysql(MariaDB)数据库","keywords":"","body":"Armbian安装Mysql(MariaDB)数据库 debian9默认情况下，Mysql数据库已经替换为MariaDB数据库，配置方式已经同原Mysql不同。 通过apt安装mysql-server后，需要进行一些列的配置，才能成功登录 一、安全配置 运行脚本mysql_secure_installation，无需密码，进行部分按权设置 配置root密码 删除匿名帐号 启用root的远程登录 删除test数据库 立即刷新数据库权限 bytetoy@aml:~$ sudo mysql_secure_installation NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY! In order to log into MariaDB to secure it, we'll need the current password for the root user. If you've just installed MariaDB, and you haven't set the root password yet, the password will be blank, so you should just press enter here. Enter current password for root (enter for none): OK, successfully used password, moving on... Setting the root password ensures that nobody can log into the MariaDB root user without the proper authorisation. Set root password? [Y/n] y New password: Re-enter new password: Password updated successfully! Reloading privilege tables.. ... Success! By default, a MariaDB installation has an anonymous user, allowing anyone to log into MariaDB without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? [Y/n] y ... Success! Normally, root should only be allowed to connect from 'localhost'. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? [Y/n] n ... skipping. By default, MariaDB comes with a database named 'test' that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? [Y/n] y - Dropping test database... ... Success! - Removing privileges on test database... ... Success! Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? [Y/n] y ... Success! Cleaning up... All done! If you've completed all of the above steps, your MariaDB installation should now be secure. Thanks for using MariaDB! 二、权限配置 按权配置后，可以使用mysql直接登录，然后可以新建帐号和配置权限 新建帐号:GRANT ALL PRIVILEGES on *.* TO 'admin'@'%' IDENTIFIED BY '9527' WITH GRANT OPTION; 设置帐号密码：SET PASSWORD FOR admin=PASSWORD('9527'); 刷新权限：FLUSH PRIVILEGES; bytetoy@aml:~$ sudo mysql Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 5 Server version: 10.1.48-MariaDB-0+deb9u2 Debian 9.13 Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. MariaDB [(none)]> MariaDB [(none)]> GRANT ALL PRIVILEGES on *.* TO 'admin'@'%' IDENTIFIED BY '9527' WITH GRANT OPTION; Query OK, 0 rows affected (0.00 sec) MariaDB [(none)]> SET PASSWORD FOR admin=PASSWORD('9527'); Query OK, 0 rows affected (0.01 sec) MariaDB [(none)]> FLUSH PRIVILEGES; Query OK, 0 rows affected (0.00 sec) 三、测试新帐号 查看数据库版本sudo mysqladmin -u admin -p version bytetoy@aml:~$ sudo mysqladmin -u admin -p version Enter password: mysqladmin Ver 9.1 Distrib 10.1.48-MariaDB, for debian-linux-gnu on aarch64 Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Server version 10.1.48-MariaDB-0+deb9u2 Protocol version 10 Connection Localhost via UNIX socket UNIX socket /var/run/mysqld/mysqld.sock Uptime: 10 min 21 sec Threads: 2 Questions: 13 Slow queries: 0 Opens: 17 Flush tables: 1 Open tables: 11 Queries per second avg: 0.020 使用新帐号登录，测试是否设置成功 bytetoy@aml:~$ mysql -h localhost -u admin -p Enter password: Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 7 Server version: 10.1.48-MariaDB-0+deb9u2 Debian 9.13 Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. MariaDB [(none)]> 四、配置帐号远程登录 修改配置文件：sudo vim /etc/mysql/mariadb.conf.d/50-server.cnf 修改绑定的IP地址，然后重启mysql服务bind-address=0.0.0.0 #原为127.0.0.1 systemctl restart mysqld 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-11-19 22:02:46 "},"tips/linux_server_safe_config.html":{"url":"tips/linux_server_safe_config.html","title":"云服务器初始安全配置","keywords":"","body":"云服务器初始安全配置 一、添加新用户 root用户登录后，新增一个用户，后续禁用root登录。 用户创建成功后，可以新用户和密码ssh进行登录。 root@aliyun:/home# adduser hotpod Adding user `hotpod' ... Adding new group `hotpod' (1000) ... Adding new user `hotpod' (1000) with group `hotpod (1000)' ... Creating home directory `/home/hotpod' ... Copying files from `/etc/skel' ... New password: Retype new password: passwd: password updated successfully Changing the user information for hotpod Enter the new value, or press ENTER for the default Full Name []: hotpod Room Number []: Work Phone []: Home Phone []: Other []: Is the information correct? [Y/n] y Adding new user `hotpod' to supplemental / extra groups `users' ... Adding user `hotpod' to group `users' ... root@aliyun:/home# ls hotpod tips 二、为新用户添加sudo权限 将新用户添加至sudo用户组，添加权限：root@aliyun:/home# 测试新用户是否添加成功：sudo -l -U hotpod，出现(ALL : ALL) ALL表示成功 root@aliyun:/home# usermod -aG sudo hotpod root@aliyun:/home# sudo -l -U hotpod Matching Defaults entries for hotpod on aliyun: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, use_pty User hotpod may run the following commands on aliyun: (ALL : ALL) ALL 三、配置SSH密钥登录 用帐号和密码登录始终不安全，改为密钥证书登录，同时禁用帐号密码登录，也将root的ssh登录权限去掉。 创建RSA密钥 创建的证书默认在当前用户的.ssh目录下 使用证书登录，无须再设置密码的，回车直接下一步创建，有安全强迫症的可以同步设置证书登录密码。 hotpod@aliyun:~$ ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/home/hotpod/.ssh/id_rsa): Created directory '/home/hotpod/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/hotpod/.ssh/id_rsa Your public key has been saved in /home/hotpod/.ssh/id_rsa.pub The key fingerprint is: SHA256:cCqF7FJW2/cqoba6uVGYP9HhVN18bFzgdkyTdD5S7Ag hotpod@aliyun The key's randomart image is: +---[RSA 3072]----+ | . .. o+B*| | . o o . E..+*B| | = + = . ..=++| | + + B o . o.o.| | . = + S . | | . + o . . | | . = . . | | + o . | | =+. | +----[SHA256]-----+ 修改证书权限 创建成功后，可以在.ssh目录下看到两个文件，id_rsa为私钥，下载至本地，id_rsa.pub为公钥放在服务器。 公钥证书设置权限为600，证书目录.ssh权限为700 cat id_rsa.pub >> authorized_keys为下一步配置证书登录使用。 hotpod@aliyun:~$ cd .ssh/ hotpod@aliyun:~/.ssh$ ls id_rsa id_rsa.pub hotpod@aliyun:~/.ssh$ touch authorized_keys hotpod@aliyun:~/.ssh$ cat id_rsa.pub >> authorized_keys hotpod@aliyun:~/.ssh$ chmod 600 authorized_keys hotpod@aliyun:~/.ssh$ cd .. hotpod@aliyun:~$ chmod 700 .ssh/ 配置证书登录 编辑/etc/ssh/sshd_config文件，进行登录配置 `* ``PubkeyAuthentication yes ```：启用证书登录 AuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2：指定证书文件 PermitRootLogin no：禁用root帐号ssh登录 PasswordAuthentication no：禁止用户使用帐号密码方式登录 sudo systemctl restart sshd：重启sshd服务 然后退出当前ssh链接，重新登录即需要使用证书登录 PubkeyAuthentication yes # Expect .ssh/authorized_keys2 to be disregarded by default in future. AuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2 PermitRootLogin no PasswordAuthentication no hotpod@aliyun:/etc/ssh$ sudo systemctl restart sshd 按照以上配置，如果再次用root帐号登录，即会出现Authentication failed,please connect again.报错，当前只能使用证书登录了。 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-11-26 16:57:14 "},"tips/mysql_add_0.html":{"url":"tips/mysql_add_0.html","title":"MySQL为字段前面加一位0","keywords":"","body":"MySQL为字段前面加一位0 Mysql中有个字段应该是2位字符串，从csv文件导入的时候，前面的0被自动去掉，需要手工加上去，否则在排序的时候，会出现一些问题。 一、未修改前 查询数据库内容如下，01-->1，不方便分组和排序 MariaDB [hbgk]> SELECT c_code,s_code,c_name,grade,class,sub_limit,score,year FROM score_1130 WHERE c_name =\"武汉科技大学\" ORDER BY c_code,s_code,year; +--------+--------+--------------------+--------+--------+-----------+-------+------+ | c_code | s_code | c_name | grade | class | sub_limit | score | year | +--------+--------+--------------------+--------+--------+-----------+-------+------+ | C102 | 01 | 武汉科技大学 | 本科 | 历史 | 不限 | 587 | 2021 | | C102 | 02 | 武汉科技大学 | 本科 | 物理 | 不限 | 587 | 2021 | | C102 | 03 | 武汉科技大学 | 本科 | 物理 | 不限 | 581 | 2021 | | C102 | 04 | 武汉科技大学 | 本科 | 物理 | 不限 | 574 | 2021 | | C102 | 05 | 武汉科技大学 | 本科 | 物理 | 不限 | 573 | 2021 | | C102 | 06 | 武汉科技大学 | 本科 | 物理 | 不限 | 554 | 2021 | | C102 | 07 | 武汉科技大学 | 本科 | 物理 | 不限 | 558 | 2021 | | C102 | 08 | 武汉科技大学 | 本科 | 物理 | 不限 | 572 | 2021 | | C102 | 09 | 武汉科技大学 | 本科 | 物理 | 化 | 567 | 2021 | | C102 | 1 | 武汉科技大学 | 本科 | 历史 | 不限 | 558 | 2022 | | C102 | 1 | 武汉科技大学 | 本科 | 历史 | 不限 | 564 | 2023 | | C102 | 10 | 武汉科技大学 | 本科 | 物理 | 化或生 | 572 | 2021 | | C102 | 10 | 武汉科技大学 | 本科 | 物理 | 化或生 | 550 | 2022 | | C102 | 10 | 武汉科技大学 | 本科 | 物理 | 化或生 | 578 | 2023 | | C102 | 11 | 武汉科技大学 | 本科 | 物理 | 化或地 | 568 | 2021 | | C102 | 11 | 武汉科技大学 | 本科 | 物理 | 化或地 | 544 | 2022 | | C102 | 11 | 武汉科技大学 | 本科 | 物理 | 化或地 | 569 | 2023 | | C102 | 2 | 武汉科技大学 | 本科 | 物理 | 不限 | 566 | 2022 | | C102 | 2 | 武汉科技大学 | 本科 | 物理 | 不限 | 596 | 2023 | | C102 | 3 | 武汉科技大学 | 本科 | 物理 | 不限 | 561 | 2022 | | C102 | 3 | 武汉科技大学 | 本科 | 物理 | 不限 | 589 | 2023 | | C102 | 4 | 武汉科技大学 | 本科 | 物理 | 不限 | 551 | 2022 | | C102 | 4 | 武汉科技大学 | 本科 | 物理 | 不限 | 580 | 2023 | | C102 | 5 | 武汉科技大学 | 本科 | 物理 | 不限 | 546 | 2022 | | C102 | 5 | 武汉科技大学 | 本科 | 物理 | 不限 | 563 | 2023 | | C102 | 6 | 武汉科技大学 | 本科 | 物理 | 不限 | 539 | 2022 | | C102 | 6 | 武汉科技大学 | 本科 | 物理 | 不限 | 566 | 2023 | | C102 | 7 | 武汉科技大学 | 本科 | 物理 | 不限 | 536 | 2022 | | C102 | 7 | 武汉科技大学 | 本科 | 物理 | 不限 | 564 | 2023 | | C102 | 8 | 武汉科技大学 | 本科 | 物理 | 不限 | 550 | 2022 | | C102 | 8 | 武汉科技大学 | 本科 | 物理 | 不限 | 577 | 2023 | | C102 | 9 | 武汉科技大学 | 本科 | 物理 | 化 | 545 | 2022 | | C102 | 9 | 武汉科技大学 | 本科 | 物理 | 化 | 573 | 2023 | +--------+--------+--------------------+--------+--------+-----------+-------+------+ 二、修改后 手工在只有一位字符的前面加一个0，再次查询内容如下： MariaDB [hbgk]> SELECT c_code,s_code,c_name,grade,class,sub_limit,score,year FROM score WHERE c_name=\"武汉科技大学\" ORDER BY c_code,s_code,year; +--------+--------+--------------------+--------+--------+-----------+-------+------+ | c_code | s_code | c_name | grade | class | sub_limit | score | year | +--------+--------+--------------------+--------+--------+-----------+-------+------+ | C102 | 01 | 武汉科技大学 | 本科 | 历史 | 不限 | 587 | 2021 | | C102 | 01 | 武汉科技大学 | 本科 | 历史 | 不限 | 558 | 2022 | | C102 | 01 | 武汉科技大学 | 本科 | 历史 | 不限 | 564 | 2023 | | C102 | 02 | 武汉科技大学 | 本科 | 物理 | 不限 | 587 | 2021 | | C102 | 02 | 武汉科技大学 | 本科 | 物理 | 不限 | 566 | 2022 | | C102 | 02 | 武汉科技大学 | 本科 | 物理 | 不限 | 596 | 2023 | | C102 | 03 | 武汉科技大学 | 本科 | 物理 | 不限 | 581 | 2021 | | C102 | 03 | 武汉科技大学 | 本科 | 物理 | 不限 | 561 | 2022 | | C102 | 03 | 武汉科技大学 | 本科 | 物理 | 不限 | 589 | 2023 | | C102 | 04 | 武汉科技大学 | 本科 | 物理 | 不限 | 574 | 2021 | | C102 | 04 | 武汉科技大学 | 本科 | 物理 | 不限 | 551 | 2022 | | C102 | 04 | 武汉科技大学 | 本科 | 物理 | 不限 | 580 | 2023 | | C102 | 05 | 武汉科技大学 | 本科 | 物理 | 不限 | 573 | 2021 | | C102 | 05 | 武汉科技大学 | 本科 | 物理 | 不限 | 546 | 2022 | | C102 | 05 | 武汉科技大学 | 本科 | 物理 | 不限 | 563 | 2023 | | C102 | 06 | 武汉科技大学 | 本科 | 物理 | 不限 | 554 | 2021 | | C102 | 06 | 武汉科技大学 | 本科 | 物理 | 不限 | 539 | 2022 | | C102 | 06 | 武汉科技大学 | 本科 | 物理 | 不限 | 566 | 2023 | | C102 | 07 | 武汉科技大学 | 本科 | 物理 | 不限 | 558 | 2021 | | C102 | 07 | 武汉科技大学 | 本科 | 物理 | 不限 | 536 | 2022 | | C102 | 07 | 武汉科技大学 | 本科 | 物理 | 不限 | 564 | 2023 | | C102 | 08 | 武汉科技大学 | 本科 | 物理 | 不限 | 572 | 2021 | | C102 | 08 | 武汉科技大学 | 本科 | 物理 | 不限 | 550 | 2022 | | C102 | 08 | 武汉科技大学 | 本科 | 物理 | 不限 | 577 | 2023 | | C102 | 09 | 武汉科技大学 | 本科 | 物理 | 化 | 567 | 2021 | | C102 | 09 | 武汉科技大学 | 本科 | 物理 | 化 | 545 | 2022 | | C102 | 09 | 武汉科技大学 | 本科 | 物理 | 化 | 573 | 2023 | | C102 | 10 | 武汉科技大学 | 本科 | 物理 | 化或生 | 572 | 2021 | | C102 | 10 | 武汉科技大学 | 本科 | 物理 | 化或生 | 550 | 2022 | | C102 | 10 | 武汉科技大学 | 本科 | 物理 | 化或生 | 578 | 2023 | | C102 | 11 | 武汉科技大学 | 本科 | 物理 | 化或地 | 568 | 2021 | | C102 | 11 | 武汉科技大学 | 本科 | 物理 | 化或地 | 544 | 2022 | | C102 | 11 | 武汉科技大学 | 本科 | 物理 | 化或地 | 569 | 2023 | +--------+--------+--------------------+--------+--------+-----------+-------+------+ 三、操作记录 UPDATE score SET s_code=LPAD(s_code,2,'0') WHERE CHAR_LENGTH(s_code)=1 LPAD(str,len,padstr) 参数解释： str：要进行填充的字符串； len：填充后字符串的长度； padstr：用于填充的字符。 length()、char_length()的区别 length()： 单位是字节，utf8编码下,一个汉字三个字节，一个数字或字母一个字节。gbk编码下,一个汉字两个字节，一个数字或字母一个字节。 char_length()：单位为字符，不管汉字还是数字或者是字母都算是一个字符。 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-02 08:45:01 "},"tips/gitbook_install_error.html":{"url":"tips/gitbook_install_error.html","title":"gitbook运行错误解决cb.apply函数问题","keywords":"","body":"gitbook运行错误解决(cb.apply(this, arguments)) 新搞得的阿里云，转移了网站，安装nodejs和gitbook后，生成文件时报错。 一、报错内容 $ gitbook build Installing GitBook 3.2.3 /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (node:fs:208:5) 二、nvm重新安装nodejs nvm可以安装指定版本的nodejs，即可以用来安装低版本的nodejs，我这里用的v10.24.1版本。 这样gitbook使用3.2.3 卸载原gitbooknpm uninstall gitbook-cli -g 安装nvm$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash 查找低版本nodejs$ nvm ls-remote v10.23.1 (LTS: Dubnium) v10.23.2 (LTS: Dubnium) v10.23.3 (LTS: Dubnium) v10.24.0 (LTS: Dubnium) v10.24.1 (Latest LTS: Dubnium) v11.0.0 v11.1.0 v11.2.0 安装V10版本nodejsnvm install 10.24.1 Downloading and installing node v10.24.1... Downloading https://nodejs.org/dist/v10.24.1/node-v10.24.1-linux-x64.tar.xz... ################################################################################################## 100.0% Computing checksum with sha256sum Checksums matched! Now using node v10.24.1 (npm v6.14.12) Creating default alias: default -> 10.24.1 (-> v10.24.1) 重新安装gitbook ~~~ npm install gitbook-cli -g /home/hotpod/.nvm/versions/node/v10.24.1/bin/gitbook -> /home/hotpod/.nvm/versions/node/v10.24.1/lib/node_modules/gitbook-cli/bin/gitbook.js gitbook-cli@2.3.2 added 578 packages from 672 contributors in 13.633s ~~~ 查看gitbook版本gitbook -V CLI version: 2.3.2 GitBook version: 3.2.3 安装gitbook扩展 我的gitbook使用了search-pro, code, expandable-chapters, back-to-top-button, tbfed-pagefooter, toc, theme-comscore扩展，需要在生成前将扩展安装好。 gitbook install info: installing 7 plugins using npm@3.9.2 info: info: installing plugin \"search-pro\" info: install plugin \"search-pro\" (*) from NPM with version 2.0.2 /home/hotpod/web/bytetoy └── gitbook-plugin-search-pro@2.0.2 extraneous info: >> plugin \"search-pro\" installed with success info: info: installing plugin \"code\" runTopLevelLifecycles → 2 ▌ ╢███████████████████████████████████████████████████████████████████████░░░╟ /home/hotpod/web/bytetoy ├── gitbook-plugin-code@0.1.0 extraneous └── gitbook-plugin-search-pro@2.0.2 extraneous 三、重新生成 运行gitbook build重新生成静态文件即可。 gitbook build info: 14 plugins are installed info: 11 explicitly listed info: loading plugin \"search-pro\"... OK info: loading plugin \"code\"... OK info: loading plugin \"expandable-chapters\"... OK info: loading plugin \"back-to-top-button\"... OK info: loading plugin \"tbfed-pagefooter\"... OK info: loading plugin \"toc\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-comscore\"... OK info: loading plugin \"theme-default\"... OK info: found 27 pages info: found 8 asset files init! warn: \"options\" property is deprecated, use config.get(key) instead finish! info: >> generation finished with success in 2.5s ! 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-02 11:37:39 "},"tips/cos_static_config.html":{"url":"tips/cos_static_config.html","title":"腾讯COS托管静态网站","keywords":"","body":"腾讯COS托管静态网站 腾讯轻量云服务器到期了，续费价格离谱。而且原来放的几个网站都逐渐改为gitbook和hugo生成静态，改用COS来托管，10G空间存储一年只需要不到10元，流量几乎用不到几毛钱，总体下来更加划算，而且原来通过腾讯备案的域名也不会因为vps到期会被注销备案。 cos桶有上传工具，在本地生成后，可以通过工具批量上传文件，写一个bash脚本，将生成和上传合二为一，很是方便。 一、COS桶配置 配置权限：创建一个cos，权限为公有读私有写 配置静态网站：基础配置 > 静态网站，开启静态网站，同时设置索引文档指定首页html文件二、域名解析 cos配置：在域名与传输管理 > 自定义源站域名页面，添加将要解析的域名，如:bytetoy.cn，注意，添加域名时，在对话框中的源站类型选择静态网站源站 将以将www和@均做解析，否则设置了解析后www和裸域名不会自动跳转，如：www.bytetoy.cn 配置域名解析，cos的解析方式为cname，在域名服务商添加cname解析。注意添加www和@两种解析都设置，解析的cname的url，在cos添加域名后，会有一个url，如：bytetoy-12×××××54.cos-website.ap-shanghai.myqcloud.com 三、文件上传 cos本身可以上传文件，但是无法上传文件夹，手工逐个文件上传实在太慢了。 而且cos提供了多种上传工具，比如：coscli,coscmd，都是非常好用的，配置好了，上传非常方便。 创建cos桶密钥 在腾讯的访问密钥，生成SecretId和SecretKey，注意，ID和Key生成后要记好，生成后不支持查看，忘了只能再次生成一个，而且同时只能有两个密钥。 配置coscli配置文件 下载COSCLI工具，然后运行./coscli config init逐步配置密钥； 注意需要配置的几项为：Secret ID，Secret Key，Bucket Name，Bucket Endpoint，Bucket Alias，其他可以直接回车设置为空 将coscli工具添加到PATH中，后面可以在任何目录下使用此工具 生成的.cos.yaml文件，如下：建议生成一个后，再进行手工调整cos: base: secretid: iSUqIy××××××××××××××××××××××× secretkey: CpGQLdFPfJLZov××××××××××××××××××××××× sessiontoken: 3kNZR4××××××××××××××××××××××× protocol: https mode: \"\" cvmrolename: \"\" buckets: - name: bytet××××××××××××××××××××××× alias: bytetoy region: \"ap-shanghai\" endpoint: cos.ap-shanghai.myqcloud.com ofs: false - name: edu××××××××××××××××××××××× alias: eduez region: \"ap-shanghai\" endpoint: cos.ap-shanghai.myqcloud.com ofs: false - name: jzj××××××××××××××××××××××× alias: jzjyxy region: \"ap-shanghai\" endpoint: cos.ap-shanghai.myqcloud.com ofs: false 生成&批量上传 coscli有很多好用的命令，配置好后，可以使用coscli ls列出全部桶列表 coscli可以使用cp和sync进行上传和同步文件，写一个简单的shell脚本，生成和上传合二为一：#!/bin/bash echo \"1. build web html\" hugo echo \"2. sync files to cos\" #cp -R public/* /var/web/eduez coscli sync ~/web/eduez/public/ cos://eduez/ -r 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-02 15:13:20 "},"tips/mysql_import_datafile.html":{"url":"tips/mysql_import_datafile.html","title":"MySQL导入frm、MYD、MYI数据文件","keywords":"","body":"MySQL导入frm、MYD、MYI数据文件 frm、MYD、MYI是MySQL数据库的数据文件，无法像SQL文件通过命令直接导入，需要使用另一种方法导入。 一、安装MySQL 5.7 这里使用的是MySQL 5.7版本，安装的时候，除了安装server，建议一并安装shell，后面可以使用shell登录数据库。 二、创建数据库&复制文件 安装MySQL后，找到MySQL的安装目录。 查找数据库存放的目录 如下，本机的数据库存放目录为C:\\ProgramData\\MySQL\\MySQL Server 5.7\\Data\\ 进入data目录，会发现，MySQL的系统数据库以目录形式存在 mysql> show variables like 'datadir'; +---------------+---------------------------------------------+ | Variable_name | Value | +---------------+---------------------------------------------+ | datadir | C:\\ProgramData\\MySQL\\MySQL Server 5.7\\Data\\ | +---------------+---------------------------------------------+ 1 row in set, 1 warning (0.00 sec) 创建数据库 创建的数据库名字，要和frm、MYD、MYI的名字一致，如bytetoy_database。 只创建了数据库，当前目录下只有一个db.opt文件，因为没有表以及数据，就没有其他文件。 创建成功后，将bytetoy_database.frm、bytetoy_database.MYD、bytetoy_database.MYI的文件复制到Data下的bytetoy_database目录内，即对应的数据库内 重启MySQL服务 通过shell或者数据库管理工具，既可以导入的数据，如表以及表数据。 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-07 15:21:56 "},"tips/debian_install_docker.html":{"url":"tips/debian_install_docker.html","title":"Debian 12(bookworm)安装Docker","keywords":"","body":"Debian 12(bookworm)安装Docker 查看系统版本 hotpod@iZuf639kwmsyssxs0c0n9mZ:~$ (. /etc/os-release && echo \"$VERSION_CODENAME\") bookworm 安装必要软件包 hotpod@iZuf639kwmsyssxs0c0n9mZ:~$ api ca-certificates curl gnupg [sudo] password for hotpod: ca-certificates is already installed at the requested version (20230311) curl is already installed at the requested version (7.88.1-10+deb12u4) gnupg is already installed at the requested version (2.2.40-1.1) ca-certificates is already installed at the requested version (20230311) curl is already installed at the requested version (7.88.1-10+deb12u4) gnupg is already installed at the requested version (2.2.40-1.1) No packages will be installed, upgraded, or removed. 0 packages upgraded, 0 newly installed, 0 to remove and 0 not upgraded. Need to get 0 B of archives. After unpacking 0 B will be used. 配置Docker gpg证书 hotpod@iZuf639kwmsyssxs0c0n9mZ:~$ sudo install -m 0755 -d /etc/apt/keyrings hotpod@iZuf639kwmsyssxs0c0n9mZ:~$ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg hotpod@iZuf639kwmsyssxs0c0n9mZ:~$ sudo chmod a+r /etc/apt/keyrings/docker.gpg hotpod@iZuf639kwmsyssxs0c0n9mZ:~$ echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \\ $(. /etc/os-release && echo \"$VERSION_CODENAME\") stable\" | \\ sudo tee /etc/apt/sources.list.d/docker.list > /dev/null 更新软件源 hotpod@iZuf639kwmsyssxs0c0n9mZ:~$ sudo aptitude update Hit http://mirrors.cloud.aliyuncs.com/debian bookworm InRelease Get: 1 http://mirrors.cloud.aliyuncs.com/debian-security bookworm-security InRelease [48.0 kB] Get: 2 http://mirrors.cloud.aliyuncs.com/debian bookworm-updates InRelease [52.1 kB] Get: 3 http://mirrors.cloud.aliyuncs.com/debian bookworm-backports InRelease [56.5 kB] Get: 4 http://mirrors.cloud.aliyuncs.com/debian-security bookworm-security/main Sources [62.4 kB] Get: 5 http://mirrors.cloud.aliyuncs.com/debian-security bookworm-security/main amd64 Packages [106 kB] Get: 6 http://mirrors.cloud.aliyuncs.com/debian-security bookworm-security/main Translation-en [64.1 kB] Get: 7 http://mirrors.cloud.aliyuncs.com/debian bookworm-backports/main Sources.diff/Index [63.3 kB] Get: 8 http://mirrors.cloud.aliyuncs.com/debian bookworm-backports/main amd64 Packages.diff/Index [63.3 kB] Get: 9 http://mirrors.cloud.aliyuncs.com/debian bookworm-backports/main Translation-en.diff/Index [38.7 kB] Get: 10 http://mirrors.cloud.aliyuncs.com/debian bookworm-backports/main Sources T-2023-12-07-0205.52-F-2023-11-26-0203.42.pdiff [42.5 kB] Get: 11 https://download.docker.com/linux/debian bookworm InRelease [43.3 kB] Get: 12 http://mirrors.cloud.aliyuncs.com/debian bookworm-backports/main Sources T-2023-12-07-0205.52-F-2023-11-26-0203.42.pdiff [42.5 kB] Get: 13 http://mirrors.cloud.aliyuncs.com/debian bookworm-backports/main amd64 Packages T-2023-12-07-0205.52-F-2023-11-26-2009.18.pdiff [45.4 kB] Get: 14 http://mirrors.cloud.aliyuncs.com/debian bookworm-backports/main amd64 Packages T-2023-12-07-0205.52-F-2023-11-26-2009.18.pdiff [45.4 kB] Get: 15 http://mirrors.cloud.aliyuncs.com/debian bookworm-backports/main Translation-en T-2023-12-05-0206.02-F-2023-11-27-1404.10.pdiff [8,464 B] Get: 16 http://mirrors.cloud.aliyuncs.com/debian bookworm-backports/main Translation-en T-2023-12-05-0206.02-F-2023-11-27-1404.10.pdiff [8,464 B] Get: 17 https://download.docker.com/linux/debian bookworm/stable amd64 Packages [13.3 kB] Fetched 708 kB in 1s (708 kB/s) Current status: 2 (+2) upgradable, 27 (+27) new. 安装Docker hotpod@iZuf639kwmsyssxs0c0n9mZ:~$ api docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin The following NEW packages will be installed: containerd.io docker-buildx-plugin docker-ce docker-ce-cli docker-ce-rootless-extras{a} docker-compose-plugin iptables{a} libip6tc2{a} libltdl7{a} libnetfilter-conntrack3{a} libnfnetlink0{a} libslirp0{a} pigz{a} slirp4netns{a} 0 packages upgraded, 14 newly installed, 0 to remove and 2 not upgraded. Need to get 115 MB of archives. After unpacking 412 MB will be used. Do you want to continue? [Y/n/?] y Get: 1 http://mirrors.cloud.aliyuncs.com/debian bookworm/main amd64 pigz amd64 2.6-1 [64.0 kB] Get: 2 http://mirrors.cloud.aliyuncs.com/debian bookworm/main amd64 libip6tc2 amd64 1.8.9-2 [19.4 kB] Get: 3 http://mirrors.cloud.aliyuncs.com/debian bookworm/main amd64 libnfnetlink0 amd64 1.0.2-2 [15.1 kB] Get: 4 http://mirrors.cloud.aliyuncs.com/debian bookworm/main amd64 libnetfilter-conntrack3 amd64 1.0.9-3 [40.7 kB] Get: 5 http://mirrors.cloud.aliyuncs.com/debian bookworm/main amd64 iptables amd64 1.8.9-2 [360 kB] Get: 6 http://mirrors.cloud.aliyuncs.com/debian bookworm/main amd64 libltdl7 amd64 2.4.7-5 [393 kB] Get: 7 http://mirrors.cloud.aliyuncs.com/debian bookworm/main amd64 libslirp0 amd64 4.7.0-1 [63.0 kB] Get: 8 http://mirrors.cloud.aliyuncs.com/debian bookworm/main amd64 slirp4netns amd64 1.2.0-1 [37.5 kB] Get: 9 https://download.docker.com/linux/debian bookworm/stable amd64 containerd.io amd64 1.6.25-1 [28.7 MB] Get: 10 https://download.docker.com/linux/debian bookworm/stable amd64 docker-buildx-plugin amd64 0.11.2-1~debian.12~bookworm [28.2 MB] Get: 11 https://download.docker.com/linux/debian bookworm/stable amd64 docker-ce-cli amd64 5:24.0.7-1~debian.12~bookworm [13.3 MB] Get: 12 https://download.docker.com/linux/debian bookworm/stable amd64 docker-ce amd64 5:24.0.7-1~debian.12~bookworm [22.5 MB] Get: 13 https://download.docker.com/linux/debian bookworm/stable amd64 docker-ce-rootless-extras amd64 5:24.0.7-1~debian.12~bookworm [9,030 kB] Get: 14 https://download.docker.com/linux/debian bookworm/stable amd64 docker-compose-plugin amd64 2.21.0-1~debian.12~bookworm [11.9 MB] Fetched 115 MB in 10s (11.5 MB/s) Selecting previously unselected package pigz. (Reading database ... 93881 files and directories currently installed.) Preparing to unpack .../00-pigz_2.6-1_amd64.deb ... Unpacking pigz (2.6-1) ... Selecting previously unselected package containerd.io. Preparing to unpack .../01-containerd.io_1.6.25-1_amd64.deb ... Unpacking containerd.io (1.6.25-1) ... Selecting previously unselected package docker-buildx-plugin. Preparing to unpack .../02-docker-buildx-plugin_0.11.2-1~debian.12~bookworm_amd64.deb ... Unpacking docker-buildx-plugin (0.11.2-1~debian.12~bookworm) ... Selecting previously unselected package docker-ce-cli. Preparing to unpack .../03-docker-ce-cli_5%3a24.0.7-1~debian.12~bookworm_amd64.deb ... Unpacking docker-ce-cli (5:24.0.7-1~debian.12~bookworm) ... Selecting previously unselected package libip6tc2:amd64. Preparing to unpack .../04-libip6tc2_1.8.9-2_amd64.deb ... Unpacking libip6tc2:amd64 (1.8.9-2) ... Selecting previously unselected package libnfnetlink0:amd64. Preparing to unpack .../05-libnfnetlink0_1.0.2-2_amd64.deb ... Unpacking libnfnetlink0:amd64 (1.0.2-2) ... Selecting previously unselected package libnetfilter-conntrack3:amd64. Preparing to unpack .../06-libnetfilter-conntrack3_1.0.9-3_amd64.deb ... Unpacking libnetfilter-conntrack3:amd64 (1.0.9-3) ... Selecting previously unselected package iptables. Preparing to unpack .../07-iptables_1.8.9-2_amd64.deb ... Unpacking iptables (1.8.9-2) ... Selecting previously unselected package docker-ce. Preparing to unpack .../08-docker-ce_5%3a24.0.7-1~debian.12~bookworm_amd64.deb ... Unpacking docker-ce (5:24.0.7-1~debian.12~bookworm) ... Selecting previously unselected package docker-ce-rootless-extras. Preparing to unpack .../09-docker-ce-rootless-extras_5%3a24.0.7-1~debian.12~bookworm_amd64.deb ... Unpacking docker-ce-rootless-extras (5:24.0.7-1~debian.12~bookworm) ... Selecting previously unselected package docker-compose-plugin. Preparing to unpack .../10-docker-compose-plugin_2.21.0-1~debian.12~bookworm_amd64.deb ... Unpacking docker-compose-plugin (2.21.0-1~debian.12~bookworm) ... Selecting previously unselected package libltdl7:amd64. Preparing to unpack .../11-libltdl7_2.4.7-5_amd64.deb ... Unpacking libltdl7:amd64 (2.4.7-5) ... Selecting previously unselected package libslirp0:amd64. Preparing to unpack .../12-libslirp0_4.7.0-1_amd64.deb ... Unpacking libslirp0:amd64 (4.7.0-1) ... Selecting previously unselected package slirp4netns. Preparing to unpack .../13-slirp4netns_1.2.0-1_amd64.deb ... Unpacking slirp4netns (1.2.0-1) ... Setting up libip6tc2:amd64 (1.8.9-2) ... Setting up docker-buildx-plugin (0.11.2-1~debian.12~bookworm) ... Setting up containerd.io (1.6.25-1) ... Created symlink /etc/systemd/system/multi-user.target.wants/containerd.service → /lib/systemd/system/containerd.service. Setting up docker-compose-plugin (2.21.0-1~debian.12~bookworm) ... Setting up libltdl7:amd64 (2.4.7-5) ... Setting up docker-ce-cli (5:24.0.7-1~debian.12~bookworm) ... Setting up libslirp0:amd64 (4.7.0-1) ... Setting up pigz (2.6-1) ... Setting up libnfnetlink0:amd64 (1.0.2-2) ... Setting up docker-ce-rootless-extras (5:24.0.7-1~debian.12~bookworm) ... Setting up slirp4netns (1.2.0-1) ... Setting up libnetfilter-conntrack3:amd64 (1.0.9-3) ... Setting up iptables (1.8.9-2) ... update-alternatives: using /usr/sbin/iptables-legacy to provide /usr/sbin/iptables (iptables) in auto mode update-alternatives: using /usr/sbin/ip6tables-legacy to provide /usr/sbin/ip6tables (ip6tables) in auto mode update-alternatives: using /usr/sbin/iptables-nft to provide /usr/sbin/iptables (iptables) in auto mode update-alternatives: using /usr/sbin/ip6tables-nft to provide /usr/sbin/ip6tables (ip6tables) in auto mode update-alternatives: using /usr/sbin/arptables-nft to provide /usr/sbin/arptables (arptables) in auto mode update-alternatives: using /usr/sbin/ebtables-nft to provide /usr/sbin/ebtables (ebtables) in auto mode Setting up docker-ce (5:24.0.7-1~debian.12~bookworm) ... Created symlink /etc/systemd/system/multi-user.target.wants/docker.service → /lib/systemd/system/docker.service. Created symlink /etc/systemd/system/sockets.target.wants/docker.socket → /lib/systemd/system/docker.socket. Processing triggers for man-db (2.11.2-2) ... Processing triggers for libc-bin (2.36-9+deb12u3) ... 测试Docker hotpod@iZuf639kwmsyssxs0c0n9mZ:~$ sudo docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 719385e32844: Pull complete Digest: sha256:c79d06dfdfd3d3eb04cafd0dc2bacab0992ebc243e083cabe208bac4dd7759e0 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ 查看Docker版本 hotpod@iZuf639kwmsyssxs0c0n9mZ:~$ sudo docker version Client: Docker Engine - Community Version: 24.0.7 API version: 1.43 Go version: go1.20.10 Git commit: afdd53b Built: Thu Oct 26 09:08:02 2023 OS/Arch: linux/amd64 Context: default Server: Docker Engine - Community Engine: Version: 24.0.7 API version: 1.43 (minimum version 1.12) Go version: go1.20.10 Git commit: 311b9ff Built: Thu Oct 26 09:08:02 2023 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.6.25 GitCommit: d8f198a4ed8892c764191ef7b3b06d8a2eeb5c7f runc: Version: 1.1.10 GitCommit: v1.1.10-0-g18a0cb0 docker-init: Version: 0.19.0 GitCommit: de40ad0 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-07 16:17:35 "},"tips/docker_cancel_sudo.html":{"url":"tips/docker_cancel_sudo.html","title":"Docker配置操作无需sudo","keywords":"","body":"Docker配置操作无须sudo 查看docker版本 docker安装后，如果没有设置权限，直接使用docker 命令，会提示缺少权限 hotpod@bytetoy.cn:~$ docker version Client: Docker Engine - Community Version: 24.0.7 API version: 1.43 Go version: go1.20.10 Git commit: afdd53b Built: Thu Oct 26 09:08:02 2023 OS/Arch: linux/amd64 Context: default permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get \"http://%2Fvar%2Frun%2Fdocker.sock/v1.24/version\": dial unix /var/run/docker.sock: connect: permission denied 查看是否有用户组 hotpod@bytetoy.cn:~$ sudo cat /etc/group | grep docker [sudo] password for hotpod: docker:x:995: 查看docker.sock权限和用户组 hotpod@bytetoy.cn:~$ ll /var/run/docker.sock srw-rw---- 1 root docker 0 Dec 7 15:59 /var/run/docker.sock 修改docker.sock权限 hotpod@bytetoy.cn:~$ sudo chmod a+rw /var/run/docker.sock 将当前用户添加至docker用户组 hotpod@bytetoy.cn:~$ sudo gpasswd -a ${USER} docker Adding user hotpod to group docker hotpod@bytetoy.cn:~$ sudo cat /etc/group | grep docker docker:x:995:hotpod 测试 hotpod@bytetoy.cn:~$ docker version Client: Docker Engine - Community Version: 24.0.7 API version: 1.43 Go version: go1.20.10 Git commit: afdd53b Built: Thu Oct 26 09:08:02 2023 OS/Arch: linux/amd64 Context: default Server: Docker Engine - Community Engine: Version: 24.0.7 API version: 1.43 (minimum version 1.12) Go version: go1.20.10 Git commit: 311b9ff Built: Thu Oct 26 09:08:02 2023 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.6.25 GitCommit: d8f198a4ed8892c764191ef7b3b06d8a2eeb5c7f runc: Version: 1.1.10 GitCommit: v1.1.10-0-g18a0cb0 docker-init: Version: 0.19.0 GitCommit: de40ad0 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-08 16:38:06 "},"tips/docker_cli.html":{"url":"tips/docker_cli.html","title":"Docker常用命令","keywords":"","body":"Docker常用命令 一、镜像操作 查看所有镜像 docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest b6548eacb063 6 days ago 77.8MB hello-world latest 9c7a54a9a43c 7 months ago 13.3kB 删除镜像 docker rmi b6548eacb063 Untagged: ubuntu:latest Untagged: ubuntu@sha256:8eab65df33a6de2844c9aefd19efe8ddb87b7df5e9185a4ab73af936225685bb Deleted: sha256:b6548eacb0639263e9d8abfee48f8ac8b327102a05335b67572f715c580a968e Deleted: sha256:8ceb9643fb36a8ac65882c07e7b2fff9fd117673d6784221a83d3ad076a9733e hotpod@iZuf639kwmsyssxs0c0n9mZ:~$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest 9c7a54a9a43c 7 months ago 13.3kB 二、容器操作 查看运行容器 docker ps -as CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e93766cbddf8 hello-world \"/hello\" 18 minutes ago Exited (0) 18 minutes ago sleepy_proskuriakova 0a322818990e ubuntu \"bash\" 19 minutes ago Exited (0) 19 minutes ago blissful_bouman 61853acec886 hello-world \"/hello\" 20 minutes ago Exited (0) 20 minutes ago focused_hodgkin 删除运行镜像 docker rm $(docker ps -a -q) e93766cbddf8 0a322818990e 61853acec886 docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-08 16:51:02 "},"tips/pip_error.html":{"url":"tips/pip_error.html","title":"pip安装出错解决一例(error: externally-managed-environment)","keywords":"","body":"pip安装出错解决一例(error: externally-managed-environment) 一、报错 pip install aliyundrive-fuse error: externally-managed-environment × This environment is externally managed ╰─> To install Python packages system-wide, try apt install python3-xyz, where xyz is the package you are trying to install. If you wish to install a non-Debian-packaged Python package, create a virtual environment using python3 -m venv path/to/venv. Then use path/to/venv/bin/python and path/to/venv/bin/pip. Make sure you have python3-full installed. If you wish to install a non-Debian packaged Python application, it may be easiest to use pipx install xyz, which will manage a virtual environment for you. Make sure you have pipx installed. See /usr/share/doc/python3.11/README.venv for more information. note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages. hint: See PEP 668 for the detailed specification. 二、解决办法 按照上述提示，安装pipx 安装pipx api pipx The following NEW packages will be installed: blt{a} fonts-font-awesome{a} fonts-lato{a} ghp-import{a} libjs-bootstrap4{a} libjs-highlight.js{a} libjs-lunr{a} libjs-modernizr{a} libjs-popper.js{a} libjs-sizzle{a} libtcl8.6{a} libtk8.6{a} mkdocs{a} node-jquery{a} pipx python3-argcomplete{a} python3-click{a} python3-colorama{a} python3-dateutil{a} python3-iniconfig{a} python3-joblib{a} python3-livereload{a} python3-lunr{a} python3-markdown{a} python3-mergedeep{a} python3-more-itertools{a} python3-nltk{a} python3-numpy{a} python3-packaging{a} python3-pip-whl{a} python3-pluggy{a} python3-psutil{a} python3-py{a} python3-pytest{a} python3-pyyaml-env-tag{a} python3-regex{a} python3-setuptools-whl{a} python3-simplejson{a} python3-tk{a} python3-tornado{a} python3-tqdm{a} python3-userpath{a} python3-venv{a} python3-watchdog{a} python3.11-venv{a} sphinx-rtd-theme-common{a} tk8.6-blt2.5{a} 0 packages upgraded, 47 newly installed, 0 to remove and 2 not upgraded. Need to get 21.8 MB of archives. After unpacking 84.7 MB will be used. Do you want to continue? [Y/n/?] y Get: 1 http://mirrors.cloud.aliyuncs.com/debian bookworm/main amd64 fonts-lato all 2.0-2.1 [2,696 kB] Get: 2 http://mirrors.cloud.aliyuncs.com/debian bookworm/main amd64 libtcl8.6 amd64 8.6.13+dfsg-2 [1,035 kB] Get: 3 http://mirrors.cloud.aliyuncs.com/debian bookworm/main amd64 libtk8.6 amd64 8.6.13-2 [781 kB] 配置PATH pipx安装后，仍会有一个提示，需要配置PATH环境 pipx install aliyundrive-fuse installed package aliyundrive-fuse 0.1.14, installed using Python 3.11.2 These apps are now globally available - aliyundrive-fuse ⚠️ Note: '/home/hotpod/.local/bin' is not on your PATH environment variable. These apps will not be globally accessible until your PATH is updated. Run `pipx ensurepath` to automatically add it, or manually modify your PATH in your shell's config file (i.e. ~/.bashrc). done! ✨ 🌟 ✨ pipx ensurepath Success! Added /home/hotpod/.local/bin to the PATH environment variable. Consider adding shell completions for pipx. Run 'pipx completions' for instructions. You will need to open a new terminal or re-login for the PATH changes to take effect. Otherwise pipx is ready to go! ✨ 🌟 ✨ pipx completions Add the appropriate command to your shell's config file so that it is run on startup. You will likely have to restart or re-login for the autocompletion to start working. bash: eval \"$(register-python-argcomplete pipx)\" zsh: To activate completions for zsh you need to have bashcompinit enabled in zsh: autoload -U bashcompinit bashcompinit Afterwards you can enable completion for pipx: eval \"$(register-python-argcomplete pipx)\" tcsh: eval `register-python-argcomplete --shell tcsh pipx` fish: # Not required to be in the config file, only run once register-python-argcomplete --shell fish pipx >~/.config/fish/completions/pipx.fish eval \"$(register-python-argcomplete pipx)\" 查看.bashrc文件 .bashrc文件末尾已经添加PATH # Created by `pipx` on 2023-12-09 00:03:37 export PATH=\"$PATH:/home/hotpod/.local/bin\" 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-09 09:01:17 "},"tips/frp_config.html":{"url":"tips/frp_config.html","title":"frp实现内网穿透","keywords":"","body":"frp实现内网穿透 frp新版本进行了更新，配置文件不再使用ini作为配置文件，而是使用toml格式作为配置文件，配置方式与之前的略有不同。 一、云服务器开启端口 使用服务器作为转发，前提条件是服务器已经开放了相应的端口，因此需要在云服务器上的安全策略里打开相应的端口，如我的服务器开放了8001-8003这三个端口。 而且frp自身有两个端口需要开放7001和7500，也需要在云服务器上开放这两个端口 二、服务端frps.toml配置 主要配置三个方面，frps端口、身份验证、控制面板配置。 bindAddr = \"0.0.0.0\" bindPort = 7000 # [必选] 绑定端口, 客户端与该端口建立连接 #vhostHTTPPort = 7001 # [可选] http 代理需要, 当访问该端口时就转到对应本地 frpc 代理 # console or real logFile path like ./frps.log log.to = \"frps.log\" # trace, debug, info, warn, error log.level = \"info\" log.maxDays = 30 # 身份验证 auth.method = \"token\" # [可选] 身份验证方式 auth.token = \"password\" # [可选] token 设置, 只有客服端设置了相同 token 才能身份校验通过, 其实就是密码 # 下面是服务端仪表板配置 webServer.port = 7500 # 端口设置 webServer.addr = \"0.0.0.0\" # IP 设置 webServer.user = \"admin\" # 仪表盘用户名设置 webServer.password = \"password\" # 仪表盘用户密码设置 三、客户端frpc.toml配置 配置基础服务器ip、端口以及验证方式，与服务端配置相同即可 然后配置相应的需要转发的功能，如ssh、web等服务。 serverAddr = \"45.101.131.42\" serverPort = 7000 auth.method = \"token\" auth.token = \"password\" [[proxies]] name = \"ssh\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 22 remotePort = 8001 [[proxies]] name = \"web-alist\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 1024 remotePort = 8002 [[proxies]] name = \"web-aria2\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 80 remotePort = 8003 三、使用 访问服务器frps控制面板，使用ip:7500即可 转发功能，如使用ssh，使用ip:8001即可ssh登录内网服务器 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-11 14:47:50 "},"tips/scp_file.html":{"url":"tips/scp_file.html","title":"scp在服务器之间传输文件","keywords":"","body":"scp在两个Linux服务器之间传输文件 需要从另一台服务器中，复制歌曲到本地的linux服务器，scp命令还是非常好用的。 一、命令格式 scp [参数] [原路径] [目标路径] -P:指定远程服务器的ssh端口 -r:递归复制整个目录 二、使用 scp -P 9001 -r bytetoy@hotpod.cn:/home/bytetoy/ustore/伍佰 . The authenticity of host '[hotpod.cn]:9001 ([47.100.130.26]:9001)' can't be established. ED25519 key fingerprint is SHA256:tj98t53ce5UB+Wu/dhVkbKXyUmTLMrIiLjb5AzCgBa0. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added '[hotpod.cn]:9001' (ED25519) to the list of known hosts. bytetoy@hotpod.cn's password: 伍佰&china Blue - 手.mp3 100% 9510KB 400.9KB/s 00:23 伍佰 - 你是我的花朵.mp3 100% 10MB 383.2KB/s 00:27 伍佰&china Blue - 生存游戏.mp3 100% 221 2.7KB/s 00:00 伍佰 - 无尽闪亮的哀愁.mp3 100% 221 2.7KB/s 00:00 伍佰&china Blue - 太极.mp3 100% 359 4.4KB/s 00:00 伍佰&China Blue - 亏欠.mp3 100% 221 2.7KB/s 00:00 伍佰 - 泪桥.ape 100% 359 4.4KB/s 00:00 伍佰 - 亲爱的你.mp3 100% 6052KB 399.3KB/s 00:15 伍佰&china Blue - 答案.mp3 100% 221 2.7KB/s 00:00 伍佰 - 痛哭的人.mp3 100% 221 2.9KB/s 00:00 伍佰 - 我们注定在一起.mp3 100% 221 2.7KB/s 00:00 伍佰 - 浪人情歌.mp3 100% 221 2.7KB/s 00:00 伍佰 - 牵挂.mp3 100% 12MB 393.6KB/s 00:32 伍佰&China Blue - 就是因为爱.mp3 100% 359 4.4KB/s 00:00 伍佰 - 世界第一等.mp3 100% 9726KB 384.8KB/s 00:25 伍佰 - 白鸽.mp3 100% 14MB 383.3KB/s 00:37 伍佰&china Blue - 青春与爱情.mp3 100% 221 2.7KB/s 00:00 伍佰 - 答案.mp3 100% 11MB 363.9KB/s 00:30 伍佰 - 突然的自我.mp3 100% 8477KB 381.6KB/s 00:22 伍佰 - 再度重相逢.mp3 100% 8240KB 332.3KB/s 00:24 伍佰&china Blue - 一次.mp3 100% 221 2.7KB/s 00:00 伍佰 - 有多少爱可以重来.mp3 100% 221 2.7KB/s 00:00 伍佰&china Blue - 无尽闪亮的哀愁.mp3 100% 359 4.4KB/s 00:00 伍佰&china Blue - 小妹.mp3 100% 221 2.7KB/s 00:00 伍佰 - 挪威的森林.mp3 100% 15MB 387.7KB/s 00:39 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-11 15:08:27 "},"tips/unzip_error.html":{"url":"tips/unzip_error.html","title":"unzip解压大文件出错解决办法","keywords":"","body":"unzip解压大文件出错解决办法 一、报错 unzip -x jay.zip Archive: jay.zip replace 029 Jay - 周杰伦 2000/01 可爱女人.flac? [y]es, [n]o, [A]ll, [N]one, [r]ename: y extracting: 029 Jay - 周杰伦 2000/01 可爱女人.flac error: invalid zip file with overlapped components (possible zip bomb) 二、解决办法 使用7z这个命令即可，就是p7zip这个工具 7z e jay.zip 7-Zip [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21 p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,2 CPUs Intel(R) Xeon(R) Platinum (50654),ASM,AES-NI) Scanning the drive for archives: 1 file, 282414656 bytes (270 MiB) Extracting archive: jay.zip -- Path = jay.zip Type = zip Physical Size = 282414656 Everything is Ok Folders: 1 Files: 10 Size: 282411154 Compressed: 282414656 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-13 09:21:41 "},"tips/rclone_to_webdav.html":{"url":"tips/rclone_to_webdav.html","title":"rclone配置同步WebDAV","keywords":"","body":"rclone配置同步WebDAV 为了方便家里NAS和服务之间的文件同步，开启了nas的WebDAB功能，通过rclone这个工具，可以方便同步文件。 一、rclone配置 新建配置 这里新建一个名为nas的webdav配置 rclone config 2023/12/13 19:43:21 NOTICE: Config file \"/home/hotpod/.config/rclone/rclone.conf\" not found - using defaults No remotes found, make a new one? n) New remote s) Set configuration password q) Quit config n/s/q> n Enter name for new remote. name> nas 选择WebDAV存储 rclone在不断更新，不同版本中webdav所处的序号不同，我这里是第52个 Option Storage. Type of storage to configure. Choose a number from below, or type in your own value. 1 / 1Fichier \\ (fichier) 2 / Akamai NetStorage \\ (netstorage) 3 / Alias for an existing remote \\ (alias) 4 / Amazon Drive \\ (amazon cloud drive) 5 / Amazon S3 Compliant Storage Providers including AWS, Alibaba, ArvanCloud, Ceph, ChinaMobile, Cloudflare, DigitalOcean, Dreamhost, GCS, HuaweiOBS, IBMCOS, IDrive, IONOS, LyveCloud, Leviia, Liara, Linode, Minio, Netease, Petabox, RackCorp, Rclone, Scaleway, SeaweedFS, StackPath, Storj, Synology, TencentCOS, Wasabi, Qiniu and others \\ (s3) 51 / Uptobox \\ (uptobox) 52 / WebDAV \\ (webdav) 53 / Yandex Disk \\ (yandex) 54 / Zoho \\ (zoho) 55 / premiumize.me \\ (premiumizeme) 56 / seafile \\ (seafile) Storage> 52 配置webdav的url vendor选择6，即普通的webdav验证方式即可 群辉下webdav默认的端口号是5005，我这里改成了8005 Option url. URL of http host to connect to. E.g. https://example.com. Enter a value. url> http://bytetoy.cn:8005 Option vendor. Name of the WebDAV site/service/software you are using. Choose a number from below, or type in your own value. Press Enter to leave empty. 1 / Fastmail Files \\ (fastmail) 2 / Nextcloud \\ (nextcloud) 3 / Owncloud \\ (owncloud) 4 / Sharepoint Online, authenticated by Microsoft account \\ (sharepoint) 5 / Sharepoint with NTLM authentication, usually self-hosted or on-premises \\ (sharepoint-ntlm) 6 / rclone WebDAV server to serve a remote over HTTP via the WebDAV protocol \\ (rclone) 7 / Other site/service or software \\ (other) vendor> 6 配置登录帐号 即nas中的帐号，群辉默认使用是平时登录的帐号 至于token和高级功能可以暂时不配置 Option user. User name. In case NTLM authentication is used, the username should be in the format 'Domain\\User'. Enter a string value. Press Enter for the default (master). user> admin Option pass. Password. Choose an alternative below. Press Enter for the default (n). y) Yes, type in my own password g) Generate random password n) No, keep existing (default) y/g/n> y Enter the password: password: Confirm the password: password: Option bearer_token. Bearer token instead of user/pass (e.g. a Macaroon). Enter a value. Press Enter to leave empty. bearer_token> Edit advanced config? y) Yes n) No (default) y/n> 配置完毕 配置完毕后，即可显示已经配置的信息。 Configuration complete. Options: - type: webdav - url: http://bytetoy.cn:8005 - vendor: rclone - user: admin - pass: *** ENCRYPTED *** Keep this \"nas\" remote? y) Yes this is OK (default) e) Edit this remote d) Delete this remote y/e/d> y Current remotes: Name Type ==== ==== nas webdav e) Edit existing remote n) New remote d) Delete remote r) Rename remote c) Copy remote s) Set configuration password q) Quit config e/n/d/r/c/s/q> q 二、rclone使用 列表webdav的全部文件 使用刚才名为nas的webdav，即可使用rclone ls nas:/列表全部文件 rclone ls nas:/ 2764211696 classic/2023.HD1080P.英语中字.mp4 2752978740 classic/4K.mp4 166751 classic/Guy.Ritchies.The.Covenant.2023.1080p.AMZN.WEB-DL.DDP5.1.H.264-CM.chs&eng.ass 6673521252 classic/Guy.Ritchies.The.Covenant.2023.1080p.AMZN.WEB-DL.DDP5.1.H.264-Q66.mkv 1976323059 classic/The.Equalizer.2.2018.HD1080P.中英双字.mp4 5985707165 classic/The.Equalizer.2014.BD1080P.X264.AAC.mp4 2254956961 classic/the.equalizer.3.2023.1080p.mp4 5703298583 classic/备份4.mp4 8954839040 classic/行骗高手 (2023) - Sharper.2023.1080p.WEB-DL.DDP5.1.H.264-CUPCAKES.mkv 1444845174 classic/过年.mp4 4184292789 classic/飞机陷落.中英双字.Plane.2023.HD1080P.X265.AAC-YYDS.mp4 3942645760 download/debian-11.7.0-amd64-DVD-1.iso 显示目录 ls是显示全部文件，一般nas中存储的文件以万计，即可使用lsd仅显示目录，配合grep还可以进行过滤 rclone lsd nas:/music | grep 200 -1 2023-10-05 22:03:32 -1 Beyond - 2002 Best Collection -1 2023-05-05 11:58:49 -1 华语经典热歌榜200首 下载文件 rclone copy 源文件 目标位置 rclone copy nas:/music/华语经典热歌榜200首 ~/media/ 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-13 20:27:37 "},"tips/docker_install_jellyfin.html":{"url":"tips/docker_install_jellyfin.html","title":"Docker安装&配置jellyfin","keywords":"","body":"Docker安装&配置jellyfin 域名通过备案，ECS不能浪费啊，搞个jellyfin服务器玩玩，虽然宽带小，用来听听歌还是绰绰有余的。 一、Docker安装jellyfin 这里使用的是nyanmisaka/jellyfin版本，据说全部驱动都已经全部安装好了。 docker pull nyanmisaka/jellyfin:latest 二、启用jellyfin 新建几个必须用的文件夹，如 这三个目录建议配置，通过docker启动，如果不映射目录，就无法添加视频、音乐文件了。 media：存放媒体文件，后续全部电影、节目、音乐都放在此目录下 config：用于存放jellyfin的配置文件 cache：用于存放jellyfin的临时文件 启动jellyfin docker镜像 -v /home/hotpod/.jellyfin/config:/config：映射目录，这里需要映射刚才创建的3个目录 docker run -d --name=Jellyfin -p 8096:8096 \\ -v /home/hotpod/.jellyfin/config:/config -v /home/hotpod/.jellyfin/cache:/cache -v /home/hotpod/media:/media \\ --add-host=api.themoviedb.org:13.224.161.90 \\ --add-host=api.themoviedb.org:13.35.8.65 \\ --add-host=api.themoviedb.org:13.35.8.93 \\ --add-host=api.themoviedb.org:13.35.8.6 \\ --add-host=api.themoviedb.org:13.35.8.54 \\ --add-host=image.tmdb.org:138.199.37.230 \\ --add-host=image.tmdb.org:108.138.246.49 \\ --add-host=api.thetvdb.org:13.225.89.239 \\ --add-host=api.thetvdb.org:192.241.234.54 \\ --restart unless-stopped \\ nyanmisaka/jellyfin:latest 三、反代jellyfin apache启用几个模块 apache2使用反代功能，需要提前启用几个模块 sudo a2enmod rewrite sudo a2enmod proxy sudo a2enmod proxy_http sudo systemctl restart apache2.service 如果没有启用apache的proxy mod，启用阿帕车的代理功能会报错，如： sudo systemctl reload apache2.service Job for apache2.service failed. See \"systemctl status apache2.service\" and \"journalctl -xeu apache2.service\" for details. sudo apachectl configtest AH00526: Syntax error on line 17 of /etc/apache2/sites-enabled/hotpod.conf: Invalid command 'ProxyPass', perhaps misspelled or defined by a module not included in the server configuration Action 'configtest' failed. The Apache error log may have more information. 配置apache反代 配置好反代配置文件后，重新加载apache即可。 # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request's Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. ServerName www.hotpod.cn ServerAlias hotpod.cn # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ProxyPass \"/\" \"http://127.0.0.1:8096/\" ProxyPassReverse \"/\" \"http://127.0.0.1:8096/\" ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with \"a2disconf\". #Include conf-available/serve-cgi-bin.conf 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-13 20:49:28 "},"tips/proxychains_install_config.html":{"url":"tips/proxychains_install_config.html","title":"proxychains-ng配置终端下代理","keywords":"","body":"proxychains-ng配置终端下代理 终端下git和下载一些资料，没有代理的时候，特别的基本以失败告终。 试了好几个工具，都不是很理想，还是老工具proxychains-ng好用，安装和配置都方便，强烈推荐。 一、下载proxychains-ng 目前proxychains-ng最新版本是4.16，官方下载地址为proxychains-ng4.16 然后进行解压： $ tar -xvf proxychains-ng-4.16.tar.xz proxychains-ng-4.16/ proxychains-ng-4.16/tests/ proxychains-ng-4.16/tests/test_getnameinfo.c proxychains-ng-4.16/tests/test_proxy_gethostbyname.c proxychains-ng-4.16/tests/test_gethostent.c proxychains-ng-4.16/tests/test_shm.c proxychains-ng-4.16/tests/test_sendto.c proxychains-ng-4.16/tests/test_gethostbyname.c proxychains-ng-4.16/tests/test_getaddrinfo.c proxychains-ng-4.16/tests/test_v4_in_v6.c proxychains-ng-4.16/tests/test_gethostent_r.c proxychains-ng-4.16/configure proxychains-ng-4.16/tools/ proxychains-ng-4.16/tools/version.sh proxychains-ng-4.16/tools/install.sh proxychains-ng-4.16/TODO proxychains-ng-4.16/src/ proxychains-ng-4.16/src/debug.c proxychains-ng-4.16/src/common.h proxychains-ng-4.16/src/proxychains.conf proxychains-ng-4.16/src/hash.c proxychains-ng-4.16/src/debug.h proxychains-ng-4.16/src/ip_type.h 二、编译 配置 $ ./configure --prefix=/usr --sysconfdir=/etc checking whether C compiler works ... yes checking whether we have GNU-style getservbyname_r() ... yes checking whether we have pipe2() and O_CLOEXEC ... yes checking whether we have SOCK_CLOEXEC ... yes checking whether we have clock_gettime ... yes checking whether $CC defines __APPLE__ ... no checking whether $CC defines __FreeBSD__ ... no checking whether $CC defines __OpenBSD__ ... no checking whether $CC defines __sun ... no checking whether $CC defines __HAIKU__ ... no checking whether we can use -Wl,--no-as-needed ... yes checking what's the option to use in linker to set library name ... --soname checking checking whether we can use -ldl ... yes checking checking whether we can use -lpthread ... yes Done, now run make && make install 编译 $ make printf '#define VERSION \"%s\"\\n' \"$(sh tools/version.sh)\" > src/version.h cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/version.o src/version.c cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/core.o src/core.c cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/common.o src/common.c cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/libproxychains.o src/libproxychains.c cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/allocator_thread.o src/allocator_thread.c cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/rdns.o src/rdns.c cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/hostsreader.o src/hostsreader.c cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/hash.o src/hash.c cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/debug.o src/debug.c cc -fPIC -Wl,--no-as-needed -ldl -lpthread -Wl,--soname,libproxychains4.so \\ -shared -o libproxychains4.so src/version.o src/core.o src/common.o src/libproxychains.o src/allocator_thread.o src/rdns.o src/hostsreader.o src/hash.o src/debug.o cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/main.o src/main.c cc src/common.o src/main.o -ldl -o proxychains4 cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/daemon/hsearch.o src/daemon/hsearch.c cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/daemon/sblist.o src/daemon/sblist.c In file included from src/daemon/sblist.c:3:0: src/daemon/sblist.h:90:0: warning: ignoring #pragma RcB2 DEP [-Wunknown-pragmas] #pragma RcB2 DEP \"sblist.c\" \"sblist_delete.c\" cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/daemon/sblist_delete.o src/daemon/sblist_delete.c In file included from src/daemon/sblist_delete.c:1:0: src/daemon/sblist.h:90:0: warning: ignoring #pragma RcB2 DEP [-Wunknown-pragmas] #pragma RcB2 DEP \"sblist.c\" \"sblist_delete.c\" cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/daemon/daemon.o src/daemon/daemon.c src/daemon/daemon.c:8:0: warning: \"_GNU_SOURCE\" redefined #define _GNU_SOURCE :0:0: note: this is the location of the previous definition In file included from src/daemon/daemon.c:20:0: src/daemon/udpserver.h:11:0: warning: ignoring #pragma RcB2 DEP [-Wunknown-pragmas] #pragma RcB2 DEP \"udpserver.c\" In file included from src/daemon/daemon.c:21:0: src/daemon/sblist.h:90:0: warning: ignoring #pragma RcB2 DEP [-Wunknown-pragmas] #pragma RcB2 DEP \"sblist.c\" \"sblist_delete.c\" cc -DSUPER_SECURE -DHAVE_GNU_GETSERVBYNAME_R -DHAVE_PIPE2 -DHAVE_SOCK_CLOEXEC -DHAVE_CLOCK_GETTIME -Wall -O0 -g -std=c99 -D_GNU_SOURCE -pipe -DLIB_DIR=\\\"/usr/lib\\\" -DSYSCONFDIR=\\\"/etc\\\" -DDLL_NAME=\\\"libproxychains4.so\\\" -fPIC -c -o src/daemon/udpserver.o src/daemon/udpserver.c In file included from src/daemon/udpserver.c:1:0: src/daemon/udpserver.h:11:0: warning: ignoring #pragma RcB2 DEP [-Wunknown-pragmas] #pragma RcB2 DEP \"udpserver.c\" cc src/daemon/hsearch.o src/daemon/sblist.o src/daemon/sblist_delete.o src/daemon/daemon.o src/daemon/udpserver.o -o proxychains4-daemon 安装 $ sudo make install [sudo] password for bytetoy: ./tools/install.sh -D -m 644 libproxychains4.so /usr/lib/libproxychains4.so ./tools/install.sh -D -m 755 proxychains4 /usr/bin/proxychains4 ./tools/install.sh -D -m 755 proxychains4-daemon /usr/bin/proxychains4-daemon 三、配置&测试 将源码（src）目录下的proxychains.conf文件复制到用户目录的的.config目录下，同时添加代理的ip和端口。 配置[ProxyList] # add proxy here ... # meanwile # defaults set to \"tor\" http 127.0.0.1 7890 测试./proxychains4 -f ~/.config/proxychains.conf curl -i www.google.com 80 [proxychains] config file found: /home/bytetoy/.config/proxychains.conf [proxychains] preloading ./libproxychains4.so [proxychains] DLL init: proxychains-ng 4.16 [proxychains] Strict chain ... 127.0.0.1:7890 ... www.google.com:80 ... OK HTTP/1.1 200 OK Date: Mon, 18 Dec 2023 01:55:00 GMT Expires: -1 Cache-Control: private, max-age=0 Content-Type: text/html; charset=ISO-8859-1 Content-Security-Policy-Report-Only: object-src 'none';base-uri 'self';script-src 'nonce-22YkdFi_V8FF2PImpIa2rA' 'strict-dynamic' 'report-sample' 'unsafe-eval' 'unsafe-inline' https: http:;report-uri https://csp.withgoogle.com/csp/gws/other-hp P3P: CP=\"This is not a P3P policy! See g.co/p3phelp for more info.\" 四、下载youtube视频 配置alias 使用命令+配置文件既长且复杂，可以在.bashrc配置一个别名 alias proxychain='/home/bytetoy/apps/proxychains-ng-4.16/proxychains4 -f ~/.config/proxychains.conf' 下载youtube视频proxychain you-get https://www.youtube.com/watch?v=Dx_A1Hu20cI&list=PLYhOT2FBuEidYOFh0f7EsmmhPMk0K0CRk [1] 11803 bytetoy@aml:~/ustore/video$ [proxychains] config file found: /home/bytetoy/.config/proxychains.conf [proxychains] preloading /home/bytetoy/apps/proxychains-ng-4.16/libproxychains4.so [proxychains] DLL init: proxychains-ng 4.16 [proxychains] DLL init: proxychains-ng 4.16 [proxychains] Strict chain ... 127.0.0.1:7890 ... www.youtube.com:443 ... OK [proxychains] Strict chain ... 127.0.0.1:7890 ... www.youtube.com:443 ... OK [proxychains] Strict chain ... 127.0.0.1:7890 ... rr1---sn-i3b7knsl.googlevideo.com:443 ... OK [proxychains] Strict chain ... 127.0.0.1:7890 ... rr5---sn-i3belne6.googlevideo.com:443 ... OK [proxychains] Strict chain ... 127.0.0.1:7890 ... rr5---sn-npoe7ner.googlevideo.com:443 ... OK site: YouTube title: 20130125【我是歌手】羽泉 《燭光裡的媽媽》 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-18 11:06:03 "},"tips/geminipro_chatbot.html":{"url":"tips/geminipro_chatbot.html","title":"Vercel部署Gemini Pro前端程序","keywords":"","body":"Vercel部署Gemini Pro前端程序 最近Google的Gemini Pro大火，也部署一个前端程序自己玩玩。 前提条件是你已经有了Vercel的帐号，没有也不要紧，用github登录即可。 获取api key： makersuite.google.com/app/apikey，获取到API KEY后，留后面备用。 必须要求美国梯子才能访问 部署proxy代理 palm-proxy，部署成功后，记下vercel的网址，留后面备用。 此时如果访问部署后的URL无法访问(404)，也不要紧。 部署Gemini Chat Bot前端程序 Gemini Chat Bot，部署的时候要填写一个环境变量（Environment variables)，GEMINI_API_KEY，对应的值就是google的API KEY 配置环境变量 由于Gemini只能使用美国梯子访问，这也是proxy的作用，进入项目的settings，点开Environment variables，添加一个环境变量API_BASE_URL，值为proxy的vercel的网址。 绑定域名 进入项目的settings，点击 domain，填写绑定的域名，然后在域名服务商做好cname解析即可 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-12-23 18:59:19 "},"tips/mysql_statis_score.html":{"url":"tips/mysql_statis_score.html","title":"MySQL统计学生期末联考成绩","keywords":"","body":"MySQL统计期末学生联考成绩 之前一直使用Excel来做成绩分析,统计各班级,科目对号率非常麻烦,还是MySQL方便一些. 一、表结构 一共3个表: 学生总分成绩表finalscore opt:组合方向,物理或历史 optional:选科,包含首选科目和再选科目 score:总分 CREATE TABLE `finalscore` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `num` CHAR(8) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `class` INT(1) NULL DEFAULT NULL, `name` CHAR(10) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `optional` CHAR(10) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `opt` CHAR(10) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `score` FLOAT NULL DEFAULT NULL, `origin_score` FLOAT NULL DEFAULT NULL, `grade` VARCHAR(50) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `s_order` INT(11) NULL DEFAULT NULL, `f_order` INT(11) NULL DEFAULT NULL, `o_order` INT(11) NULL DEFAULT NULL, `c_order` INT(11) NULL DEFAULT NULL, `cf_order` INT(11) NULL DEFAULT NULL, `co_order` INT(11) NULL DEFAULT NULL, `comment` VARCHAR(50) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', PRIMARY KEY (`id`) USING BTREE ) COLLATE='utf8mb4_general_ci' ENGINE=InnoDB AUTO_INCREMENT=512 ; 学生单科成绩表score type:科目,如:语文,历史或者政治 score:单科赋分分数 origin_score:单科原始分数 a_score:总分 CREATE TABLE `score` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `num` CHAR(8) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `class` INT(1) NULL DEFAULT NULL, `name` CHAR(10) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `optional` CHAR(10) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `opt` CHAR(10) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `score` FLOAT NULL DEFAULT NULL, `origin_score` FLOAT NULL DEFAULT NULL, `a_score` FLOAT NULL DEFAULT NULL, `a_origin_score` FLOAT NULL DEFAULT NULL, `grade` VARCHAR(50) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `type` VARCHAR(50) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `s_order` INT(11) NULL DEFAULT NULL, `f_order` INT(11) NULL DEFAULT NULL, `o_order` INT(11) NULL DEFAULT NULL, `c_order` INT(11) NULL DEFAULT NULL, `cf_order` INT(11) NULL DEFAULT NULL, `co_order` INT(11) NULL DEFAULT NULL, `comment` VARCHAR(50) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', PRIMARY KEY (`id`) USING BTREE ) COLLATE='utf8mb4_general_ci' ENGINE=InnoDB ROW_FORMAT=DYNAMIC AUTO_INCREMENT=4096 ; 划线标准表stld CREATE TABLE `stld` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `t_score` FLOAT NULL DEFAULT NULL, `b_score` FLOAT NULL DEFAULT NULL, `opt` VARCHAR(50) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `type` VARCHAR(50) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', PRIMARY KEY (`id`) USING BTREE ) COLLATE='utf8mb4_general_ci' ENGINE=InnoDB AUTO_INCREMENT=32 ; 二、部分计算方法 统计各班分数数据 统计各班的考试人数,最高分,平均分,最低分 根据班级统计:GROUP BY class SELECT class,COUNT(NAME),MAX(score),round(AVG(score),1),MIN(score) FROM finalscore GROUP BY class 统计各班,各科目数据 统计各班各科目考试人数,最高分,平均分,最低分 根据班级,学科统计:GROUP BY score.class,score.type SELECT class AS 班级,TYPE AS 学科,count(NAME) as 人数,max(score) AS 最高分,round(AVG(score),1) AS 平均分,MIN(score) AS 最低分 FROM score GROUP BY class,TYPE ORDER BY type,class; 统计各班本科上线数据 本科上线条件:JOIN stld ON score>=b_score AND finalscore.opt=stld.opt AND stld.type='总分' 根据班级和方向统计:GROUP BY class,finalscore.opt SELECT class,COUNT(num) FROM finalscore JOIN stld ON score>=b_score AND finalscore.opt=stld.opt AND stld.type='总分' GROUP BY class,finalscore.opt 统计各班单科上线数据 统计各班,单科上线名单 选科方向,选科,单科成绩上线JOIN stld ON (score.`type`=stld.`type` AND score.opt=stld.opt AND score.score>=stld.b_score) 根据班级,学科统计:GROUP BY score.class,score.type SELECT score.class AS 班级,score.`type` AS 学科,COUNT(num) AS 人数 from score JOIN stld ON (score.`type`=stld.`type` AND score.opt=stld.opt AND score.score>=stld.t_score) GROUP BY score.class,score.type ORDER BY score.type,score.class 统计各班,单科命中数据 命中:总分上线且本学科上线 统计各班总分上线,同时单科成绩也上线人数 选科方向,选科,单科成绩上线JOIN stld ON (score.`type`=stld.`type` AND score.opt=stld.opt AND score.score>=stld.b_score) 总分上线:WHERE a_score>=406 AND score.opt='历史' 根据班级,学科统计:GROUP BY score.class,score.type SELECT score.class AS 班级,score.`type` AS 学科,COUNT(num) AS 人数 from score JOIN stld ON (score.`type`=stld.`type` AND score.opt=stld.opt AND score.score>=stld.b_score) WHERE a_score>=406 AND score.opt='历史' GROUP BY score.class,score.type ORDER BY score.type,score.class 查看各班总分且单科上线学生 根据划线标准,查看总分上线,并且单科成绩也上线的学生 总分上线:WHERE a_score>=431.5 AND score.opt='物理' 选科方向,选科,单科成绩上线JOIN stld ON (score.`type`=stld.`type` AND score.opt=stld.opt AND score.score>=stld.b_score) SELECT score.num,score.class,score.NAME,score.optional,score.opt,score.score,score.origin_score,score.type, score.a_score,score.a_origin_score from score JOIN stld ON (score.`type`=stld.`type` AND score.opt=stld.opt AND score.score>=stld.b_score) WHERE a_score>=431.5 AND score.opt='物理' ORDER BY name 统计各班日语、英语人数 外语包含英语，日语两个语种，分别统计各班两个语种的考试人数 根据班级,语种统计GROUP BY class,comment SELECT class,TYPE,COMMENT,COUNT(num) FROM score WHERE TYPE='外语' GROUP BY class,comment 统计各班日语,英语上线数据 选科方向,选科,单科成绩上线JOIN stld ON (score.`type`=stld.`type` AND score.opt=stld.opt AND score.score>=stld.b_score) 根据班级,专业,语种:``GROUP BY score.class,score.type,score.comment```` SELECT score.class AS 班级,score.`type` AS 学科,score.comment,COUNT(num) AS 人数 from score JOIN stld ON (score.`type`=stld.`type` AND score.opt=stld.opt AND score.score>=stld.b_score) WHERE score.type='外语' GROUP BY score.class,score.type,score.`comment` ORDER BY score.class,score.comment 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-01 16:32:24 "},"tips/mysql_compara_score.html":{"url":"tips/mysql_compara_score.html","title":"MySQL分析学生中考和期末联考成绩","keywords":"","body":"MySQL分析学生中考和期末联考成绩 一、表结构 一共3个表 学生信息表info optional:选科 opt：方向（物理或历史） CREATE TABLE `info` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `num` CHAR(8) NOT NULL DEFAULT '0' COLLATE 'utf8mb4_general_ci', `class` INT(11) NOT NULL DEFAULT '0', `name` VARCHAR(50) NOT NULL DEFAULT '0' COLLATE 'utf8mb4_general_ci', `optional` VARCHAR(50) NOT NULL DEFAULT '0' COLLATE 'utf8mb4_general_ci', `opt` VARCHAR(50) NOT NULL DEFAULT '0' COLLATE 'utf8mb4_general_ci', `level` INT(11) NOT NULL DEFAULT '0', PRIMARY KEY (`id`) USING BTREE ) COLLATE='utf8mb4_general_ci' ENGINE=InnoDB AUTO_INCREMENT=512 ; 学生期末考试成绩表 s_order:成绩校排名 f_order:成绩方向校排名 CREATE TABLE `g_score` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `num` CHAR(8) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `class` INT(1) NULL DEFAULT NULL, `name` CHAR(10) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `optional` CHAR(10) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `opt` CHAR(10) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `score` FLOAT NULL DEFAULT NULL, `origin_score` FLOAT NULL DEFAULT NULL, `grade` VARCHAR(50) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `type` VARCHAR(50) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', `s_order` INT(11) NULL DEFAULT NULL, `f_order` INT(11) NULL DEFAULT NULL, `o_order` INT(11) NULL DEFAULT NULL, `c_order` INT(11) NULL DEFAULT NULL, `cf_order` INT(11) NULL DEFAULT NULL, `co_order` INT(11) NULL DEFAULT NULL, `comment` VARCHAR(50) NULL DEFAULT NULL COLLATE 'utf8mb4_general_ci', PRIMARY KEY (`id`) USING BTREE ) COLLATE='utf8mb4_general_ci' ENGINE=InnoDB ROW_FORMAT=DYNAMIC AUTO_INCREMENT=4607 ; 学生中考成绩表CREATE TABLE `s_score` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `num` CHAR(8) NOT NULL DEFAULT '0' COLLATE 'utf8mb4_general_ci', `class` INT(11) NOT NULL DEFAULT '0', `name` VARCHAR(50) NOT NULL DEFAULT '0' COLLATE 'utf8mb4_general_ci', `optional` VARCHAR(50) NOT NULL DEFAULT '0' COLLATE 'utf8mb4_general_ci', `opt` VARCHAR(50) NOT NULL DEFAULT '0' COLLATE 'utf8mb4_general_ci', `score` FLOAT NOT NULL DEFAULT '0', `type` VARCHAR(50) NOT NULL DEFAULT '0' COLLATE 'utf8mb4_general_ci', `s_order` INT(11) NULL DEFAULT NULL, `f_order` INT(11) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE ) COLLATE='utf8mb4_general_ci' ENGINE=InnoDB AUTO_INCREMENT=5111 ; 二、部分统计方法 线下生本科线 SELECT i.num,i.class,i.name,i.optional,i.opt,f.score FROM info i,finalscore f WHERE i.num=f.num AND f.score>=400 AND i.level=0; 线下生高于平均分数 新建均分变量:SET @jf:=(select round(AVG(score),1) FROM finalscore); 大于均分:f.score>=@jf SET @jf:=(select round(AVG(score),1) FROM finalscore); SELECT i.num,i.class,i.name,i.optional,i.opt,f.score FROM info i,finalscore f WHERE i.num=f.num AND f.score>=@jf AND i.level=0 ORDER BY f.score desc,i.class; 线下生高于平均分数（分物理和历史组合） 同上 SET @jf:=(select round(AVG(score),1) FROM finalscore WHERE opt='物理'); SELECT i.num,i.class,i.name,i.optional,i.opt,f.score FROM info i,finalscore f WHERE i.num=f.num AND f.score>=@jf AND i.level=0 AND f.opt='物理' ORDER BY f.score desc,i.class; 根据信息名单，合并中考与期末分数 使用子查询联合两个分数表(SELECT score FROM score f WHERE f.num=i.num AND f.type='语文') f_score SELECT i.num,i.class,i.name,i.optional,i.opt,i.level,(SELECT score FROM finalscore f WHERE f.num=i.num) f_score,(SELECT score FROM s_score s WHERE s.num=i.num AND s.type='总分') s_score FROM info i ORDER BY class asc,f_score desc; 根据信息名单，合并单科中考与期末分数 使用子查询联合两个分数表(SELECT score FROM score f WHERE f.num=i.num AND f.type='语文') f_score 这种方式感觉不好，不如join方便，查询的字段无法在where中使用 SELECT i.num,i.class,i.name,i.optional,i.opt,i.level,(SELECT score FROM score f WHERE f.num=i.num AND f.type='语文') f_score,(SELECT score FROM s_score s WHERE i.num=s.num AND s.type='语文') s_score FROM info i ORDER BY class asc,f_score desc; 计算方向、单科成绩排名 计算排名：(rank() over(order BY s.score DESC)) as pm rank()是窗口函数 SELECT s.num,s.class,s.name,s.score,(rank() over(order BY s.score DESC)) as pm FROM s_score s WHERE s.type='数学' AND s.opt='物理'; 通过临时表，更新总分成绩排名 创建临时表:CREATE TEMPORARY table tmp_score as SELECT 更新数据:UPDATE s_score SET s_order 有9大主科，每次写一个SQL就非常不方便，用Python实现就比较容易 DROP TEMPORARY TABLE IF EXISTS tmp_score; CREATE TEMPORARY table tmp_score as SELECT s.num,s.class,s.name,s.score,(rank() over(order BY s.score DESC)) as s_order FROM s_score s WHERE s.type='总分'; UPDATE s_score SET s_order=(SELECT s_order FROM tmp_score WHERE tmp_score.num=s_score.num AND s_score.type='总分') 根据信息名单，合并中考、期末分数、排名等 info是主表使用左联合,查询中考和期末考试成绩left JOIN g_score g ON i.num=g.num AND i.optional=g.optional AND g.type='总分' 联合查询有个好处,处理多个表的多个字段更容易.而子查询则比较复杂 SELECT i.class,i.name,i.optional,i.level,g.score,g.origin_score,g.s_order,g.f_order,s.score,s.s_order,s.f_order FROM info i left JOIN g_score g ON i.num=g.num AND i.optional=g.optional AND g.type='总分' LEFT JOIN s_score s ON i.num=s.num AND i.optional=s.optional AND s.`type`='总分' ORDER BY class,g.score desc 统计进步前50名 按照期末、中考方向相差最大的排名排序：ORDER BY s.f_order-g.f_order desc 取前50名：LIMIT 50 SELECT i.class,i.name,i.optional,i.level,g.score,g.origin_score,g.s_order,g.f_order,s.score,s.s_order,s.f_order FROM info i left JOIN g_score g ON i.num=g.num AND i.optional=g.optional AND g.type='总分' LEFT JOIN s_score s ON i.num=s.num AND i.optional=s.optional AND s.`type`='总分' ORDER BY s.f_order-g.f_order DESC LIMIT 50 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-07 15:37:21 "},"tips/git_force_push.html":{"url":"tips/git_force_push.html","title":"Github提交密码信息后补救措施","keywords":"","body":"Github提交密码信息后补救措施 新建一个repo，在添加.gitignore文件之前，把仓库push到github，虽然数据库密码配置文件可以删除，但是git的commit记录依旧在。根据github官方的建议，可以使用bfg来删除commit记录 使用BFG工具 BFG Repo-Cleaner是github官方推荐的工具，用于删除敏感信息数据文件 删除敏感信息文件 config.ini是MySQL数据的链接配置文件，前面已经提交过一次。此时使用BFG工具进行删除 java -jar .\\bfg-1.14.0.jar --delete-files config.ini Using repo : D:\\bench\\.git Found 33 objects to protect Found 3 commit-pointing refs : HEAD, refs/heads/master, refs/remotes/origin/master Protected commits ----------------- These are your protected commits, and so their contents will NOT be altered: * commit f8efb82f (protected by 'HEAD') Cleaning -------- Found 3 commits Cleaning commits: 100% (3/3) Cleaning commits completed in 540 ms. Updating 2 Refs --------------- Ref Before After ------------------------------------------------ refs/heads/master | f8efb82f | aee89bd8 refs/remotes/origin/master | f8efb82f | aee89bd8 Updating references: 100% (2/2) ...Ref update completed in 39 ms. Earliest Latest | | D D m D = dirty commits (file tree fixed) m = modified commits (commit message or parents changed) Before After ------------------------------------------- First modified commit | 8678605e | ed92ad02 Last dirty commit | b3d21fd9 | f09c8f34 Deleted files Filename Git id config.ini | ebc00fef (70 B ) In total, 5 object ids were changed. Full details are logged here: 强制push 删除文件后，必须push只github仓库 我使用的是Pycharm，强制push，需要在push对话框，选择Force push git push --force 提示： 如果在pycharm中无法选中Force push，需要进行配置： File-->Settings-->Version Control-->Git-->Push-->Protected branches，删除文本框中的master,main 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-08 21:08:43 "},"tips/pycharm_http_proxy.html":{"url":"tips/pycharm_http_proxy.html","title":"Git使用代理提交Github","keywords":"","body":"Git使用代理提交Github 使用git或者Pycharm向github提交代码，经常会出现以下两种异常： 配置代理可解决问题。 连接超时Failed to connect to github.com port 443 after 21097 ms: Couldn't connect to server 无法访问fatal: unable to access 'https://github.com/ByteToy/algo/': Failure when receiving data from the peer Pycharm配置代理 Pycharm中配置代理，基本上不起作用，仅作配置演示 File-->Settings-->Appearance&Behavior-->System Settings-->HTTP Proxy-->Manual proxy configuration Git配置代理 直接在终端下进行配置，pycharm也会调用此代理配置 配置代理 git config --global http.proxy 127.0.0.1:7890 git config --global https.proxy 127.0.0.1:7890 查看配置 git config --global --list user.name=ByteToy user.email=12620716@qq.com safe.directory=D:/bench http.proxy=127.0.0.1:7890 https.proxy=127.0.0.1:7890 取消代理配置 如果后面不需要代理，或者代理服务器不可用了，可以取消代理配置 git config --gobal unset http.proxy git config --gobal unset https.proxy 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-08 21:07:41 "},"tips/vim_modify_jar.html":{"url":"tips/vim_modify_jar.html","title":"jar修改技巧一则","keywords":"","body":"jar修改技巧一则 使用Spring boot开发的web程序，可能会出现数据库服务器的ip、帐号密码等修改的情况，如果不方便重新编译生成新的jar包，可以用zip程序解开，然后修改了再压缩为jar包。 今天学到了一个方便的技巧，可以用vim直接进行修改。 用vim打开jar包 打开jar包后，会出现包的目录及文件列表，如下： 找到需要修改的文件 找到需要修改的文件，可以使用vim的搜索功能/，如：/application.yml，然后打开文件。 保存文件并退出 文件修改结束后，使用`:wq，退出文件。 如果无其他文件需要修改，退出jar包：:q 重新启动web服务即可。 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-02-19 21:11:40 "},"tips/systemctl_config.html":{"url":"tips/systemctl_config.html","title":"systemctl配置开机启动服务","keywords":"","body":"systemctl配置开机启动服务 N1盒子上安装了几个后台服务，由于办公室偶尔会停电，服务没有随机启动。 systemctl常用命令 启动服务 systemctl start alist 查看服务状态 systemctl status aria2.service ● aria2.service - Aria2 Loaded: loaded (/etc/systemd/system/aria2.service; enabled; vendor preset: enabled) Active: active (running) since Wed 2024-03-06 15:45:50 CST; 16h ago Main PID: 12404 (aria2c) Tasks: 1 (limit: 4915) CGroup: /system.slice/aria2.service └─12404 /usr/bin/aria2c --conf-path=/home/bytetoy/.aria2/aria2.conf Mar 07 08:23:32 aml aria2c[12404]: [#29207b 0B/0B CN:1 DL:0B] Mar 07 08:23:32 aml aria2c[12404]: 03/07 08:23:32 [NOTICE] Serialized session to '/home/bytetoy/.aria2/aria2.session' successfully. Mar 07 08:23:50 aml aria2c[12404]: [#29207b 0B/0B CN:1 DL:0B] Mar 07 08:23:50 aml aria2c[12404]: 03/07 08:23:50 [NOTICE] Download complete: /home/bytetoy/ustore/微信图片_20240126163917.jpg Mar 07 08:23:50 aml aria2c[12404]: 03/07 08:23:50 [NOTICE] Serialized session to '/home/bytetoy/.aria2/aria2.session' successfully. Warning: Journal has been rotated since unit was started. Log output is incomplete or unavailable. 应用服务 systemctl enable alist 一、Alist 安装目录 /home/bytetoy/apps/alist alist.service配置文件 alist的配置文件在alist的目录下，通过./alist server启动时，需要加载alist/data目录下的配置文件，因此需要指定WorkingDirectory=/home/bytetoy/apps/alist [Unit] Description=alist After=network.target [Service] Type=simple WorkingDirectory=/home/bytetoy/apps/alist ExecStart=/home/bytetoy/apps/alist/alist server Restart=on-failure [Install] WantedBy=multi-user.target 二、aria2 安装目录 /usr/bin/aria2c aria2.service配置文件 [Unit] Description=Aria2 After=network.target [Service] ExecStart=/usr/bin/aria2c --conf-path=/home/bytetoy/.aria2/aria2.conf [Install] WantedBy=default.target 三、Frp 安装目录 /home/bytetoy/apps/frp/frpc frpc.service配置文件 [Unit] # 服务名称，可自定义 Description = frp client After = network.target syslog.target Wants = network.target [Service] Type = simple # 启动frps的命令，需修改为您的frps的安装路径 ExecStart = /home/bytetoy/apps/frp/frpc -c /home/bytetoy/apps/frp/frpc.toml [Install] WantedBy = multi-user.target 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-03-07 08:38:13 "},"tips/mysql_create_user.html":{"url":"tips/mysql_create_user.html","title":"MySQL新增帐号","keywords":"","body":"MySQL新增帐号 默认情况下，不使用root帐号，至少不开放root帐号远程登录功能，以保证安全。 新建帐号 'zhanghao'@'%'：设置帐号，@'%'配置远程登录 identified by 'mima':设置密码 mysql> create user 'zhanghao'@'%' identified by 'mima'; Query OK, 0 rows affected (0.31 sec) 授权 hbgk.*:为帐号授权数据库 mysql> grant all on hbgk.* to 'zhanghao'@'%'; Query OK, 0 rows affected (0.01 sec) 刷新权限 mysql> flush privileges; Query OK, 0 rows affected (0.04 sec) 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-03-15 22:22:17 "},"tips/mysql_import_csv.html":{"url":"tips/mysql_import_csv.html","title":"MySQL启用导入外部数据功能","keywords":"","body":"MySQL启用导入外部数据功能 默认情况下，mariadb没有启用外部导入数据功能，需要手动开启。 如果导入数据时，出现下图报错，可以使用下面方式解决 查看local_infile变量 mysql> show global variables like 'local_infile'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | local_infile | OFF | +---------------+-------+ 1 row in set (0.00 sec) 开启local_infile变量 mysql> set global local_infile=1; Query OK, 0 rows affected (0.00 sec) 将当前帐号退出再重新登录即可导入外部csv数据了 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2024-03-15 22:32:38 "},"stm32/":{"url":"stm32/","title":"STM32","keywords":"","body":"简介 本文记录最近学习stm32F407为核心开发板的笔记 因为原Raspberry pi pico开发板芯片功能不够，改换stm32的板子 核心板芯片：stm32F407ZGT6 开发环境：STM32CubeMX和STM32CubeIDE 串口下载工具：FlyMcu 串口调试工具：COMTransmit 串口转USB驱动：CH340 下载器：J-link（jlink的下载速度远高于串口，而且可以使用debug功能） 驱动下载 Flash驱动：W25Q128驱动 LCD驱动：ST7789 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-09-30 11:33:18 "},"stm32/stm32f407_config.html":{"url":"stm32/stm32f407_config.html","title":"stm32F407开发环境配置","keywords":"","body":"stm32F407开发环境配置 通过ST官方提供的STM32CubeMX和STM32CubeIDE来作为开发配置工具和开发工具，非常方便，会大大降低学习难度，强烈推荐使用 STM32CubeIDE就是魔改的Eclipse，相当于在eclipse的基础上增加了一个Plugin，可以通过这个工具图形化配置时钟、GPIO接口等 一、安装 安装太简单了，就不细写了，一路next就行，就几个需要注意的地方 eclipse是基于Java的，电脑上需要安装好jre或者JDK； 安装完毕之后，通过STM32CubeMX，下载相应的芯片HAL库，我的开发板是stm32f407zgt6，下载相应的库 二、配置 新建项目，需要针对开发板芯片进行对应的配置，这里稍微复杂一点，做个记录 基本配置（SYS) Debug：配置为：Series Wire 时钟配置(RCC) 启用外部高速时钟，我这个开发板外部使用的是要给8M晶振 HSE（外部高速时钟）：Crystal/Ceramic Resonator LSE（外部低速时钟）：可以不启用，或者同HSE 启用外部时钟：Input frequency：设置为8M PLL Source设置为HSE System Clock设置为：PLLCLK（Enable css） HCLK设置为168M，最高主频，这里只需要填写对应主频即可，系统会自动计算/M,*N,/P等数据 ABP1,ABP2预分频分别设置为4，2 如果设置的参数有问题，最右边的频率数据会显示红色 GPIO配置(GPIO) 通过图形化的引脚配置，鼠标电子芯片图形上对应的引脚，设置相应模式即可 Project Manager配置 Project配置：填写项目名称、项目位置，以及开发IDE工具（IDE开发工具的选择，决定了生成代码的结构和配置文件，我使用的是STM32CubeIDE，在Toolchain/IDE选择STM32CubeIDE，如果是其他工具，选择对应的选项） Code generator：勾选copy only the ...（复制必要的开发库文件）和Generate peri...（自动生成c和h头文件） 三、下载程序 通过串口下载的是hex二进制文件，但是STM32CubeIDE默认生成的是elf文件，因此需要配置IDE。 生成hex文件 项目右键-->Properties-->C/C++ build-->Settings-->Tool settings-->MCU Post build outputs-->勾选Convert to intel hex file 生成hex文件：Project--> build project 找到hex文件：项目目录-->Debug-->项目名称.hex 烧录程序 根据开发板卖家推荐的串口烧录程序：flymcu 安装串口转USB的驱动：CH340驱动，去wch官方网站下载，安装驱动的时候，需要插上开发板（开发板连接usb ttl这个usb接口） 配置flymcu： 选择com端口，CH340驱动安装完毕后，可以在系统设备管理器中，查看com是哪个端口，我的系统显示为com3 配置波特率（bps）为：76800 选择STMISP，勾选校验和编程后执行 勾选编程前重装文件 取消勾选编程到flash时写选项字节 选择DTR低电平复位，RTS高电平进Bootloader 注意：以上选项选择一个，写入程序时，就会报错，务必注意 选择需要烧录的hex文件后，点击开始编程即开始烧录，flymcu的右边log会显示烧录进度和日志。 四、注意 STM32CubeIDE已经包含了STM32CubeMX的图形化配置功能，其实安装一个即可； GPIO的引脚配置，下次根据实际例程来配置； 时钟配置，其实只需要配置几个地方即可，无需配置主频分频，按照上面的步骤就行了 代码写在main.c的提示位置，后面再次更改配置的时候，系统会保护写的代码，否则写的代码就被擦除了 我是通过开发板上的串口转usb端口来下载程序，板载2个usb接口，使用usb ttl接口，不能使用usb otg接口 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-07-21 15:03:30 "},"stm32/stm32f407_key.html":{"url":"stm32/stm32f407_key.html","title":"stm32F407按键输入","keywords":"","body":"stm32F407按键输入Sample stm32核心板的第二个实验，因为板子、面包板、轻触开关等硬件原因，踩了几个坑，总算搞定了。 一、硬件 stm32F407最小系统板 发光二极管 面包板 杜邦线 二、接口连接方式 板载LED：（原理图上显示板载的两个led等均上拉了一个电阻，因此是低电平才能点亮，但是系统里设置的是初始化输出为high高电平，因此是连接电源之后是不亮的。） LED0--PF9：GPIO output level设置为high LED1--PF10：GPIO output level设置为high 外部LED：（外部led是直接连接GPIO引脚，因此初始化后，根据电平高低，会点亮PF7，PF8因为设置的low，因此是不亮的。） LED3--PF7：GPIO output level设置为high LED4--PF8：GPIO output level设置为low 板载按键： KEY0--PE4：板子上下拉连接一个10k电阻，需要设置GPIO Pull down/Pull up为pull down，高电平触发有效 KEY_UP--PA0：需要设置GPIO Pull down/Pull up为pull down，高电平触发有效 外部按键 KEY_PF--PF6：外部按键上拉一个电阻，需要设置模式为GPIO Pull down/Pull up为pull up，低电平触发有效。（这个按键是外购的，一般外购的轻触开关，基本都是上拉电阻，因此都是低电平触发有效） 面包板连接 面包板两侧只有两个的是竖向联通 面包板中间的两块多导轨的，是横向联通的 这里一定要搞清楚面包板的联通方式，两侧和中间的联通方式不同，搞错了按键是无效的。 三、代码 将按键扫描封装为一个函数scanKeys() void scanKeys() { //KEY0是下拉电阻，高电平触发 //这个按键是按下去就转换电平信号，然后重设按键电平 if(KEY0==GPIO_PIN_SET){ HAL_Delay(100); if(KEY0==GPIO_PIN_SET) { HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_9); // HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_8); while(KEY0==GPIO_PIN_RESET); } } //KEY_UP是高电平触发 //这个按键的模式是按键松开后，才转换输出电平型号， if(KEY_UP==GPIO_PIN_SET) { HAL_Delay(100); if(KEY_UP==GPIO_PIN_SET) { //检测按键有没有松开 while(KEY_UP==GPIO_PIN_SET); HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_10); // HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_7); } } //KEY_PF是上拉电阻，低电平触发，其他同KEY_UP if(KEY_PF==GPIO_PIN_RESET) { HAL_Delay(100); if(KEY_PF==GPIO_PIN_RESET) { while(KEY_PF==GPIO_PIN_RESET); // HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_10); //7：初始化高电平，通电灯即亮 //8：初始化低电平，通电灯不亮 HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_7); HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_8); } } } 四、注意事项 按键电阻的上拉、下拉方式，决定了触发电平信号的高低，这里核心板和外购的按键的模式就不同； 面包板的连接方式，这里折腾了我很久，不同区域的导轨联通方式是不同的； GPIO接口是否被占用，需要查看核心板的GPIO接口分配表，尽量选用完全独立的IO接口； 使用#define宏定义，代码美观好看，又容易理解； 这个例程的难点不是几行代码，而是GPIO接口、接口模式的选择和配置，尤其是使用了非板载的LED灯和按键。 记录一段关于上拉电阻和下拉电阻的注释：电源到器件引脚上的电阻叫上拉电阻，作用是平时使该引脚为高电平，地到器件引脚上的电阻叫下拉电阻，作用是平时使该引脚为低电平。 上拉电阻的目的是为了保证在无信号输入时输入端的电平为高电平。而在信号输入为低电平是输入端的电平应该也为低电平。如果没有上拉电阻，在没有外界输入的情况下输入端是悬空的，它的电平是未知的无法保证的，上拉电阻就是为了保证无信号输入时输入端的电平为高电平，同样还有下拉电阻它是为了保证无信号输入时输入端的电平为低电平 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-07-21 15:16:36 "},"stm32/stm32f407_nvic.html":{"url":"stm32/stm32f407_nvic.html","title":"stm32F407外部中断","keywords":"","body":"stm32F407外部中断Sample 关于stm32F407芯片所拥有的中断参数，这里就介绍了，官方手册上有，主要是记录中断开发的几个重要地方，如：io配置、中断调用流程、中断函数重写等。 本Sample是通过一个外部按键开关，控制两个LED灯交替切换点亮和熄灭。 一、硬件 输出： LED0PF7; LED1PF8; 输入： KEYPF6（按键上拉电阻，注意配置需要同样设置，如果按键是其他的类型，需要根据实际情况配置 二、配置 时钟（RCC）配置：启用外部8M晶振的高速时钟，最高168M频率，STM32CubeMX可以自动设置； GPIO配置： PF7、PF8：设置为output，输出初始化电平分别设置为high和low，这样方便根据按键点亮和熄灭两个灯； PF6：设置为GPIO_EXTI6，gpio mode设置为上沿触发；gpio pull up/pull down设置为上拉电阻； NVIC配置：在GPIO栏目的NVIC标签页下，启用外部中断，我这里显示的外部中断编号为EXTI line[9:5]，连接不同的GPIO接口，这个显示会不同 SYS配置：启用串口调试 三、中断调用流程 通过STM32CubeMX配置硬件和软件环境后，自动生成的代码，可以先编译一次，这个各个库文件就会全部生成，可以方便的用F3功能跳转函数，查看函数的调用流程。 调用流程 main.c-->gpio.c-->stm32f4xx_it.c-->stm32f4xx_hal_gpio.c-->main.c gipo.c 关键代码就是启用NVIC功能，配置IO引脚，代码如下： HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0, 0); HAL_NVIC_EnableIRQ(EXTI9_5_IRQn); stm32f4xx_it.c 此文件是在项目的src（源代码目录下） 系统会根据GPIO和NVIC的配置，自动生成一个中断函数void EXTI9_5_IRQHandler(void)，此函数配置了GPIO的端口引脚，并调用通用中断函数，代码如下： void EXTI9_5_IRQHandler(void) { /* USER CODE BEGIN EXTI9_5_IRQn 0 */ /* USER CODE END EXTI9_5_IRQn 0 */ HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_6); /* USER CODE BEGIN EXTI9_5_IRQn 1 */ /* USER CODE END EXTI9_5_IRQn 1 */ } stm32f4xx_hal_gpio.c 此文件是在驱动的库文件目录的driver目录下 中断函数在这里通过调用回调函数（callback），实现中断的功能。 在此文件中有两个函数，一个通用中断处理函数，一个回调函数 通用外部中断处理函数：主要有两个功能：1清除中断标记；2调用回调函数；注意函数里有一个if判断语句，这个是根据NVIC的配置中，我们使用配置了上升沿触发，即!=RESET void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin) { /* EXTI line interrupt detected */ if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) { __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin); HAL_GPIO_EXTI_Callback(GPIO_Pin); } } 回调函数：__weak表明是一个虚函数，我们要实现的功能，就是覆写这个函数来实现。 __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { /* Prevent unused argument(s) compilation warning */ UNUSED(GPIO_Pin); /* NOTE: This function Should not be modified, when the callback is needed, the HAL_GPIO_EXTI_Callback could be implemented in the user file */ } 四、代码 覆写回调函数，就是要在这个函数中实现我们的功能，比如判断触发的按键，按键输入触发后，实现的一系列动作。 回调函数的实现是在main.c文件中完成 以下代码是实现通过按键控制两个输出LED灯的切换交替点亮，即通过转换高低电平来实现。 /* USER CODE BEGIN 0 */ void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if(GPIO_Pin==GPIO_PIN_6) { HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_7); HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_8); } } /* USER CODE END 0 */ 五、其他 抄写一段内容 上升沿检测由低电平到高电平，下降沿检测由高电平到低电平。 在callback回调函数中，仅判断了端口号，而没有判断端口组，如果有两个都是6的端口号，但是分数不同端口组，如何判断呢！ 另一个问题就是通过外部中断实现的按键输入，没有通过gpio扫描按键输入方式稳定 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-07-23 13:52:29 "},"stm32/stm32f407_tim.html":{"url":"stm32/stm32f407_tim.html","title":"stm32F407定时器","keywords":"","body":"stm32F407定时器Sample stm32的定时器，顾名思义用于定时任务，难点是需要根据定时器的时钟进行计算预分频和计数器。 本例程是以两个定时器，分配控制两个LED灯定时点亮，但是这两个LED点亮间隔时间不同。 一、系统定时器 stm32F407拥有14个定时器， 高级定时器：TIM1,TIM8,APB2 基本定时器：TIM6,TIM7,APB1 通用定时器：TIM2-TIM5,TIM9-TIM14,APB1(TIM9-11,APB2) 二、硬件 任务：通使用定时器控制间隔时间，通过外部中断控制LED灯的闪烁间隔时间 LED1PF7：0.5秒（500ms）闪烁一次 LED2PF8：1秒（1000ms）闪烁一次 三、定时器原理 stm32的定时器有两个核心的概念：分频器（Prescaler）和计数器（Counter Period），当分频器溢出后会触发计数器，计数器溢出后，即定时的时间到了，触发外部中断。 分频器是16位，即数值在0-65535之间； 计数器有16位，也有32位，图形化的配置工具中有提示，如TIM2的计数器是32位的，TIM3的计数器是16位的。 间隔时间计算公式： (Prescaler+1 ) X (Counter Period+1) X 1/ 定时器时钟频率，输入的是1khz。 如：1khz*32000*500/32M=500ms(32M是设置的时钟输出频率，如果不是这个，需要另外计算，原理一样) 四、配置 时钟（RCC）：时钟全部输出频率为32M（初步这样设置，还不了解具体的计时器是挂在那个APB下 GPIO：PF7/PF8全部设置为gpio_output，初始输出电频为low 定时器：Timers标签下，计时器参数在Parameter Settings下设置，同时为了使计时器能驱动LED，要启用计时器的NVIC功能，在NVIC Settings下设置开启 1. TIM2: * Clock source：internal clock * Prescaler：32000-1=31999 * Counter Mode:up * Counter Period:500-1=499 2. TIM3: * Clock source：internal clock * Prescaler：32000-1=31999 * Counter Mode:up * Counter Period:1000-1=999 五、调用流程 定时器的调用流程同外部冲断类似，同时通过调用回调函数实现处理功能。 main.c-->tim.c-->stm32f4xx_it.c-->stm32f4xx_hal_tim.c-->main.c 六、代码 tim.c 负责定义计时器，及TIM的初始化，配置定时器的参数。这里定义和初始化的计时器，在main.c中进行调用。 tim.c文件在项目的src目录下 定义计时器（这里定义两个计时器） TIM_HandleTypeDef htim2; TIM_HandleTypeDef htim3; 定时器初始化（这个代码是TIM2的初始化代码） void MX_TIM2_Init(void) { /* USER CODE BEGIN TIM2_Init 0 */ /* USER CODE END TIM2_Init 0 */ TIM_ClockConfigTypeDef sClockSourceConfig = {0}; TIM_MasterConfigTypeDef sMasterConfig = {0}; /* USER CODE BEGIN TIM2_Init 1 */ /* USER CODE END TIM2_Init 1 */ htim2.Instance = TIM2; htim2.Init.Prescaler = 31999; htim2.Init.CounterMode = TIM_COUNTERMODE_UP; htim2.Init.Period = 499; htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; if (HAL_TIM_Base_Init(&htim2) != HAL_OK) { Error_Handler(); } sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL; if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK) { Error_Handler(); } sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK) { Error_Handler(); } /* USER CODE BEGIN TIM2_Init 2 */ /* USER CODE END TIM2_Init 2 */ } stm32f4xx_it.c stm32f4xx_it.c文件在项目src目录下 这里的功能是计时器调用外部中断 引入在tim.c定义的定时器变量 extern TIM_HandleTypeDef htim2; extern TIM_HandleTypeDef htim3; 生成定时器的中断调用函数，此函数调用定时器中断处理函数（这里是TIM2定时器） void TIM2_IRQHandler(void) { /* USER CODE BEGIN TIM2_IRQn 0 */ /* USER CODE END TIM2_IRQn 0 */ HAL_TIM_IRQHandler(&htim2); /* USER CODE BEGIN TIM2_IRQn 1 */ /* USER CODE END TIM2_IRQn 1 */ } stm32f4xx_hal_tim.c stm32f4xx_hal_tim.c文件在driver的src目录下 在此文件中找到上面调用的函数void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim) 在HAL_TIM_IRQHandler函数中找到时间间隔回调函数HAL_TIM_PeriodElapsedCallback 找到HAL_TIM_PeriodElapsedCallback的函数原型，这是一个虚函数，我们需要实现的功能，需要在main.c文件中，重载这个函数 __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { /* Prevent unused argument(s) compilation warning */ UNUSED(htim); /* NOTE : This function should not be modified, when the callback is needed, the HAL_TIM_PeriodElapsedCallback could be implemented in the user file */ } main.c 在main文件中，重写这个函数，实现我们要用的功能，这里是TIM定时器反转LED的电平。 重写HAL_TIM_PeriodElapsedCallback函数，实现反转LED的电平 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if(htim->Instance==TIM2) { HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_7); } if(htim->Instance==TIM3) { HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_8); } } 启动定时器 在mian.c文件的main方法中，系统各项功能初始化完毕后，通过定时器启动函数启动定时器。 启动函数传入的定时器的指针，变量需要用到&符号 HAL_TIM_Base_Start_IT(&htim2); HAL_TIM_Base_Start_IT(&htim3); 七、其他 此例程是按照教程的，全部输出时钟设置的32M，暂时没有使用其他时钟频率 STM32CubeIDE功能非常强大，配置后会自动生成代码，只需要在main.c文件的中重写定时器回调函数和启用定时器即可 八、补充（定时器间隔时间的计算） 前面的定时器配置完全是按照教程来的，把系统时钟频率全部设置为32M，但是，STM32F407开发板的芯片时钟最高频率是168M，而且实际应用中，也不可能把系统所有输出的时钟频率设置为32M，重新研究时钟配置和定时器间隔时间的计算。 系统时钟设置为168M，如：sysclk，hclk的时钟全部配置为168M，其他各输出时钟由图形化工具自动计算； apb1的预分频系数配置为/4,apb2的预分频系数配置为/2 前文中已经提到TIM2-TIM5定时器是挂在apb1下的，因此需要根据apb1的预分频系数来计算输出的时钟 查看时钟树或者查看IDE的时钟图形化配置，可以知道apb1外设时钟是42M（168/4=42），apb1的定时器时钟是84M（168/4*2=84M）； 抄录一段文字 当 APB1 的时钟分频数为 1 的时候，TIM2~7 以及 TIM12~14 的时钟为 APB1 的时钟，而如果 APB1 的时钟分频数不为 1，那么 TIM2~7 以及 TIM12~14 的时钟频率将为 APB1时钟的两倍。 根据第4、5点，可以知道TIM2,TIM3的时钟频率是84M，这个时钟频率是我们计算间隔定时器频率 定时器间隔0.5秒（500ms）计算：1khz*(4999+1)*(8399+1)/84Mhz=500ms 定时器间隔1秒（1000ms）计算：1khz*(9999+1)*(8399+1)/84Mhz=1000ms 在实际应用中，可以按照以上方法根据系统配置的时钟，计算定时器的间隔时间 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-07-24 09:27:17 "},"stm32/stm32f407_usart.html":{"url":"stm32/stm32f407_usart.html","title":"stm32F407串口接收/发送","keywords":"","body":"stm32F407串口通信Sample 一、任务目标 二、硬件 三、工具 四、配置 五、运行流程 main.c stm32f4xx_hal_uart.c main.c 六、其他 七、函数说明 发送函数 接收函数 stm32的串口，是很方便实验连接电脑的方式之一，大部分开发板都是串口通过ch340转接至电脑usb接口。 一、任务目标 通过串口向电脑发送消息，并控制led7的开关； 电脑通过串口向开发板发送消息，并控制led8的开关 二、硬件 LED7PF7：发送消息时闪烁 LED8PF8：接收到消息时闪烁 USART1_TXPA9：USART1的发送引脚，与PA9复用 USART1_RXPA10：USART1的接收引脚，与PA10服用 USART1串口在我这个开发板上，是通过ch340转换为usb连接电脑上的 RST按键用于复位，否则开发板上电即发送消息，串口无法调试 三、工具 flymcu：烧录工具 comtransmit：串口调试工具，用于接收和发送数据 四、配置 sys，rcc同之前的默认设置； GPIO：两个LED等连接PF7/8，通用输出配置，无需其他设置 USART1:在Connectivity标签下的USART1接口配置 模式(mode)：设置为异步模式(Asynchronous) Parameter settings：波特率(baud rate):9600；字节长度(word length)8位；无校验位(parity)；停止位(stop bits)为1；通信方向(data direction)为双向； NVIC settings：启用USART1的全局中断功能 GPIO settings：GPIO MODE：PA9/10均设置为端口复用(Alternate function)，注意，这里和开发板的教程不同，无需设置上拉/下拉模式，使用推挽模式即可。 五、运行流程 同之前的中断程序运行流程类似，通过调用回调函数实现功能（非阻塞模式） main.c-->stm32f4xx_hal_uart.c-->main.c main.c 发送消息（阻塞式） 这里先演示阻塞式发送消息，操作非常简单，只需要调用HAL_UART_Transmit函数即可。 led7_on(); HAL_UART_Transmit(&huart1, tx_led_open, sizeof(tx_led_open), 10000); led7_off(); 接收消息（非阻塞式，接收基本非阻塞式的） 在main.c中调用HAL_UART_Receive_IT函数。 //usart1接收到数据后，将数据存放在rx_data中 HAL_UART_Receive_IT(&huart1, &rx_data, 1); stm32f4xx_hal_uart.c USART的发送、接收函数均在此文件中，如上面main.c文件中调用的发送和接收消息函数 此文件在driver目录的src下 几乎所有的usart的执行都在这个文件中，接收的函数运行流程执行如下： HAL_UART_Receive_IT-->UART_Start_Receive_IT-->UART_Receive_IT-->HAL_UART_RxCpltCallback HAL_UART_RxCpltCallback是接收消息的虚函数，HAL_UART_Receive_IT就是通过回调此函数实现消息接收后的操作。如：消息接收后，点亮LED8灯 剩下就是需要重写HAL_UART_RxCpltCallback函数即可 main.c 由于在main函数中调用HAL_UART_Receive_IT后，是通过重写回调函数HAL_UART_RxCpltCallback来实现的。 在回调函数中首先要判断接收的消息是否来自USART1端口 对接收到的信息进行分析，然后根据信息开关led8 仔细观察代码中，HAL_UART_Receive_IT函数在每次发送消息完毕之后，都会再调用一次，目的是为了一直在监听是否有接收到消息。 代码如下： void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { if(huart->Instance==USART1) { if(rx_data=='a') { led8_on(); led7_on(); HAL_UART_Transmit(&huart1, tx_led_open, sizeof(tx_led_open), 10000); led7_off(); HAL_UART_Receive_IT(&huart1, &rx_data, 1); } else if(rx_data=='b') { led8_off(); led7_on(); HAL_UART_Transmit(&huart1, tx_led_close, sizeof(tx_led_close), 10000); led7_off(); HAL_UART_Receive_IT(&huart1, &rx_data, 1); } } } 六、其他 其实这个例程非常简单，无非是配置USART端口，然后重写回调函数，实现功能； 这里有一个排查了很久的问题：if(rx_data=='a')，这个语句弄了很久，目前我的单片机上，必须比较字符，无法直接比较0x这种形式的16进制（功力不够，没找到原因） 注意调试工具的参数要和usart配置参数一直，另外就是调试工具和程序下载工具不能同时使用，当调试工具端口打开后，程序下载工具是无法下载程序的。 七、函数说明 发送函数 阻塞式发送函数HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size, uint32_t Timeout) 参数1：huart，串口实例的指针。 参数2：*pData，待发送数据缓冲区的指针。 参数3：Size，待发送数据的字节数。 参数4：Timeout，超时时间值。 非阻塞式发送函数HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart,uint8_t *pData, uint16_t Size); 参数1：huart，串口实例的指针。 参数2：*pData，待发送数据缓冲区的指针。 参数3：Size，待发送数据的字节数。 非阻塞式发送完毕中断回调函数//发送完毕后回调中断函数 void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart); //发送一半回调 void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart) 接收函数 非阻塞式接收函数（推荐使用） HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size); 参数1：huart，串口实例的指针。 参数2：*pData，数据接收据缓冲区的指针。 参数3：Size，待接收数据的字节数。 接收完毕中断回调函数 //发送完毕回调中断函数 void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart); //接收一半回调中断函数 void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart); 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-07-25 17:48:55 "},"stm32/stm32f407_adc.html":{"url":"stm32/stm32f407_adc.html","title":"stm32F407接收ADC数据","keywords":"","body":"stm32F407的ADC stm32连接各种外设的传感器，如：红外测距、温度、气压等传感器，都是通过ADC接口连接的。 一、任务 测量按键（WAKE_UP)的按下和放开的电压 测量外接的红外测距仪感应的距离和电压 两个LED灯分别用于显示测量过程中 二、硬件 LED：指示灯 LED7PF7 LED8PF8 红外测距仪 OUT引脚PF6（此引脚设置为ADC3的IN4） GNDGND（开发板上任意一个） VCC3.3V（开发板上任意一个） 轻触开关 WAKE_UPPA0(此引脚设置为ADC1的IN0) 三、配置 SYS、RCC、USART等配置同之前的配置； ADC配置：Analog标签下 ADC1：ADC1-->IN0-->Parameter Setting(默认)-->NVIC Setting(启用中断)-->GPIO setting(系统默认引出为PA0引脚) ADC3：GPIO-->PF6-->鼠标点击-->ADC3_IN4-->其他设置同ADC1即可 在GPIO标签和Analog标签下，都可以启用ADC功能，一个根据ADC的通道进行配置（ADC的通道已经绑定了引脚对应的引脚号），一个是根据GPIO的引脚号进行配置，方式都是一样的。 ADC的中断功能一定要开启 四、程序流程 同中断、USART、TIM等功能开发，ADC的开发也涉及到中断，因此也是通过调用回调函数实现功能。 main.c-->stm32f4xx_hal_adc.c-->main.c main.c（启动ADC） main.c文件中，通过调用ADC中断启动函数，开启ADC功能。 非阻塞式启动ADC（中断，推荐） HAL_ADC_Start_IT(&hadc3); 阻塞式启动ADC： HAL_ADC_Start(&hadc1); main.c（实现回调函数或数据接收） 非阻塞式（重写回调函数） HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)是一个虚函数，在stm32f4xx_hal_adc.c文件中 同TIM\\USART等，回调函数只有一个，因此，第一步是需要判断传入结构体是哪个ADC接口 下面代码中ADC1用于检测按键电压，ADC3用于检测红外测距仪电压 HAL_ADC_GetValue函数用户获取ADC的值，单位是毫伏 注意电压的换算方式：ADC是12位，因此最大值4096（2的12次方） void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) { if(hadc->Instance==ADC1) { ADC_Value=HAL_ADC_GetValue(&hadc1); ADC_Volt=ADC_Value*3.3*1000/4096; send_USART_Data(); led7_off(); } if(hadc->Instance==ADC3) { ADC_Value=HAL_ADC_GetValue(&hadc3); ADC_Volt=ADC_Value*3.3*1000/4096; send_USART_Data(); led8_off(); } } 阻塞式调用 阻塞式调用分为两个步骤：启动对应的ADC，然后进行判断ADC是否执行成功，执行成功后就活区ADC的值。 HAL_ADC_Start(&hadc1);启动ADC1 (HAL_ADC_PollForConversion(&hadc1, 10)==HAL_OK)判断ADC1是在规定超时时间内否执行成功 HAL_ADC_GetValue(&hadc1);获取ADC1的值 void get_ADC_Value() { HAL_ADC_Start(&hadc1); led7_on(); if(HAL_ADC_PollForConversion(&hadc1, 10)==HAL_OK) { ADC_Value=HAL_ADC_GetValue(&hadc1); ADC_Volt=ADC_Value*3.3*1000/4096; } send_USART_Data(); led7_off(); HAL_ADC_Stop(&hadc1); } 五、其他 推荐使用非阻塞模式，更加优雅而且效果更好； 开发板自带的adc转换器式12位长度，这也是转换精度 几个常用ADC的函数： 启动函数： //查询，阻塞方式，启动ADC HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc); //查询，阻塞方式，停止ADC HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc); //中断，非阻塞方式，启动ADC HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc); //中断，非阻塞方式，停止ADC HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc); 读取ADC数据函数 ~~~C uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc); 参数1：hadc，ADC实例指针。 返回值：uint32_t，ADC转换结果。 ~~~ 查询方式，阻塞式A/D转换HAL库函数 HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout); 参数1：hadc，ADC实例指针。 参数2：Timeout，超时时间。 返回值：HAL_StatusTypeDef，函数执行状态。 中断方式，非阻塞式回调 void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) ADC的几个概念 * 量程：指ADC所能输入模拟信号的类型和电压范围，即参考电压。信号类型包括单极性和双极性。 * 转换位数：量化过程中的量化位数n。 A/D转换后的输出结果用n位二进制数来表示。 【例】：10位ADC的输出值就是0～1023。 * 分辨率：ADC能够分辨的模拟信号最小变化量。计算公式是，分辨率 = 量程 / 2的n次方 【例】：量程为单极性0-5V，8位ADC的分辨率是，5 / 256 = 0.0195V * 转换时间：ADC完成一次完整的A/D转换所需要的时间，包括采样、保持、量化、编码的全过程。 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-07-27 10:45:31 "},"stm32/stm32f407_pwm.html":{"url":"stm32/stm32f407_pwm.html","title":"stm32F407下PWM实现呼吸灯","keywords":"","body":"stm32F407之PWM实现呼吸灯效果 PWM：脉冲宽度调制，可以理解为，PWM波形，是通过调整其频率和占空比来达到我们需要的波形或是等效电压，通过占空比替代波形曲线。 概念 频率：整个PWM波的频率，即时钟频率 占空比：脉冲的有效电平占整个周期的百分比 任务 两个LED灯，实现呼吸灯效果 定时器频率为1000HZ 时钟预分频：83 计数器：999 定时器频率计算为：84000000/84/1000=1000HZ 硬件 LED2PA1TIM2.Channel2通道 LED3PA2TIM2.Channel3通道 不同GPIO会连接不同的TIM的不同Channel，配置GPIO和TIM是要注意 配置 SYS,RCC与前面的配置相同，需要注意的是，TIM默认的输出时钟是84M GPIO：引脚可以先设置，然后在TIM标签下设置定时器的参数 LED2连接PA1引脚，引脚设置位TIM2_CH2 LED3连接PA2引脚，引脚设置位TIM2_CH3 TIM： Clock Source：interal clock channel2\\3：PWM Generation CH2/3（打开两个通道的PWM功能） 预分频和计数器按照上面配置，分别为83和999； PWM Channel配置：Mode：PWM mode1；pulse（暂不配置，后面在代码里动态配置）；CH Polarity：low 启用NVIC使能 实现 通过动态调整pulse的值，动态实现不同的占空比，在不同占空比下，TIM实现了不同的输出电压，LED灯在不同电压下，亮度动态变化，从而实现呼吸灯的功能。 main.c 前面介绍了TIM定时器的函数调用流程，这里就不再介绍调用方式。另外定时器动态调整输出的电压到GPIO引脚，也无需实现TIM的中断回调函数。 启用定时器的PWM功能 HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_2); HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_3); 动态调账PWM的占空比 uint16_t dutycycle=0; /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ while(dutycycleCCR2 = dutycycle; // __HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_3,dutycycle); TIM2->CCR3 = dutycycle; HAL_Delay(1); } while(dutycycle) { dutycycle--; __HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_2,dutycycle); __HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_3,dutycycle); HAL_Delay(1); } HAL_Delay(100); } /* USER CODE END 3 */ } __HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_2,dutycycle);设置PWM的占空比： 第一参数都是定时器 第二参数为通道 第三参数为占空比的计数值 补充说明： PWM的MODE：PWM mode 1和PWM mode 2互补 PWM Mode 1：当定时器计数为向上计数，则计数小于占空比的部分为有效电 PWM Mode 2：当定时器计数为向上计数，则计数大于占空比的部分为有效电平 Pulse（脉冲宽度）：占空比 占空比=（Pulse/自动重载值）*100% 自动重载值为定时器的：Counter Period值 上面设置的计数器是1000，通过动态调整pulse值，即动态调整占空比 看main.c中while中的代码，dutycycle就是动态设置，而且dutycycle不要超过这个数，否则LED灯演示的效果会很奇怪 CH Polarity（频道有效电平【High/Low】） 通道的高低电平根据所驱动的外设进行设置，如LED是高电平驱动，设置为HIGH，则LED灯由暗变亮 __HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_2,dutycycle)与TIM2->CCR2 = dutycycle具有同样的效果，只是一种是使用HAL库函数，一种是操作寄存器。 在PWM Mode 1模式下，当计数器使用up（向上）时，CNT 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-07-30 17:30:14 "},"stm32/stm32f407_spi.html":{"url":"stm32/stm32f407_spi.html","title":"stm32F407下SPI读写Flash","keywords":"","body":"stm32F407下SPI读写Flash 实在是太菜了，调试了很久才搞定，记录一下！ 菜鸡一个，思维有点混乱，写的不是很好，尽量理清思路 一、任务 生成测试256个测试数据（0x00-0x100），0x100=0xFF 将测试数据写入Flash 读取Flash数据，并与写入的数据进行测试比较 读取的数据通过USART串口发送至电脑 二、硬件 Flash：W25Q128，128Mbit的flash，相当于16M字节； Flash已经集成在开发板上，无需额外购买 集成的Flash是连接在SPI1引脚上的，设置其他引脚没有用，如果是自己外接的Flash则自己连接引脚 三、配置 SYS,RCC跟之前一样配置，注意时钟频率，W25Q128，最高支持80M速度，我配置的时钟频率是84M，因此后面的配置，需要进行分频（SPI时钟是挂在APB1上的） GPIO：所有接口都要开启复用功能 CSPB14：片选引脚（output模式） MISOPB4：主设备输入，从设备输出 MOSIPB5：主设备输出，从设备输入 SCKPB3：时钟引脚 SPI配置：启用SPI1接口 Mode：Full-duplex master（全双工，主设备，stm32向flash中读写数据，因此是主设备） NSS：disable Parameter Setting:重点是相位和极性配置 Basic Parameter：保持默认（主要注意data size=8；first bit=MSB) Clock Parameter：输出时钟为84M，可将预分频设置为8，速率即为10.5；clock polarity：High；clock phase：2edge Advance parameter：保持默认，即不开启CRC校验和启用软件控制片选信号 NVIC：启用 W25Q128驱动，我用的是微雪已经写好的驱动，稍微改一下即可。 四、代码 导入驱动 将W25Q128的驱动下载至本地并解压，可以解压至项目的源文件src目录下，然后将驱动的目录导入到项目的include中 在驱动的头文件中定义片选引脚，系统集成的W25Q128的片选引脚是PB14，这是必备步骤 这里操作的使W25Q128的头文件W25QXX.h//GPIO片选引脚，需要在这里定义 #define SPI1_CS_GPIO_Port GPIOB #define SPI1_CS_Pin GPIO_PIN_14 main.c 导入驱动其他的头文件，除了驱动的头文件，自定的函数还会需要用到其他的几个函数，因此需要导入其他两个个头文件 /* USER CODE BEGIN Includes */ #include \"W25QXX.h\" #include \"stdio.h\" #include \"string.h\" /* USER CODE END Includes */ 定义几个会要用到的变量 /* USER CODE BEGIN PV */ uint8_t wData[0x100]; uint8_t rData[0x100]; uint32_t i; uint8_t ID[2]; uint8_t msg_buff[64]; uint8_t tmp_buff[64]; /* USER CODE END PV */ 实现读写操作，具体看代码注释 /* USER CODE BEGIN 2 */ //启动后发送一段欢迎消息 transmitStr(\"0.Welcome bytetoy.cn,W25Q128 SPI Sample\\r\\n\\r\\n\"); HAL_Delay(500); /* 1.W25Q128初始化，并获取W25Q128的设备ID*/ BSP_W25Qx_Init(); BSP_W25Qx_Read_ID(ID); sprintf((char*) msg_buff, \"1.W25Q128(bytetoy) ID is : 0x%02X 0x%02X \\r\\n\\r\\n\", ID[0], ID[1]); HAL_UART_Transmit(&huart1, msg_buff, sizeof(msg_buff), 1000); HAL_Delay(500); //2. 擦除block数据 if (BSP_W25Qx_Erase_Block(0) == W25Qx_OK) { transmitStr(\"2.SPI Erase Block ok\\r\\n\"); } else Error_Handler(); HAL_Delay(500); /* 3.生成写入数据，通过for循环生成测试数据*/ /* fill buffer */ for (i = 0; i 自定义的包装发送函数：用于通过USART串口发送数据 /* USER CODE BEGIN 4 */ //自定义向串口发送输出数据 //用途是将发送的消息字符串，通过USART串口发送至电脑，目的是将HAL库函数缩短一些 //注意一点数组需要重置为空 void transmitStr(char *p) { memset(tmp_buff,0,64); sprintf((char *)tmp_buff,p); HAL_UART_Transmit(&huart1, tmp_buff, sizeof(tmp_buff), 1000); } /* USER CODE END 4 */ 数据读写成功后，通过USART串口发送至电脑，内容如下： 0.Welcome bytetoy.cn,W25Q128 SPI Sample 1.W25Q128(bytetoy) ID is : 0x52 0x17 2.SPI Erase Block ok 3.SPI write flash ok 4.1.SPI Read ok 4.2.SPI Read Data : 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C 0x0D 0x0E 0x0F 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1A 0x1B 0x1C 0x1D 0x1E 0x1F 0x20 0x21 0x22 0x23 0x24 0x25 0x26 0x27 0x28 0x29 0x2A 0x2B 0x2C 0x2D 0x2E 0x2F 0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x3A 0x3B 0x3C 0x3D 0x3E 0x3F 0x40 0x41 0x42 0x43 0x44 0x45 0x46 0x47 0x48 0x49 0x4A 0x4B 0x4C 0x4D 0x4E 0x4F 0x50 0x51 0x52 0x53 0x54 0x55 0x56 0x57 0x58 0x59 0x5A 0x5B 0x5C 0x5D 0x5E 0x5F 0x60 0x61 0x62 0x63 0x64 0x65 0x66 0x67 0x68 0x69 0x6A 0x6B 0x6C 0x6D 0x6E 0x6F 0x70 0x71 0x72 0x73 0x74 0x75 0x76 0x77 0x78 0x79 0x7A 0x7B 0x7C 0x7D 0x7E 0x7F 0x80 0x81 0x82 0x83 0x84 0x85 0x86 0x87 0x88 0x89 0x8A 0x8B 0x8C 0x8D 0x8E 0x8F 0x90 0x91 0x92 0x93 0x94 0x95 0x96 0x97 0x98 0x99 0x9A 0x9B 0x9C 0x9D 0x9E 0x9F 0xA0 0xA1 0xA2 0xA3 0xA4 0xA5 0xA6 0xA7 0xA8 0xA9 0xAA 0xAB 0xAC 0xAD 0xAE 0xAF 0xB0 0xB1 0xB2 0xB3 0xB4 0xB5 0xB6 0xB7 0xB8 0xB9 0xBA 0xBB 0xBC 0xBD 0xBE 0xBF 0xC0 0xC1 0xC2 0xC3 0xC4 0xC5 0xC6 0xC7 0xC8 0xC9 0xCA 0xCB 0xCC 0xCD 0xCE 0xCF 0xD0 0xD1 0xD2 0xD3 0xD4 0xD5 0xD6 0xD7 0xD8 0xD9 0xDA 0xDB 0xDC 0xDD 0xDE 0xDF 0xE0 0xE1 0xE2 0xE3 0xE4 0xE5 0xE6 0xE7 0xE8 0xE9 0xEA 0xEB 0xEC 0xED 0xEE 0xEF 0xF0 0xF1 0xF2 0xF3 0xF4 0xF5 0xF6 0xF7 0xF8 0xF9 0xFA 0xFB 0xFC 0xFD 0xFE 0xFF 4.3.all data output 5.input and ouput data SPI Test OK 五、SPI相关概念 记录一下，用于理解和记忆 SPI引脚 SPI（Serial Peripheral Interface）,串行外围设备接口,一种高速的，全双工，同步的通信总线。芯片的管脚上只占用四根线。 MISO：主器件数据输入，从器件数据输出。 MOSI：主器件数据输出，从器件数据输入。 SCK： 时钟信号，由主设备控制发出。 NSS（CS）： 从设备选择信号，由主设备控制。当NSS为低电平则选中从器件。 IDE配置内容 CPOL（时钟极性）：定义时钟空闲状态电平 CPOL=0为时钟空闲时为低电平, CPOL=1为时钟空闲时为高电平 CPHA（时钟相位）：定义数据的采集时间 CPHA=0:在时钟的第一个跳变沿（上升沿或下降沿）进行数据采样。CPHA=1:在时钟的第二个跳变沿（上升沿或下降沿）进行数据采样 CPHA=0，相当于设置里clock phase：1edge，CPHA=1，相当于设置里clock phase：2edge W25Q128指令 W25Q128是串行Flash，掉电不丢失数据，可用于存储数据。 128M（bit）大小分为256个block（块），即每个block是64k 每个block（64k）又分为16个sector（扇区），每个sector为4k W25Q128指令由32位组成，分为两个部分：指令和地址。前8位（0-7）是指令，后24位（8-31）是地址。 FLASH写数据前必须擦除存储器，而擦除是以扇区或块作为操作单位的 0x90：读制造商/设备ID 0x03H：读数据 0x02H：页编程，即写入数据 0x20H：扇区擦除 分析一个W25Q128驱动函数：BSP_W25Qx_Read，数据读取函数 uint8_t cmd[4]：定义一个指令，由32位组成，即4个字节 在指令中，从高位到低位，分别写入8位的指令和24位的地址 W25Qx_Enable()：使能SPI设备，通过片选CS引脚给低电平实现。 HAL_SPI_Transmit(&hspi1, cmd, 4, W25Qx_TIMEOUT_VALUE)：stm32通过SPI向W25Q128发送指令，cmd是上面的定义的指令 HAL_SPI_Receive(&hspi1, pData,Size,W25Qx_TIMEOUT_VALUE)：stm32通过SPI读取数据。 W25Qx_Disable()：使SPI设备失能 uint8_t BSP_W25Qx_Read(uint8_t* pData, uint32_t ReadAddr, uint32_t Size) { uint8_t cmd[4]; /* Configure the command */ cmd[0] = READ_CMD; cmd[1] = (uint8_t)(ReadAddr >> 16); cmd[2] = (uint8_t)(ReadAddr >> 8); cmd[3] = (uint8_t)(ReadAddr); W25Qx_Enable(); /* Send the read ID command */ HAL_SPI_Transmit(&hspi1, cmd, 4, W25Qx_TIMEOUT_VALUE); /* Reception of the data */ if (HAL_SPI_Receive(&hspi1, pData,Size,W25Qx_TIMEOUT_VALUE) != HAL_OK) { return W25Qx_ERROR; } W25Qx_Disable(); return W25Qx_OK; } 六、其他 例程的演示，默认first bit=MSB，从高位读取数据，驱动和驱动函数的解析都是以高位读取数据； SPI1的引脚设置，可先设置GPIO，然后设置SPI；先设置了SPI后，SPI的菜单里使看不到GPIO接口的。 片选引脚(CS)的设置，在GPIO里，例程里选的PB14，设置的时候，IDE有点慢，要等一下才会出现output选项，不能选择为SPI2_MISO，否则无法使能SPI1。这里排查了很长时间，就是因为CS连接的PB14模式设置错误。 CPOL和CPHA貌似无论何种设置都可以，不影响读取SPI，可能跟外设不同 SPI其实没有读取、写入数据的说法，SPI其实是一个环形的移位过程。如：MOSI，将主设备数据从寄存器中移动到从设备的寄存器，同时从设备的寄存器内容会移动到主设备的寄存器，这就是一个写数据的过程。他的实质使两个设备交换数据。 片选（CS）的含义和作用是使SPI设备使能和失能，器件先拉低从器件的片选信号线NSS，选中要传输的从器件。这就意味同一个SPI接口可以连接多个SPI外设，通过CS接口选择不同的外设。 SPI的每次操作，如读数据、写数据、擦除，都要通过CS使外设使能和失能 通过USART读取数据时，每次都要重置数组，否则有可能带上了上一次的内容，这个问题排查了很久。我这里使通过一个函数transitStr实现的串口发送数据。 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-08-01 14:22:40 "},"stm32/stm32f407_printf_to_usart.html":{"url":"stm32/stm32f407_printf_to_usart.html","title":"stm32F407下printf重定向到串口","keywords":"","body":"stm32F407下printf重定向到串口 前面学会了使用通过串口发送和接收数据.。 本例程使用stm32的官方推荐HAL库和STM32CubeIDE作为开发工具 在没有J-link等调试器的情况下，可以通过串口打印日志实现简单的调试功能，想必大家在平时练习的时候，经常会使用printf来打印日志。但是每次通过usart函数通过串口发送数据，实在是太麻烦。因此将printf输出重定向至串口，即可在电脑上通过串口接收工具了解打印信息。 硬件 本例程启用uart1串口，根据开发板，uart1是复用了PA9和PA10两个引脚 同时加了两个LED灯作为指示灯 LED7PF7：作为指示灯，开发板上电后常亮 LED8PF8：发送消息时闪烁 USART1_TXPA9：USART1的发送引脚，与PA9复用 USART1_RXPA10：USART1的接收引脚，与PA10服用 原理 如何实现，网上的例程很多，我也是抄网上的方法^_^ 大概思路是通过宏定义，将输出函数用一个HAL库的HAL_UART_Transmit函数替代，原理代码如下： #ifdef __GNUC__ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif PUTCHAR_PROTOTYPE { //这里使用uart1串口 HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xffff); return ch; } 实现 本例程目标简单，实现代码全部在main.c文件中 导入stdio.h /* Private includes ----------------------------------------------------------*/ /* USER CODE BEGIN Includes */ #include \"stdio.h\" /* USER CODE END Includes */ 重定向printf /* USER CODE BEGIN PFP */ #ifdef __GNUC__ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif PUTCHAR_PROTOTYPE { //使用uart1端口 HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xffff); return ch; } /* USER CODE END PFP */ 使用printf /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ led8_switch(); printf(\"tx=%s\\r\\n\",tx_array); printf(\"output float k=%.1f\\r\\n\",k); HAL_Delay(200); // HAL_UART_Transmit(&huart1, tx_array, sizeof(tx_array), 10000); } /* USER CODE END 3 */ 输出结果为 注：这里float输出有问题，解决方法见下面 tx=bytetoy,goodluck! output float k= tx=bytetoy,goodluck! output float k= tx=bytetoy,goodluck! output float k= 完整代码 /* USER CODE BEGIN Header */ /** ****************************************************************************** * @file : main.c * @brief : Main program body ****************************************************************************** * @attention * * Copyright (c) 2022 STMicroelectronics. * All rights reserved. * * This software is licensed under terms that can be found in the LICENSE file * in the root directory of this software component. * If no LICENSE file comes with this software, it is provided AS-IS. * ****************************************************************************** */ /* USER CODE END Header */ /* Includes ------------------------------------------------------------------*/ #include \"main.h\" #include \"usart.h\" #include \"gpio.h\" /* Private includes ----------------------------------------------------------*/ /* USER CODE BEGIN Includes */ #include \"stdio.h\" /* USER CODE END Includes */ /* Private typedef -----------------------------------------------------------*/ /* USER CODE BEGIN PTD */ /* USER CODE END PTD */ /* Private define ------------------------------------------------------------*/ /* USER CODE BEGIN PD */ /* USER CODE END PD */ /* Private macro -------------------------------------------------------------*/ /* USER CODE BEGIN PM */ /* USER CODE END PM */ /* Private variables ---------------------------------------------------------*/ /* USER CODE BEGIN PV */ /* USER CODE END PV */ /* Private function prototypes -----------------------------------------------*/ void SystemClock_Config(void); /* USER CODE BEGIN PFP */ #ifdef __GNUC__ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) #else #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f) #endif PUTCHAR_PROTOTYPE { //具体哪个串口可以更改huart1为其它串�???? HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xffff); return ch; } /* USER CODE END PFP */ /* Private user code ---------------------------------------------------------*/ /* USER CODE BEGIN 0 */ #define led7_on() HAL_GPIO_WritePin(GPIOF, GPIO_PIN_7, GPIO_PIN_SET) #define led7_off() HAL_GPIO_WritePin(GPIOF, GPIO_PIN_7, GPIO_PIN_RESET) #define led7_switch() HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_7) #define led8_on() HAL_GPIO_WritePin(GPIOF, GPIO_PIN_8, GPIO_PIN_SET) #define led8_off() HAL_GPIO_WritePin(GPIOF, GPIO_PIN_8, GPIO_PIN_RESET) #define led8_switch() HAL_GPIO_TogglePin(GPIOF, GPIO_PIN_8) uint8_t tx=1; uint8_t tx_array[]=\"bytetoy,goodluck!\"; float k=1.2; /* USER CODE END 0 */ /** * @brief The application entry point. * @retval int */ int main(void) { /* USER CODE BEGIN 1 */ led7_on(); led8_on(); /* USER CODE END 1 */ /* MCU Configuration--------------------------------------------------------*/ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* USER CODE BEGIN Init */ /* USER CODE END Init */ /* Configure the system clock */ SystemClock_Config(); /* USER CODE BEGIN SysInit */ /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); MX_USART1_UART_Init(); /* USER CODE BEGIN 2 */ /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ led8_switch(); printf(\"tx=%s\\r\\n\",tx_array); printf(\"output float k=%.1f\\r\\n\",k); HAL_Delay(200); // HAL_UART_Transmit(&huart1, tx_array, sizeof(tx_array), 10000); } /* USER CODE END 3 */ } /** * @brief System Clock Configuration * @retval None */ void SystemClock_Config(void) { RCC_OscInitTypeDef RCC_OscInitStruct = {0}; RCC_ClkInitTypeDef RCC_ClkInitStruct = {0}; /** Configure the main internal regulator output voltage */ __HAL_RCC_PWR_CLK_ENABLE(); __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1); /** Initializes the RCC Oscillators according to the specified parameters * in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 4; RCC_OscInitStruct.PLL.PLLN = 168; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 4; if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) { Error_Handler(); } } /* USER CODE BEGIN 4 */ /* USER CODE END 4 */ /** * @brief This function is executed in case of error occurrence. * @retval None */ void Error_Handler(void) { /* USER CODE BEGIN Error_Handler_Debug */ /* User can add his own implementation to report the HAL error return state */ __disable_irq(); while (1) { } /* USER CODE END Error_Handler_Debug */ } #ifdef USE_FULL_ASSERT /** * @brief Reports the name of the source file and the source line number * where the assert_param error has occurred. * @param file: pointer to the source file name * @param line: assert_param error line source number * @retval None */ void assert_failed(uint8_t *file, uint32_t line) { /* USER CODE BEGIN 6 */ /* User can add his own implementation to report the file name and line number, ex: printf(\"Wrong parameters value: file %s on line %d\\r\\n\", file, line) */ /* USER CODE END 6 */ } #endif /* USE_FULL_ASSERT */ 碰到的问题 无法输出浮点数(float) 我用的开发环境是STM32CubeIDE，需要对项目进行一个配置 project->properties->C/C++Build->Settings->Tool Settings->MCU Settings->Use float with printf from newlib-nano(勾选此选项) 配置后输出内容正常 tx=bytetoy,goodluck! output float k=1.2 tx=bytetoy,goodluck! output float k=1.2 tx=bytetoy,goodluck! output float k=1.2 tx=bytetoy,goodluck! output float k=1.2 输出内容乱码 输出内容在串口调试工具上显示乱码，原因很多，我碰到的主要两个原因 修改波特率 将代码波特率和串口调试工具的波特率均调为9600，波特率太高了，貌似有点问题，有可能是我的数据线质量太差； 重定向的代码 关键代码是一次发送一个字节，不能修改为其他数字 HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xffff); 重要提醒 重定向要在printf使用之前完成定义，因此强烈建议按照放在例程所在的位置。 注意时钟 有个把月没有继续学这个了，配置的时候犯了一个低级又致命的错误，就是外部时钟配置错了。开发板搭载的外部时钟是8M的晶振，因此配置的时候务必改为8（默认是25） 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-09-19 21:27:56 "},"stm32/stm32f407_dma.html":{"url":"stm32/stm32f407_dma.html","title":"stm32F407下DMA操作","keywords":"","body":"stm32F407下DMA STM32F4 最多有 2 个 DMA 控制器（DMA1 和 DMA2），共 16 个数据流（每个控制器 8 个），每一个 DMA 控制器都用于管理一个或多个外设的存储器访问请求。 每个数据流总共可以有多达 8个通道（或称请求）。每个数据流通道都有一个仲裁器，用于处理 DMA 请求间的优先级。 一、任务 使用DMA实现从内存至内存传输数据 使用DMA实现从内存至外设传输数据 二、几个概念 控制器：就是DMA1和DMA2，他们就是控制器 请求：每个控制器可以发送的 数据流：每个控制器 8 个 模式：Normal表单次传输，传输一次后终止传输，Circular表示循环传输，传输完成后又重新开始继续传输，不断循环永不停止 方向：3种，内存到内存，内存到外设，外设到内存 地址自增：串口发送数据是将数据不断存进串口的发送数据寄存器(USARTx_TDR)。所以外接的地址是不递增。而内存储器存储的是要发送的数据，所以地址指针要递增才能将所以的数据发送出去。 传输字宽：每次传输的数据长度，可以一个字节，两个字节(半字)，四个字节(字)，串口数据发送寄存器只能存储8bit,每次发送一个字节，所以数据长度选择Byte 三、配置 （一）usart串口配置 启用usart1串口，显示传输数据的内容 以下三项为基本配置，两种传输模式均使用此共同配置 PA10USART1.RX PA9USART1.TX RCC和sys配置与之前一致，无需特别调整 四、实现 （一）内存至内存传输数据 存储器到存储器需要外设接口可以访问存储器，而仅 DMA2 的外设接口可以访问存储器，所以仅 DMA2 控制器支持存储器到存储器的传输，DMA1 不支持 1.DMA配置 System Core->DMA->DMA2,新增（add）一个DMA DMA Request（请求）：MEMTOMEM(内存到内存) Stream（通道）：DMA2 Steam0-7均可，8个通道可用 Direction（方向）：Memory to Memory Mode（模式）：normal（正常模式），即单次传输，发送完即停止 Increment Address（指针自增模式）：src memory和dst memory，都选择自增（内存至内存传输数据，都选择自增） Data width：byte（以字节长度传输数据），串口数据发送寄存器只能存储8bit,每次发送一个字节，所以数据长度选择Byte 2.实现 定义两个int数组变量，用于存储源和目标数组，分别命名为：src_buf和des_buf /* * 定义两个数组，实现DMA从内存到内存进行传输数据 * src_buf：源数组，保存在内存中； * des_buf:目标数组，DMA将源数组拷贝至本数组，实现内�?-->内存复制功能 * */ const uint8_t src_buf[16]={ 1,2,3,4, 5,6,7,8, 9,10,11,12, 13,14,15,16 }; uint8_t des_buf[16]; 传输数据 使用HAL_DMA_Start函数，将源数据内容传输至目标数组，并使用printf通过串口将目标数组发送至串口调试工具 /* * 1. 内存到内存传输数据 * HAL_DMA_Start函数实现内存至内存数据传�? */ HAL_DMA_Start(&hdma_memtomem_dma2_stream0, (uint32_t)src_buf, (uint32_t)des_buf, 16); /* * 将源数组和目标数据，通过串口输出至串口调试工�? */ for(int i=0;i 显示结果如下src_buf[0]=1,des_buf[0]+1=1 src_buf[1]=2,des_buf[1]+1=3 src_buf[2]=3,des_buf[2]+1=4 src_buf[3]=4,des_buf[3]+1=5 src_buf[4]=5,des_buf[4]+1=6 src_buf[5]=6,des_buf[5]+1=7 src_buf[6]=7,des_buf[6]+1=8 src_buf[7]=8,des_buf[7]+1=9 src_buf[8]=9,des_buf[8]+1=10 src_buf[9]=10,des_buf[9]+1=11 src_buf[10]=11,des_buf[10]+1=12 src_buf[11]=12,des_buf[11]+1=13 src_buf[12]=13,des_buf[12]+1=14 src_buf[13]=14,des_buf[13]+1=15 src_buf[14]=15,des_buf[14]+1=16 src_buf[15]=16,des_buf[15]+1=17 （二）内存至外设传输数据 通过DMA将内存中的内容，发送至usart串口外设，这里的发送，不再使用printf函数，而是使用函数通过串口直接发送 1.DMA配置 Connectivity->usart1->DMA Settings，新增（add）一个DMA DMA Request（请求）：USART1_TX，使用usart1的发送端口 Stream（通道）：DMA2_stream7，这里只能选择7通道，可以查询DMA2控制器的8个通道功能表看不同接口可以使用的通道 Direction（方向）：memory to pheriperal（内存至外设） Mode：nomarl Increment Address（指针自增模式）：src选择自增，dst不选，从内存到外设，读取内存，地址在变化，而外设地址是不变的。 Data width：byte 2.实现 DMA从内存向外设(usart1)传输数据 定义一个字符串，用于存储向外发送的内容 const uint8_t txt_buf[]=\"welcome to bytetoy.cn!\\r\\n\"; 传输数据 使用HAL_UART_Transmit_DMA函数发送数据 /* * 2. DMA从内存向外设(usart1)传输数据 * 这里需要注意，HAL_UART_Transmit_DMA传输数据后，需要关闭端口，否则串口会一直busy，后面的无法使用串口传输数据 */ HAL_UART_Transmit_DMA(&huart1,(uint8_t *)txt_buf, sizeof(txt_buf)); 显示结果如下 welcome to bytetoy.cn! 五、注意事项 （一）HAL_DMA_Start函数 此函数的第二、三参数是源地址和目标内存地址，地址是32位长度，使用时需要强制转换 而HAL_UART_Transmit_DMA函数的源内存地址是8位长度 HAL_DMA_Start(&hdma_memtomem_dma2_stream0, (uint32_t)src_buf, (uint32_t)des_buf, 16); （二）HAL_UART_Transmit_DMA函数 此函数如果不开启串口中断，则程序只能发送一次数据,程序不能判断DMA传输是否完成，USART一直处于busy状态，此配置在usart1的NVIC Settings配置种，选择使能interupt 需要手动关闭DMA通道(HAL_UART_DMAStop)，串口方可进行后面的传输。 其次是，串口传输数据比较慢，使用此函数传输数据较长时，传输后，需要delay一段时间，否则数据无法传输完成。 HAL_UART_Transmit_DMA(&huart1,(uint8_t *)txt_buf, sizeof(txt_buf)); HAL_Delay(5000); HAL_UART_DMAStop(&huart1); for(int i=0;i 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-09-22 23:42:55 "},"stm32/stm32f407_iwdg.html":{"url":"stm32/stm32f407_iwdg.html","title":"stm32F407下IWDG","keywords":"","body":"stm32F407下IWDG 概念 STM32F4 的独立看门狗由内部专门的 32Khz 低速时钟（LSI）驱动 预分频器（prescaler）：设置看门狗时钟的分频系数，该寄存器是占用3位，即最大值位为256 重载计数器（reload value）：向下计数 配置 时钟配置 独立看门狗时钟挂在LSI时钟上，stm32F407的内部时钟是32khz，因此看门狗的时钟也是32khz，通过IDE的时钟图可以看到时钟配置和频率数因此这里无需设置 IWDG配置 配置一个周期为1秒的看门狗，计算方式为： 32000hz/(32*1000)=1hz，即周期为1秒，即为1秒为溢出时间 启用IWDG：System core-->IWDG-->Activated prescaler：32 reload：1000 实现 没有喂狗 由于看门狗设置的监听周期是1秒，在1秒周期内如果没有喂狗，看门狗将重置系统： 在while中，每隔300ms向串口输出一次信息，由于1秒看门狗将重置系统，理论上只能输出3次信息将重新打印 代码 while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ if(cnt==0) { printf(\"Sys reset\\r\\n\"); } printf(\"cnt=%d\\r\\n\",cnt); cnt++; HAL_Delay(300); } 输出结果 我们可以看到串口输出的信息，cnt输出的最大值为3，然后系统重置，进行循环输出。 这就意味着看门狗起作用了，没有喂狗导致系统重置 Sys reset cnt=0 cnt=1 cnt=2 cnt=3 Sys reset cnt=0 cnt=1 cnt=2 cnt=3 启用喂狗 喂狗的函数为：HAL_IWDG_Refresh，在看门狗的设置周期内，调用喂狗函数，将重置装载器（reload），这样就不会触发看门狗，导致系统重置 代码 while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ if(cnt==0) { printf(\"Sys reset\\r\\n\"); } printf(\"cnt=%d\\r\\n\",cnt); cnt++; HAL_Delay(300); HAL_IWDG_Refresh(&hiwdg); } 输出结果Sys reset cnt=0 cnt=1 cnt=2 cnt=3 cnt=4 cnt=5 cnt=6 cnt=7 cnt=8 cnt=9 cnt=10 cnt=11 cnt=12 cnt=13 cnt=14 cnt=15 cnt=16 cnt=17 cnt=18 cnt=19 cnt=20 cnt=21 cnt=22 cnt=23 cnt=24 cnt=25 cnt=26 cnt=27 cnt=28 其他问题 调用喂狗函数后，系统输出的最大值为256，不知道原因在哪。（我猜是云分频计数器最大值是256吧） 预分频寄存器只占用3个bit，计算方式为：42的n次方，如寄存器位001（1），预分频系数位：42=8；如寄存器位110（6），4*2的6次方=256；在实际中，预分频系数是直接设置的，无需根据位来计算； 重载数值寄存器占用12位，因此reload的最大值是4095. 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-09-24 11:59:50 "},"stm32/stm32f407_fsmc_sram.html":{"url":"stm32/stm32f407_fsmc_sram.html","title":"stm32F407读写SRAM","keywords":"","body":"stm32F407读写SRAM STM32F407ZGT6的开发板，MCU自带的flash容量是1024kB（byte下同），RAM的容量是192kB，其实容量还是可以的。 但是我这个开发板外扩了flash和RAM，其中外扩的flash是16MB（128Mb），RAM的容量是1MB（8Mb）。 本节是练习下怎么使用外扩的RAM读写方法，网上有很多介绍如何读写的方法，基本都不是使用标准的HAL库方式，要么使用寄存器方式，手写配置；要么自己写了垃圾ram驱动而且只公布几个函数，非常不适合入门。所以本文不介绍寄存器，反正我也不懂^_^ 一、前情提要 外扩的SRAM是IS62WV51216，是一颗 16 位宽 512K（512＊16，即 1M 字节）容量的 CMOS 静态内存芯片，详细的参数就不写了 将printf函数重定向至USART1串口 需要了解FSMC用法，后面会介绍 二、SRAM引脚 SRAM一共有44个引脚，主要分为地址线、数据线等，在后面的配置中会要用到（但是不需要在代码中操作），具体如下： A0~18 为地址线，总共 19 根地址线； IO0~15 为数据线，总共 16 根数据线； OE是输出使能信号（读信号）； WE 为写使能信号 UB 和 LB 分别是高字节控制和低字节控制信号 CS2 和 CS1 都是片选信号，原理图上实际上就是CE引脚（只有一个片选引脚），此引脚本开发板中外接的是NE3（这个后面会要在FSMC中配置一个参数，NE3这个非常重要，涉及到FSMC配置和内存起始地址） 以上一共40个引脚，另有4个引脚是VCC和GND，即一共44个引脚 三、FSMC介绍 FSMC全称Flexible static memory controller， STM32 的FSMC 将外部存储器划分为固定大小为 256M 字节的四个存储块Bank，总共管理1GB的空间。 4个bank各有不同的用途，如bank1是NOR/PSRAM，bank2和bank3是Nand flash，bank4是pc card； 因此SRAM是在bank1块，而且本开SRAM芯片的片选引脚（CE引脚）外接的是NE3，即在bank1的第三区，不同的区，RAM的地址是不同的。如NE3的内存起始地址是0x68000000~0x6BFFFFFF，NE2起始地址是0x64000000~0x67FFFFFF（可以计算出每个区是64M，每个bank分为4个区，即每个bank是256M）； FSMC可以在网上找框图了解引脚功能，本SRAM的引脚接法如下：（配置时，系统自动配置好了，如果没有，就手动配置下）PF0 ------> FSMC_A0 PF1 ------> FSMC_A1 PF2 ------> FSMC_A2 PF3 ------> FSMC_A3 PF4 ------> FSMC_A4 PF5 ------> FSMC_A5 PF12 ------> FSMC_A6 PF13 ------> FSMC_A7 PF14 ------> FSMC_A8 PF15 ------> FSMC_A9 PG0 ------> FSMC_A10 PG1 ------> FSMC_A11 PE7 ------> FSMC_D4 PE8 ------> FSMC_D5 PE9 ------> FSMC_D6 PE10 ------> FSMC_D7 PE11 ------> FSMC_D8 PE12 ------> FSMC_D9 PE13 ------> FSMC_D10 PE14 ------> FSMC_D11 PE15 ------> FSMC_D12 PD8 ------> FSMC_D13 PD9 ------> FSMC_D14 PD10 ------> FSMC_D15 PD11 ------> FSMC_A16 PD12 ------> FSMC_A17 PD13 ------> FSMC_A18 PD14 ------> FSMC_D0 PD15 ------> FSMC_D1 PG2 ------> FSMC_A12 PG3 ------> FSMC_A13 PG4 ------> FSMC_A14 PG5 ------> FSMC_A15 PD0 ------> FSMC_D2 PD1 ------> FSMC_D3 PD4 ------> FSMC_NOE PD5 ------> FSMC_NWE PD6 ------> FSMC_NWAIT PG10 ------> FSMC_NE3 PE0 ------> FSMC_NBL0 PE1 ------> FSMC_NBL1 四、配置 启用USART1串口，即PA9和PA10接口； RCC和Sys，参照前面的同样配置 FSMC配置： （一）启用FSMC FSMC配置看起来复杂，但是Cube基本把大部分都已经配置好了，只要开发板不是太奇葩，基本不用太多的手动配置。 STM32CubeIDE好像有点问题，配置了FSMC后，无法点击其他配置，需要关掉ioc文件再次打开才能配置其他文件。 Connectivity-->FSMC （二）配置FSMC Mode:NOR Flash/PSRAM/SRAM/LCD 1 chip select:NE3 memory type:sram address:19(即sram的地址引脚数量，见SRAM介绍) data：16bit（即sram的数据位宽） wait：异步 byte enable：启用 Configuration-->NOR/PSRAM1-->NOR/PSRAM control（为Configuration下级选项，基本保持默认配置即可） memory type：sram bank：bank1 nor flash/psram 3 write operation：enable extend mode：enable（只有启用，才会有下面的nor timing for write accesses选框） 优先级：low Configuration-->NOR/PSRAM1-->NOR/PSRAM timing和NOR/PSRAM timing for write accesses 这两个均为时钟周期选项，保持一致即可，数据越小，读写速度越快； access mode：选A（可选项有A/D） Configuration-->GPIO Settings 根据上面FSMC的引脚进行配置 这里需要注意的就是片选（CS）的配置，开发板上只有一个片选引脚CE，外接开发板的NE3引脚。 五、实现 FSMC的配置和初始化在fsmc.c文件中 SRAM的初始化和操作函数，在stm32f4xx_hal_sram.c文件中，sram的读写操作有8、16和32位几种方式。 前面提到SRAM使用的bank1的NE3区，在内存中的映射起始地址时0x68000000，因此需要代码中定义一个地址变量，供后面的内存读写函数使用。 /* USER CODE BEGIN PV */ static uint32_t start_addr=0x68000000; /* USER CODE END PV */ （一）字符串一次性读写 代码 定义一个hello[]变量的字符串； 使用HAL_SRAM_Write_8b函数向SRAM写入 使用HAL_SRAM_Read_8b函数读取内容 uint32_t p_addr=start_addr; uint8_t hello[]=\"welcome stm32 world,www.bytetoy.cn\\r\\n\"; uint8_t txt_buf[26]; uint8_t tmp_buf[64]; printf(\"write sram hello[]:%s\\r\\n\",hello); HAL_Delay(100); HAL_SRAM_Write_8b(&hsram1, (uint32_t *)start_addr, (uint8_t *)hello, sizeof(hello)); p_addr=start_addr+sizeof(hello); printf(\"log ram address:start=%X,pointer=%X\\r\\n\",start_addr,p_addr); HAL_SRAM_Read_8b(&hsram1, (uint32_t *)start_addr, (uint8_t *)tmp_buf, 64); printf(\"read from sram tmp_buf:%s\\r\\n\",tmp_buf); 输出结果 与代码中的预期一致 write sram hello[]:welcome stm32 world,www.bytetoy.cn log ram address:start=68000000,pointer=68000025 read from sram tmp_buf:welcome stm32 world,www.bytetoy.cn （二）字符串单个读写 sram中内容的读写，函数是通过操作指针实现的，除了上面的一次性读写操作，也可以逐个字节来读取。 本代码是一次性写入一个字符串（26个小写字母），然后逐个读取字符串 代码 uint32_t p_addr=start_addr; uint8_t hello[]=\"welcome stm32 world,www.bytetoy.cn\\r\\n\"; uint8_t txt_buf[26]; uint8_t tmp_buf[64]; for(int i=0;i 输出结果 write sram txt_buf:abcdefghijklmnopqrstuvwxyz read sram txt_buf[0]=a read sram txt_buf[1]=b read sram txt_buf[2]=c read sram txt_buf[3]=d read sram txt_buf[4]=e read sram txt_buf[5]=f read sram txt_buf[6]=g read sram txt_buf[7]=h read sram txt_buf[8]=i read sram txt_buf[9]=j read sram txt_buf[10]=k read sram txt_buf[11]=l read sram txt_buf[12]=m read sram txt_buf[13]=n read sram txt_buf[14]=o read sram txt_buf[15]=p read sram txt_buf[16]=q read sram txt_buf[17]=r read sram txt_buf[18]=s read sram txt_buf[19]=t read sram txt_buf[20]=u read sram txt_buf[21]=v read sram txt_buf[22]=w read sram txt_buf[23]=x read sram txt_buf[24]=y read sram txt_buf[25]=z 六、注意事项 SRAM的读写操作函数的参数，内存地址参数是32整型（arm是32位处理器，因此内存地址长度是32位），如HAL_SRAM_Write_8b的第二个参数 SRAM在FSMC中的内存起始地址是0x68000000，需要手动设置； 内存的读写操作要手动记录当前内存地址，如第一次写入数组后，需要手动记录内存地址移动到哪个位子，如：p_addr=start_addr+sizeof(hello);，才能保证后面写入内容，不会覆盖前面的内容。 STM32CubeIDE已经提供了SRAM的读写操作函数，无需自己实现内存的读写操作函数。 log ram address:start=68000000,pointer=68000025计算方法：hello字符串数组的长度是38，指针地址偏移了25（实际是26，从0开始计算），16进制转换为10进制就是38。 两个有用的参考网址： 1 2 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-09-24 23:26:58 "},"stm32/stm32f407_spi_lcd.html":{"url":"stm32/stm32f407_spi_lcd.html","title":"stm32F407驱动LCD屏幕","keywords":"","body":"stm32F407驱动LCD屏幕 这个折腾了两次才搞好，一是能力有限写不了驱动；二是没搞懂arm的时钟，配置起来困难。这次总算弄好了。 一、硬件 LCD参数如下： 驱动芯片：ST7789 像素：240**240 大小：1.23inch 一共8个引脚 二、配置 （一）引脚功能 引脚 功能 VCC LCD 供电电源引脚（3.3V） CS LCD 片选信号（低电平有效） SDA LCD 的 SDA 信号线 RESET LCD 的复位信号(低电平有效) WR(DC) 写命令/写数据信号（0：写命令；1：写数据） SCK LCD 的 SCK 时钟线 PWR/BLK LCD 背光控制引脚（0：关闭；1：打开） GND 电源地 （二）接线方法 我的开发板上的SPI1被用作链接到外扩的Flash上，所以就使用了SPI2，使用方式是一样的，就是注意一下参数即可。 开发板引脚 ST7789引脚 ST7789引脚 开发板引脚 PC0 DC/WR RST PC1 PB10 SCK SDA PC3 PC4 PWR/BLK CS PC5 PB10和PC3为系统默认为SPI2分配的引脚，无需修改； 其余4个引脚均在GPIO中设置为OUTPUT模式 VCC和GND引脚，任意电源和接地引脚即可 （三）项目配置 RCC和SYS保持和之前的默认配置即可； GPIO配置：根据上面的引脚接法，PC0/PC1/PC4/PC5，配置为OUTPUT，输出低电平； SPI2的配置 Connectivity-->SPI2-->MODE:Transimit only maste（主设备仅发送模式）r，NSS:disable（配合下面的使用软件控制） GPIO Settings：保持默认设置即可，就是两个gpio接口 Parameter Settings：这是最重要的一个配置： Basic Parameters：Frame format（motorola）；Data Size：8Bits； First Bit：MSB Clock Parameters：prescaler：8；CPOL:High;CPHA:2edge Advance Parameters：CRC:disable;NSS:Software NVIC Settings:启用中断 三、驱动移植 （一）将驱动包含至编译路径 将驱动文件（驱动和字体库）解压至项目的core目录下（新建一个文件夹存放，如LCD） 然后将该驱动目录包含至include文件中，如下设置： Project-->Properties-->C/C++ build-->Settings-->MCU GCC Complier-->include paths （二）修改lcd.h文件 驱动开发的作者，在这里写死DC和RST两个gpio引脚，修改为刚才在GPIO中配置的引脚，如下所示： /* LCD_RST: PC1 LCD_DC: PC0 */ #define LCD_RST(n) (n?HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,GPIO_PIN_SET):HAL_GPIO_WritePin(GPIOC,GPIO_PIN_1,GPIO_PIN_RESET)) #define LCD_DC(n) (n?HAL_GPIO_WritePin(GPIOC,GPIO_PIN_0,GPIO_PIN_SET):HAL_GPIO_WritePin(GPIOC,GPIO_PIN_0,GPIO_PIN_RESET)) （三）实现SPI_WriteByte(data, size)函数 在驱动程序中，作者这个文件名字为：SPI1_WriteByte(data, size)，我把名字改了下，这里可改可不改 这是函数调用是在lcd.c文件中，我们需要在main.c文件中实现，当然在lcd.c中是写亦可以，我是在main.c文件中实现。 我这里使用的是SPI2接口，因此需要使用&hspi2/* USER CODE BEGIN 4 */ uint8_t SPI_WriteByte(uint8_t * data,uint16_t size) { return HAL_SPI_Transmit(&hspi2, data, size, 0xff); } /* USER CODE END 4 */ 同时要在main.h文件中，将此方法声明/* USER CODE BEGIN Private defines */ uint8_t SPI_WriteByte(uint8_t * data,uint16_t size); /* USER CODE END Private defines */ （四）启用背光和片选功能 ST7789的背光是高电平有效，需要开启了才能看得清（可能是我这LCD屏的问题）； 片选(CS)是低电平有效，可开启可不开启，我已经把引脚接好了，所以开启了。 在GPIO初始化之后，设置这两个功能引脚 本操作在main.c文件中HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET); //片选应交可开可不开，低电平有效，gpio默认输出低电平 HAL_GPIO_WritePin(GPIOC, GPIO_PIN_5, GPIO_PIN_RESET); 四、实现 SPI驱动LCD最难的地方是配置和驱动的移植，实现反而比较简单，无非是初始化LCD然后打印文字或者图形，这里就简要介绍，需要设置复杂的功能，可以查看驱动的函数 以下操作均在main.c文件中 包含lcd.h头文件 /* USER CODE BEGIN Includes */ #include \"lcd.h\" /* USER CODE END Includes */ 初始化LCD /* USER CODE BEGIN 2 */ //背光必须要打开，否则lcd屏幕是黑色的，设置为1，高电平 HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET); //片选应交可开可不开，低电平有效，gpio默认输出低电平 HAL_GPIO_WritePin(GPIOC, GPIO_PIN_5, GPIO_PIN_RESET); LCD_Init(); /* USER CODE END 2 */ 输出文字和绘制图形 while (1) { LCD_Clear(RED); LCD_ShowString(5, 10, 240, 24, 24, \"Bytetoy,cn,Welcome!\"); LCD_ShowString(5, 50, 240, 32, 32, \"TFT-LCD:ST7789\"); LCD_ShowString(5, 100, 240, 32, 32, \"Resolution:\"); LCD_ShowString(140, 140, 240, 24, 24, \"-240*240\"); LCD_ShowString(5, 170, 240, 32, 32, \"Size:\"); LCD_ShowString(140, 210, 240, 24, 24, \"-1.3inch\"); HAL_Delay(2000); LCD_Clear(BLUE); LCD_Draw_Circle(120, 120, 100);//画圆 半径r=100 LCD_Draw_Circle(120, 120, 80);//画圆 半径r=80 LCD_Draw_Circle(120, 120, 60);//画圆 半径r=60 LCD_Draw_Circle(120, 120, 40);//画圆 半径r=40 LCD_Draw_Circle(120, 120, 20);//画圆 半径r=20 // LCD_Draw_Circle(120, 120, 1);//画圆 半径r=1 LCD_Draw_Point(120,120); HAL_Delay(1500); LCD_Clear(GRAY); LCD_DrawRectangle(70, 70, 170, 170); LCD_Fill(70, 70, 170, 170, GREEN); HAL_Delay(1500); /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } 烧录程序后，即可在LCD上看到文字和图形 五、注意事项 驱动文件需要导入到include path中 驱动文件的移植，因为使用的是SPI2，而且引脚不同，要注意配置 GPIO引脚的接法不能错，同时背光要开 配置中，注意极性和相位的配置 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-09-28 12:40:44 "},"minecraft/minecraft.html":{"url":"minecraft/minecraft.html","title":"Minecraft","keywords":"","body":"Minecraft Minecraft简介 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-04-23 20:23:27 "},"minecraft/Minecraft服务器Spigot安装和配置.html":{"url":"minecraft/Minecraft服务器Spigot安装和配置.html","title":"Minecraft服务器Spigot安装和配置","keywords":"","body":"Minecraft服务器Spigot安装和配置 Minecraft的服务器程序有很多，有微软官方的，比如国内网易的服，也有非官方的服务器。现阶段如果要自己搭建服务器，推荐Spigot，方便、快捷，配置简单。 环境 良心云轻应用服务器：1h2g5m配置 系统：Ubuntu 18.04 LTS Spigot编译 Spigot官方不提供编译好的jar包，需要我们自己手动编译。 安装Java jre环境： sudo apt-get install openjdk-8-jre-headless 下载Spigot官方提供的构建工具： 新建一个目录，如：mc，下载构建工具BuiltTools.jar，放在此目录下。后续构建的Spigot.jar和相应的文件，放在此目录下，便于管理和修改。 https://hub.spigotmc.org/jenkins/job/BuildTools/lastSuccessfulBuild/artifact/target/BuildTools.jar 编译Spigot的jar包 网上有很多的教程，需要下载maven、git、以及各类bukkit等各类文件等，如果使用Spigot官方构建工具的话，无需下载这些工具和文件，BuiltTools会自动下载相应的工具和文件，如Maven等。 java -jar BuildTools.jar 以上默认是编译生成最新版Minecraft的jar包，如果你电脑上的MC版本是1.16.2，1.6.3等版本，可以生成指定的服务器版本。 java -jar BuildTools.jar --rev 1.16.3 编译成功后，mc目录下会生成服务端文件：Spigot.jar以及相应的文件。 开放服务器端口 默认情况下，Spigot的端口就是微软官方的端口，端口号为：25565 登录腾讯云服务器管理界面--> 防火墙设置--> 添加规则，如下图 规则添加成功后如下图： 必选配置项 修改eula.txt文件中的false为true，才能开服； 非正版用户登录：修改server.properties文件，取消正版验证，非正版用户也可以登录（支持正版理所当然），此项设置为falseonline-mode=false 启用服务器 SSH登录服务器，启用服务器：java -Xms1024M -Xmx1024M -jar spigot-1.16.4.jar nogui 服务器启用成功后，在本地启用mc客户端，如HCML。 在本地客户端的多人游戏--> 添加服务器，填入你的服务器ip地址。 安装screen 安装screen：默认情况下，在服务器上启用Spigot后，需要一直运行一个SSH终端窗口，如果关闭，服务端也会被关闭，这时可以安装screen。安装步骤就不说了。 启用一个终端：mc是终端窗口的名字，可以另选：screen -S mc 进入screen终端后，启用Spigot服务器：java -Xms1024M -Xmx1024M -jar spigot-1.16.4.jar nogui 使用快捷键ctrl+a+d，离开screen窗口，服务器继续运行，不会中断； 退出服务器或终端后，再次登录服务器时，只需唤起此窗口即可，此时可以在终端中窗口中使用Spigot服务器命令，如list。screen -r mc 其他配置 server.properties文件 server.properties时Spigot最重要的配置文件，可在此配置文件中配置服务器端口、服务器的名字和备注 max-tick-time=60000 query.port=25565 generator-settings= sync-chunk-writes=true force-gamemode=false allow-nether=true enforce-whitelist=false gamemode=survival broadcast-console-to-ops=true enable-query=false player-idle-timeout=0 text-filtering-config= difficulty=easy spawn-monsters=true broadcast-rcon-to-ops=true op-permission-level=4 pvp=true entity-broadcast-range-percentage=100 snooper-enabled=true level-type=default hardcore=false enable-status=true enable-command-block=true max-players=10 network-compression-threshold=256 resource-pack-sha1= max-world-size=29999984 function-permission-level=2 rcon.port=25575 server-port=25565 debug=false server-ip= spawn-npcs=true allow-flight=false level-name=world view-distance=10 resource-pack= spawn-animals=true white-list=true rcon.password= generate-structures=true online-mode=false max-build-height=256 level-seed= prevent-proxy-connections=false use-native-transport=true enable-jmx-monitoring=false motd=www.bytetoy.cn(QQ\\:12620716) rate-limit=0 enable-rcon=false whitelist.json：配置白名单用户，需要在server.properties文件中先开启白名单功能white-list=true whitelist的内容时允许登录的用户信息： [ { \"uuid\": \"45390f9d-6993-3b84-a292-d5cdfca8c87a\", \"name\": \"CODE0000\" } ] ops.json：管理员账户信息 [ { \"uuid\": \"45390f9d-6993-3b84-a292-d5cdfca8c87a\", \"name\": \"CODE0000\", \"level\": 4, \"bypassesPlayerLimit\": false } ] 设置服务器的ICON，创建一个6464的png文件，命名为*server-icon.png，上传至服务器，重启服务端再次登录，会出现一个服务器的icon。 设置服务器配置备注信息，添加此信息后，用户连上服务器，除了用户备注的名字，下面还有有一栏备注。在server.properties文件中修改motd选项 motd=www.bytetoy.cn(QQ\\:12620716) 鄂ICP备15001733号-4 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-04-24 13:08:53 "},"pico/pico.html":{"url":"pico/pico.html","title":"Raspberry pi pico","keywords":"","body":"Raspberry pi pico 记录pico开发板学习笔记 由于pico芯片能力不足，暂停学习和更新. 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2023-10-15 09:13:28 "},"pico/Ubuntu下配置raspberry_pico开发环境.html":{"url":"pico/Ubuntu下配置raspberry_pico开发环境.html","title":"Ubuntu下配置raspberry_pico开发环境","keywords":"","body":"Ubuntu下配置raspberry pico开发环境 欢迎访问我的小站：www.bytetoy.cn 一、需要的工具 官方提供了在ubuntu下一键安装环境的脚本，但是有些东西，可能暂时不需要使用，可以自己安装需要的工具和git相应的代码库。 cmake git gcc-arm-none-eabi minicom 注: 以上三个工具是必备了，像编辑器之类的，自己可以选择安装自己喜欢的，如：vim。 以上四个工具的安装，可以直接使用aptitude进行安装，无需自己编译源代码折腾。 通过api安装有个好处，就是无需再设置gcc-arm-none-eabi的路径，同时自动安装依赖，方便很多。 二、测试交叉编译链工具 arm-gcc交叉编译链工具安装成功后，可以通过-v查看安装的版本，显示如下说明安装成功。 ~ arm-none-eabi-gcc -v ✔ 07:35:43 Using built-in specs. COLLECT_GCC=arm-none-eabi-gcc COLLECT_LTO_WRAPPER=/usr/lib/gcc/arm-none-eabi/9.2.1/lto-wrapper Target: arm-none-eabi Configured with: ../configure --build=x86_64-linux-gnu --prefix=/usr --includedir='/usr/lib/include' --mandir='/usr/lib/share/man' --infodir='/usr/lib/share/info' --sysconfdir=/etc --localstatedir=/var --disable-silent-rules --libdir='/usr/lib/lib/x86_64-linux-gnu' --libexecdir='/usr/lib/lib/x86_64-linux-gnu' --disable-maintainer-mode --disable-dependency-tracking --mandir=/usr/share/man --enable-languages=c,c++,lto --enable-multilib --disable-decimal-float --disable-libffi --disable-libgomp --disable-libmudflap --disable-libquadmath --disable-libssp --disable-libstdcxx-pch --disable-nls --disable-shared --disable-threads --enable-tls --build=x86_64-linux-gnu --target=arm-none-eabi --with-system-zlib --with-gnu-as --with-gnu-ld --with-pkgversion=15:9-2019-q4-0ubuntu1 --without-included-gettext --prefix=/usr/lib --infodir=/usr/share/doc/gcc-arm-none-eabi/info --htmldir=/usr/share/doc/gcc-arm-none-eabi/html --pdfdir=/usr/share/doc/gcc-arm-none-eabi/pdf --bindir=/usr/bin --libexecdir=/usr/lib --libdir=/usr/lib --disable-libstdc++-v3 --host=x86_64-linux-gnu --with-headers=no --without-newlib --with-multilib-list=rmprofile CFLAGS='-g -O2 -fdebug-prefix-map=/build/gcc-arm-none-eabi-Gl9kT9/gcc-arm-none-eabi-9-2019-q4=. -fstack-protector-strong' CPPFLAGS='-Wdate-time -D_FORTIFY_SOURCE=2' CXXFLAGS='-g -O2 -fdebug-prefix-map=/build/gcc-arm-none-eabi-Gl9kT9/gcc-arm-none-eabi-9-2019-q4=. -fstack-protector-strong' FCFLAGS='-g -O2 -fdebug-prefix-map=/build/gcc-arm-none-eabi-Gl9kT9/gcc-arm-none-eabi-9-2019-q4=. -fstack-protector-strong' FFLAGS='-g -O2 -fdebug-prefix-map=/build/gcc-arm-none-eabi-Gl9kT9/gcc-arm-none-eabi-9-2019-q4=. -fstack-protector-strong' GCJFLAGS='-g -O2 -fdebug-prefix-map=/build/gcc-arm-none-eabi-Gl9kT9/gcc-arm-none-eabi-9-2019-q4=. -fstack-protector-strong' LDFLAGS='-Wl,-Bsymbolic-functions -Wl,-z,relro' OBJCFLAGS='-g -O2 -fdebug-prefix-map=/build/gcc-arm-none-eabi-Gl9kT9/gcc-arm-none-eabi-9-2019-q4=. -fstack-protector-strong' OBJCXXFLAGS='-g -O2 -fdebug-prefix-map=/build/gcc-arm-none-eabi-Gl9kT9/gcc-arm-none-eabi-9-2019-q4=. -fstack-protector-strong' INHIBIT_LIBC_CFLAGS=-DUSE_TM_CLONE_REGISTRY=0 AR_FOR_TARGET=arm-none-eabi-ar AS_FOR_TARGET=arm-none-eabi-as LD_FOR_TARGET=arm-none-eabi-ld NM_FOR_TARGET=arm-none-eabi-nm OBJDUMP_FOR_TARGET=arm-none-eabi-objdump RANLIB_FOR_TARGET=arm-none-eabi-ranlib READELF_FOR_TARGET=arm-none-eabi-readelf STRIP_FOR_TARGET=arm-none-eabi-strip Thread model: single gcc version 9.2.1 20191025 (release) [ARM/arm-9-branch revision 277599] (15:9-2019-q4-0ubuntu1) 三、安装pico sdk 1. 拉取pico sdk库 git submodule update --init：是要拉取tinyusb库，必备步骤，注意操作目录是在sdk目录下。 mkdir rasp-pico cd rasp-pico git clone -b master https://github.com/raspberrypi/pico-sdk.git cd pico-sdk git submodule update --init 2. 设置pico-sdk路径 在后面编译官方example时，需要用到官方的sdk头文件，需要在系统环境中配置sdk目录 vim .bashrc 在末尾添加一行： export PICO_SDK_PATH=/home/neal/rasp-pico/pico-sdk sdk路径配置成功后，验证下是否配置成功 env | grep PICO ✔ 08:05:06 PICO_SDK_PATH=/home/neal/rasp-pico/pico-sdk 三、拉取其他官方git库 官方还有其他几个库，尤其是examples库，非常有帮助。另外还有extra、playground属于高级用法的库，可以拉取下来，拉取的目录实在rasp-pico下。 git clone https://github.com/raspberrypi/pico-examples.git git clone https://github.com/raspberrypi/pico-extras.git git clone https://github.com/raspberrypi/pico-playground.git 四、编译官方example 官方示例代码的编译，分为两个步骤 1. 编译项目 进入pico-examples目录 新建一个build目录，进入此目录 在build目录下，运行cmake ..命令 成功后会输出一下信息： ~/rasp-pico cd pico-examples ✔ 08:39:28 ~/rasp-pico/pico-examples master mkdir build ✔ 08:39:52 ~/rasp-pico/pico-examples master cd build ✔ 08:39:55 ~/rasp-pico/pico-examples/build master cmake .. ✔ 08:39:59 Using PICO_SDK_PATH from environment ('/home/neal/rasp-pico/pico-sdk') PICO_SDK_PATH is /home/neal/rasp-pico/pico-sdk Defaulting PICO_PLATFORM to rp2040 since not specified. Defaulting PICO platform compiler to pico_arm_gcc since not specified. -- Defaulting build type to 'Release' since not specified. PICO compiler is pico_arm_gcc -- The C compiler identification is GNU 9.2.1 -- The CXX compiler identification is GNU 9.2.1 -- The ASM compiler identification is GNU -- Found assembler: /usr/bin/arm-none-eabi-gcc Defaulting PICO target board to pico since not specified. Using board configuration from /home/neal/rasp-pico/pico-sdk/src/boards/include/boards/pico.h -- Found Python3: /usr/bin/python3.8 (found version \"3.8.10\") found components: Interpreter TinyUSB available at /home/neal/rasp-pico/pico-sdk/lib/tinyusb/src/portable/raspberrypi/rp2040; enabling build support for USB. -- Configuring done -- Generating done -- Build files have been written to: /home/neal/rasp-pico/pico-examples/build 2. 编译blink代码 进入build目录下的blink目录 运行make编译命令 成功后会输出以下信息 然后可以在此目录下，可以看到编译输入的二进制文件：blink.bin,blink.elf,blink.uf2，这三个文件都是编译成功的文件，uf2用于通过USB模式拷入pico，bin用于通过 ~/rasp-pico/pico-examples/build master cd blink ✔ 08:42:10 ~/rasp-pico/pico-examples/build/blink master ls ✔ 08:42:13 CMakeFiles cmake_install.cmake elf2uf2 Makefile ~/rasp-pico/pico-examples/build/blink master make ✔ 08:42:14 Scanning dependencies of target ELF2UF2Build Creating directories for 'ELF2UF2Build' No download step for 'ELF2UF2Build' No patch step for 'ELF2UF2Build' No update step for 'ELF2UF2Build' Performing configure step for 'ELF2UF2Build' -- The C compiler identification is GNU 9.4.0 -- The CXX compiler identification is GNU 9.4.0 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ -- works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- Configuring done -- Generating done -- Build files have been written to: /home/neal/rasp-pico/pico-examples/build/elf2uf2 Performing build step for 'ELF2UF2Build' Scanning dependencies of target elf2uf2 [ 50%] Building CXX object CMakeFiles/elf2uf2.dir/main.cpp.o [100%] Linking CXX executable elf2uf2 [100%] Built target elf2uf2 No install step for 'ELF2UF2Build' Completed 'ELF2UF2Build' Built target ELF2UF2Build Scanning dependencies of target bs2_default Building ASM object pico-sdk/src/rp2_common/boot_stage2/CMakeFiles/bs2_default.dir/compile_time_choice.S.obj Linking ASM executable bs2_default.elf Built target bs2_default Scanning dependencies of target bs2_default_padded_checksummed_asm Generating bs2_default.bin Generating bs2_default_padded_checksummed.S Built target bs2_default_padded_checksummed_asm Scanning dependencies of target blink Building C object blink/CMakeFiles/blink.dir/blink.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_stdlib/stdlib.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/hardware_gpio/gpio.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/hardware_claim/claim.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_platform/platform.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/hardware_sync/sync.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/hardware_uart/uart.c.obj Building ASM object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/hardware_divider/divider.S.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/common/pico_time/time.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/common/pico_time/timeout_helper.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/hardware_timer/timer.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/common/pico_sync/sem.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/common/pico_sync/lock_core.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/common/pico_sync/mutex.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/common/pico_sync/critical_section.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/common/pico_util/datetime.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/common/pico_util/pheap.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/common/pico_util/queue.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_runtime/runtime.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/hardware_clocks/clocks.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/hardware_irq/irq.c.obj Building ASM object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/hardware_irq/irq_handler_chain.S.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/hardware_pll/pll.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/hardware_vreg/vreg.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/hardware_watchdog/watchdog.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/hardware_xosc/xosc.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_printf/printf.c.obj Building ASM object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_bit_ops/bit_ops_aeabi.S.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_bootrom/bootrom.c.obj Building ASM object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_divider/divider.S.obj Building ASM object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_double/double_aeabi.S.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_double/double_init_rom.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_double/double_math.c.obj Building ASM object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_double/double_v1_rom_shim.S.obj Building ASM object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_int64_ops/pico_int64_ops_aeabi.S.obj Building ASM object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_float/float_aeabi.S.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_float/float_init_rom.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_float/float_math.c.obj Building ASM object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_float/float_v1_rom_shim.S.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_malloc/pico_malloc.c.obj Building ASM object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_mem_ops/mem_ops_aeabi.S.obj Building ASM object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_standard_link/crt0.S.obj Building CXX object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_standard_link/new_delete.cpp.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_standard_link/binary_info.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_stdio/stdio.c.obj Building C object blink/CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_stdio_uart/stdio_uart.c.obj Linking CXX executable blink.elf Built target blink 五、载入和运行blink 通过上面编译blink项目，可以将生成的blink.uf2文件，通过USB方式考入pico然后运行。 载入blink文件 将pico的USB接口插上usb线 按住pico开发板上的BOOTSEL按钮，然后插上usb的接口 系统会提示加载了一个U盘，将blink.uf2文件拷入这个u盘，系统立马就会加载这个blink程序，同时u盘模式会自动退出 系统加载u盘后，pico里面会有两个自动生成的文件，不用管他就行。 pico运行blink后，开发板生的led灯会闪烁。 欢迎访问我的小站：www.bytetoy.cn 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-04-24 13:07:47 "},"pico/Raspberry_Pico点亮LED灯.html":{"url":"pico/Raspberry_Pico点亮LED灯.html","title":"Raspberry_Pico点亮LED灯","keywords":"","body":"Raspberry Pico点亮LED灯 点亮Pico的LED灯，是Raspberry官方的教程的第一示例，也是最容易的示例。但是官方教程，包括网上其他各类教程，都是使用官方推荐的Visual Studio Code最为默认开发工具。 即使是官方的examples，也只是介绍了如何编译和生成uf2文件，并没有讲如何单独编写blink和编译生成二进制文件。 这里介绍如何完全手动创建一个点亮led的项目，并编写cmake的编译文件，无需第三方工具自动生成。 如果有兴趣，可以研究examples目录下的CMakeLists.txt文件，可以学到如何配置但项目示例的CMakeLists。 一、项目准备工作 1. 工具 本示例未使用官方推荐的VSC，而仅仅使用vim编写代码，然后使用编写cmake文件和交叉编译工具链进行编译 arm-gcc交叉编译工具； 编辑器：vim2. 新建项目文件夹 这里新建一个blink目录，后面的C代码和cmake文件均在此目录下。 后面的编译操作也在此目录下进行（这里的编译与官方example示例编译不同，无需建立build目录和编译，更方便学习和编译小项目示例） 二、编写blink代码 blink代码很简单，原理就是给gpio一个信号是高低电平来点亮还是熄灭led灯，然后通过指定一段线程sleep时间。 1. 代码 #include \"pico/stdlib.h\" int main() { #ifndef PICO_DEFAULT_LED_PIN #warning blink example requires a board with a regular LED #else const uint LED_PIN = PICO_DEFAULT_LED_PIN; gpio_init(LED_PIN); gpio_set_dir(LED_PIN, GPIO_OUT); while (true) { gpio_put(LED_PIN, 1); sleep_ms(1000); gpio_put(LED_PIN, 0); sleep_ms(1000); } #endif } 2. 说明 Pico开发板上自带一个led灯，默认的gpio编号为25,可以手动指定，也可以使用系统变量； 如果使用自己外插的发光二极管，需要手动指定gpio的编号； 三、配置项目环境 1. 编写pico_sdk_import.cmake 将官方示例的pico_sdk_import.cmake文件拷贝至blink目录下，如果没有从github上下载官方示例，可以使用下面代码 看代码的注释可知，此cmake的文件主要作用是设置pico sdk的路径 # This is a copy of /external/pico_sdk_import.cmake # This can be dropped into an external project to help locate this SDK # It should be include()ed prior to project() if (DEFINED ENV{PICO_SDK_PATH} AND (NOT PICO_SDK_PATH)) set(PICO_SDK_PATH $ENV{PICO_SDK_PATH}) message(\"Using PICO_SDK_PATH from environment ('${PICO_SDK_PATH}')\") endif () if (DEFINED ENV{PICO_SDK_FETCH_FROM_GIT} AND (NOT PICO_SDK_FETCH_FROM_GIT)) set(PICO_SDK_FETCH_FROM_GIT $ENV{PICO_SDK_FETCH_FROM_GIT}) message(\"Using PICO_SDK_FETCH_FROM_GIT from environment ('${PICO_SDK_FETCH_FROM_GIT}')\") endif () if (DEFINED ENV{PICO_SDK_FETCH_FROM_GIT_PATH} AND (NOT PICO_SDK_FETCH_FROM_GIT_PATH)) set(PICO_SDK_FETCH_FROM_GIT_PATH $ENV{PICO_SDK_FETCH_FROM_GIT_PATH}) message(\"Using PICO_SDK_FETCH_FROM_GIT_PATH from environment ('${PICO_SDK_FETCH_FROM_GIT_PATH}')\") endif () set(PICO_SDK_PATH \"${PICO_SDK_PATH}\" CACHE PATH \"Path to the Raspberry Pi Pico SDK\") set(PICO_SDK_FETCH_FROM_GIT \"${PICO_SDK_FETCH_FROM_GIT}\" CACHE BOOL \"Set to ON to fetch copy of SDK from git if not otherwise locatable\") set(PICO_SDK_FETCH_FROM_GIT_PATH \"${PICO_SDK_FETCH_FROM_GIT_PATH}\" CACHE FILEPATH \"location to download SDK\") if (NOT PICO_SDK_PATH) if (PICO_SDK_FETCH_FROM_GIT) include(FetchContent) set(FETCHCONTENT_BASE_DIR_SAVE ${FETCHCONTENT_BASE_DIR}) if (PICO_SDK_FETCH_FROM_GIT_PATH) get_filename_component(FETCHCONTENT_BASE_DIR \"${PICO_SDK_FETCH_FROM_GIT_PATH}\" REALPATH BASE_DIR \"${CMAKE_SOURCE_DIR}\") endif () FetchContent_Declare( pico_sdk GIT_REPOSITORY https://github.com/raspberrypi/pico-sdk GIT_TAG master ) if (NOT pico_sdk) message(\"Downloading Raspberry Pi Pico SDK\") FetchContent_Populate(pico_sdk) set(PICO_SDK_PATH ${pico_sdk_SOURCE_DIR}) endif () set(FETCHCONTENT_BASE_DIR ${FETCHCONTENT_BASE_DIR_SAVE}) else () message(FATAL_ERROR \"SDK location was not specified. Please set PICO_SDK_PATH or set PICO_SDK_FETCH_FROM_GIT to on to fetch from git.\" ) endif () endif () get_filename_component(PICO_SDK_PATH \"${PICO_SDK_PATH}\" REALPATH BASE_DIR \"${CMAKE_BINARY_DIR}\") if (NOT EXISTS ${PICO_SDK_PATH}) message(FATAL_ERROR \"Directory '${PICO_SDK_PATH}' not found\") endif () set(PICO_SDK_INIT_CMAKE_FILE ${PICO_SDK_PATH}/pico_sdk_init.cmake) if (NOT EXISTS ${PICO_SDK_INIT_CMAKE_FILE}) message(FATAL_ERROR \"Directory '${PICO_SDK_PATH}' does not appear to contain the Raspberry Pi Pico SDK\") endif () set(PICO_SDK_PATH ${PICO_SDK_PATH} CACHE PATH \"Path to the Raspberry Pi Pico SDK\" FORCE) include(${PICO_SDK_INIT_CMAKE_FILE}) 2. 编写CMakeLists.txt cmake文件，用于初始化sdk和指定编译的项目信息. 说明 cmake_minimum_required：指定cmake程序最低版本，我的版本是3.16，实际中可以指定的稍微低一点; include：引入上面的pico_sdk_import.cmake，配置pico sdk路径； project：设置blink的项目名称，可以与项目名称一致，也可以不同； pico_sdk_init：初始化pico sdk； 最后面三行，用于配置blink的信息，如C代码名称、生成二进制文件的名称等 cmake文件的编写， 要注意顺序（强调三遍） cmake_minimum_required(VERSION 3.12) include(pico_sdk_import.cmake) project(pico-blink) pico_sdk_init() add_executable(blink blink.c ) # pull in common dependencies target_link_libraries(blink pico_stdlib) # create map/bin/hex file etc. pico_add_extra_outputs(blink) 四、编译代码 blink.c代码和项目cmake编译配置文件完成后，即可编译项目，生成uf2等二进制文件 1. cmake生成makefile 在当前目录（blink）下，运行cmake .命令，系统自动生成makefile文件，如C代码和配置文件无误，会顺利生成成功，并在项目目录下生成一大堆文件，如下： cmake . ✔ 10:44:20 Using PICO_SDK_PATH from environment ('/home/neal/rasp-pico/pico-sdk') PICO_SDK_PATH is /home/neal/rasp-pico/pico-sdk Defaulting PICO_PLATFORM to rp2040 since not specified. Defaulting PICO platform compiler to pico_arm_gcc since not specified. -- Defaulting build type to 'Release' since not specified. PICO compiler is pico_arm_gcc -- The C compiler identification is GNU 9.2.1 -- The CXX compiler identification is GNU 9.2.1 -- The ASM compiler identification is GNU -- Found assembler: /usr/bin/arm-none-eabi-gcc Defaulting PICO target board to pico since not specified. Using board configuration from /home/neal/rasp-pico/pico-sdk/src/boards/include/boards/pico.h -- Found Python3: /usr/bin/python3.8 (found version \"3.8.10\") found components: Interpreter TinyUSB available at /home/neal/rasp-pico/pico-sdk/lib/tinyusb/src/portable/raspberrypi/rp2040; enabling build support for USB. -- Configuring done -- Generating done -- Build files have been written to: /home/neal/rasp-pico/pico-learn/blink 2. make编译 makefile生成后，即可使用make进行项目的链接和编译，编译成功后，会在项目目录下生成blink.uf2等二进制文件，拷入pico开发板，即可运行。 make ✔ 10:44:25 Scanning dependencies of target ELF2UF2Build [ 1%] Creating directories for 'ELF2UF2Build' [ 3%] No download step for 'ELF2UF2Build' [ 5%] No patch step for 'ELF2UF2Build' [ 6%] No update step for 'ELF2UF2Build' [ 8%] Performing configure step for 'ELF2UF2Build' -- The C compiler identification is GNU 9.4.0 -- The CXX compiler identification is GNU 9.4.0 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ -- works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done 省略... [ 96%] Building C object CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_stdio/stdio.c.obj [ 98%] Building C object CMakeFiles/blink.dir/home/neal/rasp-pico/pico-sdk/src/rp2_common/pico_stdio_uart/stdio_uart.c.obj [100%] Linking CXX executable blink.elf [100%] Built target blink 五、关于cmake和make pico开发需要pico sdk的支持，这就相当于引入第三方C库，要用到cmake和make，与仅仅编译单文件的C代码不同。 以下关于cmake和make介绍，转自网络^_^ gcc：它是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。我们的程序只有一个源文件时，直接就可以用gcc命令编译它 make：make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令来进行编译和链接的。 makefile：make工具就根据makefile中的命令进行编译和链接的。makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。 cmake：cmake就可以更加简单的生成makefile文件给上面那个make用。根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。 CMakeLists.txt：cmake的配置文件。 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-04-24 13:07:00 "},"pico/VirtualBox虚拟机USB调试PICO串口.html":{"url":"pico/VirtualBox虚拟机USB调试PICO串口.html","title":"VirtualBox虚拟机USB调试PICO串口","keywords":"","body":"VirtualBox虚拟机USB调试Pico串口 一、环境 host主机：Windows 11 虚拟机工具：VirtualBox 6.1+ 虚拟机系统：Ubuntu 20 串口工具：minicom 二、Host主机设置 host主机，主要是查看pico插上后，所占用的com串口编号 打开设备管理器：电脑-->属性-->高级系统设置-->设备 在设备管理器中，查看端口（com和lpt） 默认情况下，系统会占用几个com端口，插上pico开发板后，设备管理器会更新，在端口下会出现新的设备，这就是pico开发板占用的端口 比如我的pico占用的com4端口，com5和com6系统已经使用； 打开com4端口，查看波特率，windows默认是9600,这个没有必要调，但是要记住这个数。后面的minicom的默认波特率是11520,需要修改 三、VirtualBox设置 打开串口：设置-->串口 修改com端口编号为：com4 修改端口模式为：主机设备 修改端口路径：com4 保存后，插上pico开发板 四、Ubuntu设置 终端下查看ubuntu虚拟机下的串口编号，如我的显示为/dev/ttyS3dmesg | grep tty ✔ 15:46:28 [ 0.160978] printk: console [tty0] enabled [ 0.829148] 00:02: ttyS3 at I/O 0x2e8 (irq = 3, base_baud = 115200) is a 16550A 通过minicom连接串口： -b：设置串口波特率，这里同windown系统设置查看的一致，设置为9600 -D：指定串口设备， sudo minicom -b 9600 -D /dev/ttyS3 Welcome to minicom 2.7.1 OPTIONS: I18n Compiled on Dec 23 2019, 02:06:26. Port /dev/ttyS3, 16:23:47 Press CTRL-A Z for help on special keys Hello, world! Hello, world! Hello, world! 终端下将显示hello world! 五、未解决的问题 中途将pico开发板拔下再重插，minicom显示offline，无法接收到数据，暂时未查到原因，除非虚拟机重启。 鄂ICP备15001733号-4 all right reserved，powered by Gitbook该文件修订时间： 2022-04-24 13:08:07 "}}